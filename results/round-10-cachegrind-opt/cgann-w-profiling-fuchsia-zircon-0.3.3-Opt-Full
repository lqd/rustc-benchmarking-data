--------------------------------------------------------------------------------
I1 cache:         65536 B, 64 B, 4-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         67108864 B, 64 B, 64-way associative
Command:          /usr/home/liquid/.rustup/toolchains/w-profiling/bin/rustc --crate-name fuchsia_zircon src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no -C metadata=381dcfc27037642e -C extra-filename=-381dcfc27037642e --out-dir /usr/home/liquid/tmp/.tmp7qqT4I/target/release/deps -L dependency=/usr/home/liquid/tmp/.tmp7qqT4I/target/release/deps --extern bitflags=/usr/home/liquid/tmp/.tmp7qqT4I/target/release/deps/libbitflags-923cad7af34a271a.rmeta --extern fuchsia_zircon_sys=/usr/home/liquid/tmp/.tmp7qqT4I/target/release/deps/libfuchsia_zircon_sys-921eab7b14f25420.rmeta -Adeprecated -Aunknown-lints -Zincremental-verify-ich
Data file:        results/cgout-w-profiling-fuchsia-zircon-0.3.3-Opt-Full
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       0.1
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     
--------------------------------------------------------------------------------
4,569,302,833 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                    file:function
--------------------------------------------------------------------------------
172,292,553 ( 3.77%)  ./malloc/malloc.c:_int_free
150,646,466 ( 3.30%)  ./malloc/malloc.c:_int_malloc
124,498,064 ( 2.72%)  ???:llvm::FPPassManager::runOnFunction(llvm::Function&)
104,496,746 ( 2.29%)  ./malloc/malloc.c:malloc
 54,869,155 ( 1.20%)  ./malloc/malloc.c:free
 52,491,859 ( 1.15%)  ???:llvm::AnalysisManager<llvm::Function>::getResultImpl(llvm::AnalysisKey*, llvm::Function&)
 47,479,233 ( 1.04%)  ???:llvm::AnalysisManager<llvm::Function>::invalidate(llvm::Function&, llvm::PreservedAnalyses const&)
 45,702,327 ( 1.00%)  ???:llvm::SelectionDAG::Combine(llvm::CombineLevel, llvm::AAResults*, llvm::CodeGenOpt::Level)
 40,545,587 ( 0.89%)  ???:llvm::InstCombinerImpl::run()
 40,398,736 ( 0.88%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
 30,297,712 ( 0.66%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::BatchUpdateInfo*)
 29,430,646 ( 0.64%)  ???:combineInstructionsOverFunction(llvm::Function&, llvm::InstCombineWorklist&, llvm::AAResults*, llvm::AssumptionCache&, llvm::TargetLibraryInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::OptimizationRemarkEmitter&, llvm::BlockFrequencyInfo*, llvm::ProfileSummaryInfo*, unsigned int, llvm::LoopInfo*)
 28,034,237 ( 0.61%)  ???:llvm::BitstreamCursor::readRecord(unsigned int, llvm::SmallVectorImpl<unsigned long>&, llvm::StringRef*)
 26,595,501 ( 0.58%)  ???:llvm::AttributeList::addAttributes(llvm::LLVMContext&, unsigned int, llvm::AttrBuilder const&) const
 26,098,717 ( 0.57%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe
 24,702,115 ( 0.54%)  ???:llvm::TargetLibraryInfoImpl::getLibFunc(llvm::Function const&, llvm::LibFunc&) const
 23,845,520 ( 0.52%)  ???:runCVP(llvm::Module&) [clone .llvm.11785992503873176614]
 22,494,235 ( 0.49%)  ./malloc/malloc.c:malloc_consolidate
 19,869,173 ( 0.43%)  ???:llvm::LiveVariables::runOnBlock(llvm::MachineBasicBlock*, unsigned int)
 19,562,494 ( 0.43%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_erms
 19,322,121 ( 0.42%)  ???:llvm::ValueHandleBase::AddToUseList()
 19,208,726 ( 0.42%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::runSemiNCA(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, unsigned int)
 18,566,446 ( 0.41%)  ???:llvm::PMDataManager::verifyPreservedAnalysis(llvm::Pass*)
 17,264,945 ( 0.38%)  ???:llvm::removeUnreachableBlocks(llvm::Function&, llvm::DomTreeUpdater*, llvm::MemorySSAUpdater*)
 17,029,693 ( 0.37%)  ???:llvm::AttributeList::get(llvm::LLVMContext&, llvm::ArrayRef<llvm::AttributeList>)
 16,631,945 ( 0.36%)  ./malloc/malloc.c:unlink_chunk.constprop.0
 16,311,078 ( 0.36%)  ???:llvm::coro::declaresIntrinsics(llvm::Module const&, std::initializer_list<llvm::StringRef>)
 14,898,729 ( 0.33%)  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2
 14,488,122 ( 0.32%)  ???:computeKnownBits(llvm::Value const*, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&) [clone .llvm.15619146473165121143]
 13,633,606 ( 0.30%)  ???:bool llvm::DenseMapBase<llvm::DenseMap<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*, llvm::DenseMapInfo<(anonymous namespace)::SimpleValue>, llvm::detail::DenseMapPair<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*> >, (anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*, llvm::DenseMapInfo<(anonymous namespace)::SimpleValue>, llvm::detail::DenseMapPair<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*> >::LookupBucketFor<(anonymous namespace)::SimpleValue>((anonymous namespace)::SimpleValue const&, llvm::detail::DenseMapPair<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*> const*&) const
 13,581,975 ( 0.30%)  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long)
 13,340,826 ( 0.29%)  ???:(anonymous namespace)::LazyValueInfoImpl::solve() [clone .llvm.4316243980339171764]
 13,276,096 ( 0.29%)  ???:(anonymous namespace)::MachineCopyPropagation::runOnMachineFunction(llvm::MachineFunction&)
 13,078,118 ( 0.29%)  ???:llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::PreservedAnalyses, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&)
 12,701,773 ( 0.28%)  ???:llvm::InstCombinerImpl::visitCallInst(llvm::CallInst&)
 12,474,990 ( 0.27%)  ???:llvm::InstCombinerImpl::visitICmpInst(llvm::ICmpInst&)
 12,078,413 ( 0.26%)  ???:SimplifyICmpInst(unsigned int, llvm::Value*, llvm::Value*, llvm::SimplifyQuery const&, unsigned int) [clone .llvm.1619516508949622737]
 11,953,165 ( 0.26%)  ???:llvm::InstCombinerImpl::SimplifyDemandedUseBits(llvm::Value*, llvm::APInt, llvm::KnownBits&, unsigned int, llvm::Instruction*)
 11,094,962 ( 0.24%)  ???:llvm::simplifyCFG(llvm::BasicBlock*, llvm::TargetTransformInfo const&, llvm::DomTreeUpdater*, llvm::SimplifyCFGOptions const&, llvm::ArrayRef<llvm::WeakVH>)
 10,798,868 ( 0.24%)  ???:llvm::AttributeSetNode::get(llvm::LLVMContext&, llvm::AttrBuilder const&)
 10,797,950 ( 0.24%)  ???:llvm::FindFunctionBackedges(llvm::Function const&, llvm::SmallVectorImpl<std::pair<llvm::BasicBlock const*, llvm::BasicBlock const*> >&)
 10,769,220 ( 0.24%)  ???:llvm::LiveVariables::HandleRegMask(llvm::MachineOperand const&)
 10,739,863 ( 0.24%)  ???:isKnownNonZero(llvm::Value const*, llvm::APInt const&, unsigned int, (anonymous namespace)::Query const&) [clone .llvm.15619146473165121143]
 10,598,308 ( 0.23%)  /usr/home/liquid/rust/worktree-benchmarking/library/core/src/num/uint_macros.rs:<rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<u64>
 10,309,110 ( 0.23%)  ./elf/dl-lookup.c:_dl_lookup_symbol_x
 10,283,344 ( 0.23%)  ???:llvm::PassRegistry::enumerateWith(llvm::PassRegistrationListener*)
 10,242,303 ( 0.22%)  ???:(anonymous namespace)::SimplifyCFGOpt::simplifyCondBranch(llvm::BranchInst*, llvm::IRBuilder<llvm::ConstantFolder, llvm::IRBuilderDefaultInserter>&)
 10,048,234 ( 0.22%)  ???:llvm::InlineFunction(llvm::CallBase&, llvm::InlineFunctionInfo&, llvm::AAResults*, bool, llvm::Function*)
  9,790,975 ( 0.21%)  ???:(anonymous namespace)::LazyValueInfoImpl::getEdgeValue(llvm::Value*, llvm::BasicBlock*, llvm::BasicBlock*, llvm::Instruction*) [clone .llvm.4316243980339171764]
  9,515,721 ( 0.21%)  ???:llvm::DataLayout::getAlignment(llvm::Type*, bool) const
  9,307,827 ( 0.20%)  ./malloc/malloc.c:calloc
  9,231,893 ( 0.20%)  ???:llvm::MD5::final(llvm::MD5::MD5Result&)
  9,067,812 ( 0.20%)  ???:llvm::PMDataManager::removeNotPreservedAnalysis(llvm::Pass*)
  8,970,289 ( 0.20%)  ???:llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode*, unsigned char const*, unsigned int)
  8,956,479 ( 0.20%)  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2
  8,918,420 ( 0.20%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::BasicBlock, true>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::BatchUpdateInfo*)
  8,709,542 ( 0.19%)  ???:computeKnownBitsFromOperator(llvm::Operator const*, llvm::APInt const&, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&)
  8,599,514 ( 0.19%)  ???:llvm::SimplifyInstruction(llvm::Instruction*, llvm::SimplifyQuery const&, llvm::OptimizationRemarkEmitter*)
  8,550,760 ( 0.19%)  ???:llvm::AttributeList::addAttribute(llvm::LLVMContext&, unsigned int, llvm::Attribute::AttrKind) const
  8,526,473 ( 0.19%)  ???:(anonymous namespace)::EarlyCSE::run() [clone .llvm.7062997131228810369]
  8,513,872 ( 0.19%)  ???:(anonymous namespace)::DeadMachineInstructionElim::eliminateDeadMI(llvm::MachineFunction&)
  8,504,015 ( 0.19%)  ???:llvm::DataLayout::getTypeSizeInBits(llvm::Type*) const
  8,456,687 ( 0.19%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
  8,324,010 ( 0.18%)  ./malloc/malloc.c:realloc
  8,215,362 ( 0.18%)  ???:computeKnownBits(llvm::Value const*, llvm::APInt const&, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&)
  8,068,547 ( 0.18%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::FindRoots(llvm::DominatorTreeBase<llvm::BasicBlock, true> const&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::BatchUpdateInfo*)
  7,767,363 ( 0.17%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilderMut<rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_hash::<hashbrown::map::equivalent<rustc_middle::ty::sty::TyKind, rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>>::{closure#0}>
  7,482,138 ( 0.16%)  ???:llvm::ScheduleDAGSDNodes::BuildSchedUnits()
  7,461,637 ( 0.16%)  ???:llvm::LivePhysRegs::stepBackward(llvm::MachineInstr const&)
  7,253,761 ( 0.16%)  ???:llvm::TargetLoweringBase::getTypeConversion(llvm::LLVMContext&, llvm::EVT) const
  7,137,696 ( 0.16%)  ???:llvm::X86TargetLowering::X86TargetLowering(llvm::X86TargetMachine const&, llvm::X86Subtarget const&)
  7,128,330 ( 0.16%)  ???:???
  7,109,424 ( 0.16%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/sip128.rs:<rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<u64>
  6,763,722 ( 0.15%)  ???:(anonymous namespace)::BitcodeReader::parseModule(unsigned long, bool, llvm::function_ref<llvm::Optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > (llvm::StringRef)>)
  6,697,576 ( 0.15%)  ???:llvm::MachineInstr::addOperand(llvm::MachineFunction&, llvm::MachineOperand const&)
  6,661,540 ( 0.15%)  ???:llvm::SROA::runOnAlloca(llvm::AllocaInst&)
  6,476,740 ( 0.14%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_trait_selection/src/traits/fulfill.rs:<rustc_data_structures::obligation_forest::ObligationForest<rustc_trait_selection::traits::fulfill::PendingPredicateObligation>>::process_obligations::<rustc_trait_selection::traits::fulfill::FulfillProcessor, rustc_data_structures::obligation_forest::Outcome<rustc_trait_selection::traits::fulfill::PendingPredicateObligation, rustc_infer::traits::FulfillmentErrorCode>>
  6,374,262 ( 0.14%)  ???:llvm::FoldingSetBase::FindNodeOrInsertPos(llvm::FoldingSetNodeID const&, void*&, llvm::FoldingSetBase::FoldingSetInfo const&)
  6,321,452 ( 0.14%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilder<rustc_span::def_id::LocalDefId, (&rustc_middle::ty::context::TypeckResults, rustc_query_system::dep_graph::graph::DepNodeIndex), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_key_hashed_nocheck::<rustc_span::def_id::LocalDefId>
  6,316,802 ( 0.14%)  ???:llvm::MemorySSA::buildMemorySSA(llvm::BatchAAResults&)
  6,258,374 ( 0.14%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/obligation_forest/mod.rs:<rustc_data_structures::obligation_forest::ObligationForest<rustc_trait_selection::traits::fulfill::PendingPredicateObligation>>::process_obligations::<rustc_trait_selection::traits::fulfill::FulfillProcessor, rustc_data_structures::obligation_forest::Outcome<rustc_trait_selection::traits::fulfill::PendingPredicateObligation, rustc_infer::traits::FulfillmentErrorCode>>
  6,226,998 ( 0.14%)  /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs:<rustc_middle::hir::map::Map>::attrs
  6,164,299 ( 0.13%)  ???:llvm::ConstantRange::makeExactICmpRegion(llvm::CmpInst::Predicate, llvm::APInt const&)
  6,105,920 ( 0.13%)  ???:llvm::TargetLoweringBase::computeRegisterProperties(llvm::TargetRegisterInfo const*)
  5,960,191 ( 0.13%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::DeleteEdge(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::BatchUpdateInfo*, llvm::BasicBlock*, llvm::BasicBlock*)
  5,949,231 ( 0.13%)  /usr/home/liquid/rust/worktree-benchmarking/library/std/src/sys/unix/alloc.rs:__rdl_alloc
  5,941,018 ( 0.13%)  ???:llvm::MD5::update(llvm::StringRef)
  5,887,783 ( 0.13%)  ???:(anonymous namespace)::DAGCombiner::combine(llvm::SDNode*)
  5,861,114 ( 0.13%)  ???:llvm::SmallPtrSetImplBase::insert_imp_big(void const*)
  5,830,981 ( 0.13%)  ???:llvm::BlockFrequencyInfoImpl<llvm::BasicBlock>::initializeRPOT()
  5,808,092 ( 0.13%)  ???:(anonymous namespace)::CVPLatticeFunc::ComputeInstructionState(llvm::Instruction&, llvm::DenseMap<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > >, (anonymous namespace)::CVPLatticeVal, llvm::DenseMapInfo<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > > >, llvm::detail::DenseMapPair<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > >, (anonymous namespace)::CVPLatticeVal> >&, llvm::SparseSolver<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > >, (anonymous namespace)::CVPLatticeVal, llvm::LatticeKeyInfo<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > > > >&)
  5,806,906 ( 0.13%)  ./malloc/malloc.c:_int_realloc
  5,792,282 ( 0.13%)  ???:llvm::JumpThreadingPass::processBlock(llvm::BasicBlock*)
  5,761,006 ( 0.13%)  ???:llvm::X86TargetMachine::getTargetTransformInfo(llvm::Function const&)
  5,592,883 ( 0.12%)  ???:computeKnownBitsFromAssume(llvm::Value const*, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&)
  5,557,383 ( 0.12%)  ???:(anonymous namespace)::LazyValueInfoImpl::getValueInBlock(llvm::Value*, llvm::BasicBlock*, llvm::Instruction*) [clone .llvm.4316243980339171764]
  5,499,746 ( 0.12%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/caching_source_map_view.rs:<rustc_span::caching_source_map_view::CachingSourceMapView>::span_data_to_lines_and_cols
  5,459,932 ( 0.12%)  ???:(anonymous namespace)::AggressiveDeadCodeElimination::performDeadCodeElimination()
  5,430,393 ( 0.12%)  ???:llvm::PopulateLoopsDFS<llvm::BasicBlock, llvm::Loop>::traverse(llvm::BasicBlock*)
  5,336,007 ( 0.12%)  ???:llvm::LoopInfoBase<llvm::BasicBlock, llvm::Loop>::analyze(llvm::DominatorTreeBase<llvm::BasicBlock, false> const&)
  5,094,645 ( 0.11%)  ./stdlib/msort.c:msort_with_tmp.part.0
  5,081,649 ( 0.11%)  ???:llvm::ConstantFoldTerminator(llvm::BasicBlock*, bool, llvm::TargetLibraryInfo const*, llvm::DomTreeUpdater*)
  5,010,825 ( 0.11%)  ???:llvm::BlockFrequencyInfoImplBase::finalizeMetrics()
  5,006,540 ( 0.11%)  ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2
  4,993,268 ( 0.11%)  ???:llvm::X86TargetMachine::getSubtargetImpl(llvm::Function const&) const
  4,973,661 ( 0.11%)  ???:llvm::DAGTypeLegalizer::run()
  4,848,738 ( 0.11%)  ???:llvm::SelectionDAG::Legalize()
  4,845,521 ( 0.11%)  ./elf/dl-lookup.c:do_lookup_x
  4,834,967 ( 0.11%)  ???:llvm::BlockFrequencyInfoImpl<llvm::BasicBlock>::tryToComputeMassInFunction()
  4,780,809 ( 0.10%)  ???:llvm::X86InstrInfo::analyzeBranch(llvm::MachineBasicBlock&, llvm::MachineBasicBlock*&, llvm::MachineBasicBlock*&, llvm::SmallVectorImpl<llvm::MachineOperand>&, bool) const
  4,712,357 ( 0.10%)  ???:llvm::LiveIntervals::HMEditor::updateAllRanges(llvm::MachineInstr*)
  4,711,022 ( 0.10%)  ???:llvm::FoldBranchToCommonDest(llvm::BranchInst*, llvm::DomTreeUpdater*, llvm::MemorySSAUpdater*, llvm::TargetTransformInfo const*, unsigned int)
  4,690,348 ( 0.10%)  ???:(anonymous namespace)::SelectionDAGLegalize::LegalizeOp(llvm::SDNode*) [clone .llvm.8386621111310650999]
  4,677,661 ( 0.10%)  ???:llvm::SSAUpdater::GetValueAtEndOfBlockInternal(llvm::BasicBlock*)
  4,660,233 ( 0.10%)  ???:llvm::DemandedBits::isInstructionDead(llvm::Instruction*)
  4,643,756 ( 0.10%)  ???:llvm::SROA::runImpl(llvm::Function&, llvm::DominatorTree&, llvm::AssumptionCache&)
  4,590,363 ( 0.10%)  ???:std::back_insert_iterator<std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> > > std::__copy_move_a2<false, llvm::po_iterator<llvm::Function const*, llvm::SmallPtrSet<llvm::BasicBlock const*, 8u>, false, llvm::GraphTraits<llvm::Function const*> >, std::back_insert_iterator<std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> > > >(llvm::po_iterator<llvm::Function const*, llvm::SmallPtrSet<llvm::BasicBlock const*, 8u>, false, llvm::GraphTraits<llvm::Function const*> >, llvm::po_iterator<llvm::Function const*, llvm::SmallPtrSet<llvm::BasicBlock const*, 8u>, false, llvm::GraphTraits<llvm::Function const*> >, std::back_insert_iterator<std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> > >)
  4,585,212 ( 0.10%)  ???:llvm::DenseMapBase<llvm::DenseMap<llvm::PoisoningVH<llvm::BasicBlock>, std::unique_ptr<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry, std::default_delete<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry> >, llvm::DenseMapInfo<llvm::PoisoningVH<llvm::BasicBlock> >, llvm::detail::DenseMapPair<llvm::PoisoningVH<llvm::BasicBlock>, std::unique_ptr<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry, std::default_delete<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry> > > >, llvm::PoisoningVH<llvm::BasicBlock>, std::unique_ptr<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry, std::default_delete<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry> >, llvm::DenseMapInfo<llvm::PoisoningVH<llvm::BasicBlock> >, llvm::detail::DenseMapPair<llvm::PoisoningVH<llvm::BasicBlock>, std::unique_ptr<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry, std::default_delete<(anonymous namespace)::LazyValueInfoCache::BlockCacheEntry> > > >::destroyAll() [clone .llvm.4316243980339171764]

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/library/core/src/num/uint_macros.rs
--------------------------------------------------------------------------------
Ir                  

-- line 57 ----------------------------------------
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
         .                   ///
         .                   /// ```
         .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::from_str_radix(\"A\", 16), Ok(10));")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
       852 ( 0.00%)          pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
       426 ( 0.00%)              from_str_radix(src, radix)
     1,278 ( 0.00%)          }
         .           
         .                   /// Returns the number of ones in the binary representation of `self`.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
         .                   ///
         .                   /// ```
-- line 75 ----------------------------------------
-- line 80 ----------------------------------------
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
         .                   #[doc(alias = "popcount")]
         .                   #[doc(alias = "popcnt")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn count_ones(self) -> u32 {
   357,345 ( 0.01%)              intrinsics::ctpop(self as $ActualT) as u32
         .                   }
         .           
         .                   /// Returns the number of zeros in the binary representation of `self`.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
         .                   ///
-- line 96 ----------------------------------------
-- line 118 ----------------------------------------
         .                   /// assert_eq!(n.leading_zeros(), 2);
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn leading_zeros(self) -> u32 {
   572,109 ( 0.01%)              intrinsics::ctlz(self as $ActualT) as u32
         .                   }
         .           
         .                   /// Returns the number of trailing zeros in the binary representation
         .                   /// of `self`.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 134 ----------------------------------------
-- line 139 ----------------------------------------
         .                   /// assert_eq!(n.trailing_zeros(), 3);
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn trailing_zeros(self) -> u32 {
   481,061 ( 0.01%)              intrinsics::cttz(self) as u32
         .                   }
         .           
         .                   /// Returns the number of leading ones in the binary representation of `self`.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
         .                   ///
-- line 155 ----------------------------------------
-- line 204 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(n.rotate_left(", $rot, "), m);")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn rotate_left(self, n: u32) -> Self {
11,855,708 ( 0.26%)              intrinsics::rotate_left(self, n as $SelfT)
         .                   }
         .           
         .                   /// Shifts the bits to the right by a specified amount, `n`,
         .                   /// wrapping the truncated bits to the beginning of the resulting
         .                   /// integer.
         .                   ///
         .                   /// Please note this isn't the same operation as the `>>` shifting operator!
         .                   ///
-- line 220 ----------------------------------------
-- line 430 ----------------------------------------
         .                   #[doc = concat!("assert_eq!((", stringify!($SelfT), "::MAX - 2).checked_add(3), None);")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_checked_int_methods", since = "1.47.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline]
         .                   pub const fn checked_add(self, rhs: Self) -> Option<Self> {
         4 ( 0.00%)              let (a, b) = self.overflowing_add(rhs);
         .                       if unlikely!(b) {None} else {Some(a)}
         .                   }
         .           
         .                   /// Unchecked integer addition. Computes `self + rhs`, assuming overflow
         .                   /// cannot occur.
         .                   ///
         .                   /// # Safety
         .                   ///
-- line 446 ----------------------------------------
-- line 456 ----------------------------------------
         .                   )]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[rustc_const_unstable(feature = "const_inherent_unchecked_arith", issue = "85122")]
         .                   #[inline(always)]
         .                   pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
         .                       // SAFETY: the caller must uphold the safety contract for
         .                       // `unchecked_add`.
 1,089,618 ( 0.02%)              unsafe { intrinsics::unchecked_add(self, rhs) }
         .                   }
         .           
         .                   /// Checked addition with a signed integer. Computes `self + rhs`,
         .                   /// returning `None` if overflow occurred.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 472 ----------------------------------------
-- line 525 ----------------------------------------
         .                   )]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[rustc_const_unstable(feature = "const_inherent_unchecked_arith", issue = "85122")]
         .                   #[inline(always)]
         .                   pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
         .                       // SAFETY: the caller must uphold the safety contract for
         .                       // `unchecked_sub`.
    70,501 ( 0.00%)              unsafe { intrinsics::unchecked_sub(self, rhs) }
         .                   }
         .           
         .                   /// Checked integer multiplication. Computes `self * rhs`, returning
         .                   /// `None` if overflow occurred.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 541 ----------------------------------------
-- line 596 ----------------------------------------
         .                                 without modifying the original"]
         .                   #[inline]
         .                   pub const fn checked_div(self, rhs: Self) -> Option<Self> {
         .                       if unlikely!(rhs == 0) {
         .                           None
         .                       } else {
         .                           // SAFETY: div by zero has been checked above and unsigned types have no other
         .                           // failure modes for division
       608 ( 0.00%)                  Some(unsafe { intrinsics::unchecked_div(self, rhs) })
         .                       }
         .                   }
         .           
         .                   /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`
         .                   /// if `rhs == 0`.
         .                   ///
         .                   /// # Examples
         .                   ///
-- line 612 ----------------------------------------
-- line 1035 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.saturating_add(127), ", stringify!($SelfT), "::MAX);")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
         .                   #[inline(always)]
         .                   pub const fn saturating_add(self, rhs: Self) -> Self {
   262,864 ( 0.01%)              intrinsics::saturating_add(self, rhs)
         .                   }
         .           
         .                   /// Saturating addition with a signed integer. Computes `self + rhs`,
         .                   /// saturating at the numeric bounds instead of overflowing.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 1051 ----------------------------------------
-- line 1084 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(13", stringify!($SelfT), ".saturating_sub(127), 0);")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
         .                   #[inline(always)]
         .                   pub const fn saturating_sub(self, rhs: Self) -> Self {
    16,779 ( 0.00%)              intrinsics::saturating_sub(self, rhs)
         .                   }
         .           
         .                   /// Saturating integer multiplication. Computes `self * rhs`,
         .                   /// saturating at the numeric bounds instead of overflowing.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 1100 ----------------------------------------
-- line 1175 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(200", stringify!($SelfT), ".wrapping_add(", stringify!($SelfT), "::MAX), 199);")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn wrapping_add(self, rhs: Self) -> Self {
 6,581,370 ( 0.14%)              intrinsics::wrapping_add(self, rhs)
         .                   }
         .           
         .                   /// Wrapping (modular) addition with a signed integer. Computes
         .                   /// `self + rhs`, wrapping around at the boundary of the type.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 1191 ----------------------------------------
-- line 1217 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(100", stringify!($SelfT), ".wrapping_sub(", stringify!($SelfT), "::MAX), 101);")]
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn wrapping_sub(self, rhs: Self) -> Self {
 2,025,104 ( 0.04%)              intrinsics::wrapping_sub(self, rhs)
         .                   }
         .           
         .                   /// Wrapping (modular) multiplication. Computes `self *
         .                   /// rhs`, wrapping around at the boundary of the type.
         .                   ///
         .                   /// # Examples
         .                   ///
         .                   /// Basic usage:
-- line 1233 ----------------------------------------
-- line 1240 ----------------------------------------
         .                   /// assert_eq!(25u8.wrapping_mul(12), 44);
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn wrapping_mul(self, rhs: Self) -> Self {
 6,611,259 ( 0.14%)              intrinsics::wrapping_mul(self, rhs)
         .                   }
         .           
         .                   /// Wrapping (modular) division. Computes `self / rhs`.
         .                   /// Wrapped division on unsigned types is just normal division.
         .                   /// There's no way wrapping could ever happen.
         .                   /// This function exists, so that all operations
         .                   /// are accounted for in the wrapping operations.
         .                   ///
-- line 1256 ----------------------------------------
-- line 1397 ----------------------------------------
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn wrapping_shl(self, rhs: u32) -> Self {
         .                       // SAFETY: the masking by the bitsize of the type ensures that we do not shift
         .                       // out of bounds
         .                       unsafe {
       522 ( 0.00%)                  intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)
         .                       }
         .                   }
         .           
         .                   /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,
         .                   /// where `mask` removes any high-order bits of `rhs` that
         .                   /// would cause the shift to exceed the bitwidth of the type.
         .                   ///
         .                   /// Note that this is *not* the same as a rotate-right; the
-- line 1413 ----------------------------------------
-- line 1492 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.overflowing_add(1), (0, true));")]
         .                   /// ```
         .                   #[stable(feature = "wrapping", since = "1.7.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
   921,534 ( 0.02%)              let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
         .                       (a as Self, b)
         .                   }
         .           
         .                   /// Calculates `self + rhs + carry` without the ability to overflow.
         .                   ///
         .                   /// Performs "ternary addition" which takes in an extra bit to add, and may return an
         .                   /// additional bit of overflow. This allows for chaining together multiple additions
         .                   /// to create "big integers" which represent larger values.
-- line 1508 ----------------------------------------
-- line 1587 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(5", stringify!($SelfT), ".overflowing_sub(2), (3, false));")]
         .                   #[doc = concat!("assert_eq!(0", stringify!($SelfT), ".overflowing_sub(1), (", stringify!($SelfT), "::MAX, true));")]
         .                   /// ```
         .                   #[stable(feature = "wrapping", since = "1.7.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
       528 ( 0.00%)          pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
   182,912 ( 0.00%)              let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
         .                       (a as Self, b)
     1,056 ( 0.00%)          }
         .           
         .                   /// Calculates `self - rhs - borrow` without the ability to overflow.
         .                   ///
         .                   /// Performs "ternary subtraction" which takes in an extra bit to subtract, and may return
         .                   /// an additional bit of overflow. This allows for chaining together multiple subtractions
         .                   /// to create "big integers" which represent larger values.
         .                   ///
         .                   /// # Examples
-- line 1606 ----------------------------------------
-- line 1674 ----------------------------------------
         .                   /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));
         .                   /// ```
         .                   #[stable(feature = "wrapping", since = "1.7.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                     without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
 1,841,882 ( 0.04%)              let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
         .                       (a as Self, b)
         .                   }
         .           
         .                   /// Calculates the divisor when `self` is divided by `rhs`.
         .                   ///
         .                   /// Returns a tuple of the divisor along with a boolean indicating
         .                   /// whether an arithmetic overflow would occur. Note that for unsigned
         .                   /// integers overflow never occurs, so the second value is always
-- line 1690 ----------------------------------------
-- line 1838 ----------------------------------------
         .                   #[doc = concat!("assert_eq!(0x1", stringify!($SelfT), ".overflowing_shl(132), (0x10, true));")]
         .                   /// ```
         .                   #[stable(feature = "wrapping", since = "1.7.0")]
         .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline(always)]
         .                   pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {
       174 ( 0.00%)              (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))
         .                   }
         .           
         .                   /// Shifts self right by `rhs` bits.
         .                   ///
         .                   /// Returns a tuple of the shifted version of self along with a boolean
         .                   /// indicating whether the shift value was larger than or equal to the
         .                   /// number of bits. If the shift value is too large, then value is
         .                   /// masked (N-1) where N is the number of bits, and this value is then
-- line 1854 ----------------------------------------
-- line 2132 ----------------------------------------
         .                   #[doc = concat!("assert!(16", stringify!($SelfT), ".is_power_of_two());")]
         .                   #[doc = concat!("assert!(!10", stringify!($SelfT), ".is_power_of_two());")]
         .                   /// ```
         .                   #[must_use]
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_is_power_of_two", since = "1.32.0")]
         .                   #[inline(always)]
         .                   pub const fn is_power_of_two(self) -> bool {
       180 ( 0.00%)              self.count_ones() == 1
         .                   }
         .           
         .                   // Returns one less than next power of two.
         .                   // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)
         .                   //
         .                   // 8u8.one_less_than_next_power_of_two() == 7
         .                   // 6u8.one_less_than_next_power_of_two() == 7
         .                   //
         .                   // This method cannot overflow, as in the `next_power_of_two`
         .                   // overflow cases it instead ends up returning the maximum value
         .                   // of the type, and can return 0 for 0.
         .                   #[inline]
         .                   #[rustc_const_stable(feature = "const_int_pow", since = "1.50.0")]
         .                   const fn one_less_than_next_power_of_two(self) -> Self {
    13,122 ( 0.00%)              if self <= 1 { return 0; }
         .           
    25,449 ( 0.00%)              let p = self - 1;
         .                       // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
         .                       // That means the shift is always in-bounds, and some processors
         .                       // (such as intel pre-haswell) have more efficient ctlz
         .                       // intrinsics when the argument is non-zero.
    76,235 ( 0.00%)              let z = unsafe { intrinsics::ctlz_nonzero(p) };
    25,457 ( 0.00%)              <$SelfT>::MAX >> z
         .                   }
         .           
         .                   /// Returns the smallest power of two greater than or equal to `self`.
         .                   ///
         .                   /// When return value overflows (i.e., `self > (1 << (N-1))` for type
         .                   /// `uN`), it panics in debug mode and the return value is wrapped to 0 in
         .                   /// release mode (the only situation in which method can return 0).
         .                   ///
-- line 2171 ----------------------------------------
-- line 2179 ----------------------------------------
         .                   /// ```
         .                   #[stable(feature = "rust1", since = "1.0.0")]
         .                   #[rustc_const_stable(feature = "const_int_pow", since = "1.50.0")]
         .                   #[must_use = "this returns the result of the operation, \
         .                                 without modifying the original"]
         .                   #[inline]
         .                   #[rustc_inherit_overflow_checks]
         .                   pub const fn next_power_of_two(self) -> Self {
    37,724 ( 0.00%)              self.one_less_than_next_power_of_two() + 1
         .                   }
         .           
         .                   /// Returns the smallest power of two greater than or equal to `n`. If
         .                   /// the next power of two is greater than the type's maximum value,
         .                   /// `None` is returned, otherwise the power of two is wrapped in `Some`.
         .                   ///
         .                   /// # Examples
         .                   ///
-- line 2195 ----------------------------------------

   125,846 ( 0.00%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/library/core/src/num/uint_macros.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/caching_source_map_view.rs
--------------------------------------------------------------------------------
Ir                 

-- line 27 ----------------------------------------
        .           impl CacheEntry {
        .               #[inline]
        .               fn update(
        .                   &mut self,
        .                   new_file_and_idx: Option<(Lrc<SourceFile>, usize)>,
        .                   pos: BytePos,
        .                   time_stamp: usize,
        .               ) {
   14,718 ( 0.00%)          if let Some((file, file_idx)) = new_file_and_idx {
    9,111 ( 0.00%)              self.file = file;
   14,475 ( 0.00%)              self.file_index = file_idx;
        .                   }
        .           
    4,531 ( 0.00%)          let line_index = self.file.lookup_line(pos).unwrap();
        .                   let line_bounds = self.file.line_bounds(line_index);
   24,786 ( 0.00%)          self.line_number = line_index + 1;
   36,641 ( 0.00%)          self.line = line_bounds;
        .                   self.touch(time_stamp);
        .               }
        .           
        .               #[inline]
        .               fn touch(&mut self, time_stamp: usize) {
  138,414 ( 0.00%)          self.time_stamp = time_stamp;
        .               }
        .           }
        .           
        .           #[derive(Clone)]
        .           pub struct CachingSourceMapView<'sm> {
        .               source_map: &'sm SourceMap,
        .               line_cache: [CacheEntry; 3],
        .               time_stamp: usize,
        .           }
        .           
        .           impl<'sm> CachingSourceMapView<'sm> {
    6,528 ( 0.00%)      pub fn new(source_map: &'sm SourceMap) -> CachingSourceMapView<'sm> {
        .                   let files = source_map.files();
    3,264 ( 0.00%)          let first_file = files[0].clone();
        .                   let entry = CacheEntry {
        .                       time_stamp: 0,
        .                       line_number: 0,
        .                       line: BytePos(0)..BytePos(0),
        .                       file: first_file,
        .                       file_index: 0,
        .                   };
        .           
   16,320 ( 0.00%)          CachingSourceMapView {
        .                       source_map,
   22,848 ( 0.00%)              line_cache: [entry.clone(), entry.clone(), entry],
        .                       time_stamp: 0,
        .                   }
   13,056 ( 0.00%)      }
        .           
        .               pub fn byte_pos_to_line_and_col(
        .                   &mut self,
        .                   pos: BytePos,
        .               ) -> Option<(Lrc<SourceFile>, usize, BytePos)> {
        .                   self.time_stamp += 1;
        .           
        .                   // Check if the position is in one of the cached lines
-- line 85 ----------------------------------------
-- line 106 ----------------------------------------
        .                   };
        .           
        .                   let cache_entry = &mut self.line_cache[oldest];
        .                   cache_entry.update(new_file_and_idx, pos, self.time_stamp);
        .           
        .                   Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))
        .               }
        .           
  523,453 ( 0.01%)      pub fn span_data_to_lines_and_cols(
        .                   &mut self,
        .                   span_data: &SpanData,
        .               ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {
  299,116 ( 0.01%)          self.time_stamp += 1;
        .           
        .                   // Check if lo and hi are in the cached lines.
   74,779 ( 0.00%)          let lo_cache_idx = self.cache_entry_index(span_data.lo);
   74,779 ( 0.00%)          let hi_cache_idx = self.cache_entry_index(span_data.hi);
        .           
  127,880 ( 0.00%)          if lo_cache_idx != -1 && hi_cache_idx != -1 {
        .                       // Cache hit for span lo and hi. Check if they belong to the same file.
        .                       let result = {
  127,270 ( 0.00%)                  let lo = &self.line_cache[lo_cache_idx as usize];
        .                           let hi = &self.line_cache[hi_cache_idx as usize];
        .           
  381,810 ( 0.01%)                  if lo.file_index != hi.file_index {
        .                               return None;
        .                           }
        .           
        .                           (
  127,270 ( 0.00%)                      lo.file.clone(),
        .                               lo.line_number,
        .                               span_data.lo - lo.line.start,
   63,635 ( 0.00%)                      hi.line_number,
        .                               span_data.hi - hi.line.start,
        .                           )
        .                       };
        .           
   63,635 ( 0.00%)              self.line_cache[lo_cache_idx as usize].touch(self.time_stamp);
   63,635 ( 0.00%)              self.line_cache[hi_cache_idx as usize].touch(self.time_stamp);
        .           
  254,540 ( 0.01%)              return Some(result);
        .                   }
        .           
        .                   // No cache hit or cache hit for only one of span lo and hi.
   21,678 ( 0.00%)          let oldest = if lo_cache_idx != -1 || hi_cache_idx != -1 {
        .                       let avoid_idx = if lo_cache_idx != -1 { lo_cache_idx } else { hi_cache_idx };
        .                       self.oldest_cache_entry_index_avoid(avoid_idx as usize)
        .                   } else {
        .                       self.oldest_cache_entry_index()
        .                   };
        .           
        .                   // If the entry doesn't point to the correct file, get the new file and index.
        .                   // Return early if the file containing beginning of span doesn't contain end of span.
   86,780 ( 0.00%)          let new_file_and_idx = if !file_contains(&self.line_cache[oldest].file, span_data.lo) {
   33,065 ( 0.00%)              let new_file_and_idx = self.file_for_position(span_data.lo)?;
   39,678 ( 0.00%)              if !file_contains(&new_file_and_idx.0, span_data.hi) {
        .                           return None;
        .                       }
        .           
   26,452 ( 0.00%)              Some(new_file_and_idx)
        .                   } else {
        .                       let file = &self.line_cache[oldest].file;
   13,593 ( 0.00%)              if !file_contains(&file, span_data.hi) {
        .                           return None;
        .                       }
        .           
   13,593 ( 0.00%)              None
        .                   };
        .           
        .                   // Update the cache entries.
   55,720 ( 0.00%)          let (lo_idx, hi_idx) = match (lo_cache_idx, hi_cache_idx) {
        .                       // Oldest cache entry is for span_data.lo line.
        .                       (-1, -1) => {
        .                           let lo = &mut self.line_cache[oldest];
        .                           lo.update(new_file_and_idx, span_data.lo, self.time_stamp);
        .           
   27,156 ( 0.00%)                  if !lo.line.contains(&span_data.hi) {
        .                               let new_file_and_idx = Some((lo.file.clone(), lo.file_index));
        .                               let next_oldest = self.oldest_cache_entry_index_avoid(oldest);
        .                               let hi = &mut self.line_cache[next_oldest];
        .                               hi.update(new_file_and_idx, span_data.hi, self.time_stamp);
        .                               (oldest, next_oldest)
        .                           } else {
        .                               (oldest, oldest)
        .                           }
        .                       }
        .                       // Oldest cache entry is for span_data.lo line.
        .                       (-1, _) => {
        .                           let lo = &mut self.line_cache[oldest];
        .                           lo.update(new_file_and_idx, span_data.lo, self.time_stamp);
      610 ( 0.00%)                  let hi = &mut self.line_cache[hi_cache_idx as usize];
      915 ( 0.00%)                  hi.touch(self.time_stamp);
        .                           (oldest, hi_cache_idx as usize)
        .                       }
        .                       // Oldest cache entry is for span_data.hi line.
        .                       (_, -1) => {
        .                           let hi = &mut self.line_cache[oldest];
    1,787 ( 0.00%)                  hi.update(new_file_and_idx, span_data.hi, self.time_stamp);
    3,574 ( 0.00%)                  let lo = &mut self.line_cache[lo_cache_idx as usize];
    7,148 ( 0.00%)                  lo.touch(self.time_stamp);
        .                           (lo_cache_idx as usize, oldest)
        .                       }
        .                       _ => {
        .                           panic!();
        .                       }
        .                   };
        .           
        .                   let lo = &self.line_cache[lo_idx];
        .                   let hi = &self.line_cache[hi_idx];
        .           
        .                   // Span lo and hi may equal line end when last line doesn't
        .                   // end in newline, hence the inclusive upper bounds below.
   22,288 ( 0.00%)          assert!(span_data.lo >= lo.line.start);
   11,144 ( 0.00%)          assert!(span_data.lo <= lo.line.end);
   22,288 ( 0.00%)          assert!(span_data.hi >= hi.line.start);
   11,144 ( 0.00%)          assert!(span_data.hi <= hi.line.end);
   55,720 ( 0.00%)          assert!(lo.file.contains(span_data.lo));
   33,432 ( 0.00%)          assert!(lo.file.contains(span_data.hi));
   33,432 ( 0.00%)          assert_eq!(lo.file_index, hi.file_index);
        .           
   33,432 ( 0.00%)          Some((
   11,144 ( 0.00%)              lo.file.clone(),
        .                       lo.line_number,
        .                       span_data.lo - lo.line.start,
   11,144 ( 0.00%)              hi.line_number,
        .                       span_data.hi - hi.line.start,
        .                   ))
  673,011 ( 0.01%)      }
        .           
        .               fn cache_entry_index(&self, pos: BytePos) -> isize {
        .                   for (idx, cache_entry) in self.line_cache.iter().enumerate() {
  730,067 ( 0.02%)              if cache_entry.line.contains(&pos) {
        .                           return idx as isize;
        .                       }
        .                   }
        .           
        .                   -1
        .               }
        .           
        .               fn oldest_cache_entry_index(&self) -> usize {
        .                   let mut oldest = 0;
        .           
        .                   for idx in 1..self.line_cache.len() {
   54,312 ( 0.00%)              if self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp {
        .                           oldest = idx;
        .                       }
        .                   }
        .           
        .                   oldest
        .               }
        .           
        .               fn oldest_cache_entry_index_avoid(&self, avoid_idx: usize) -> usize {
        .                   let mut oldest = if avoid_idx != 0 { 0 } else { 1 };
        .           
        .                   for idx in 0..self.line_cache.len() {
   19,681 ( 0.00%)              if idx != avoid_idx
   10,234 ( 0.00%)                  && self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp
        .                       {
        .                           oldest = idx;
        .                       }
        .                   }
        .           
        .                   oldest
        .               }
        .           
   33,065 ( 0.00%)      fn file_for_position(&self, pos: BytePos) -> Option<(Lrc<SourceFile>, usize)> {
    6,613 ( 0.00%)          if !self.source_map.files().is_empty() {
   13,226 ( 0.00%)              let file_idx = self.source_map.lookup_source_file_idx(pos);
        .                       let file = &self.source_map.files()[file_idx];
        .           
   52,904 ( 0.00%)              if file_contains(file, pos) {
        .                           return Some((file.clone(), file_idx));
        .                       }
        .                   }
        .           
        .                   None
   33,065 ( 0.00%)      }
        .           }
        .           
        .           #[inline]
        .           fn file_contains(file: &SourceFile, pos: BytePos) -> bool {
        .               // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position
        .               // one past the end of a file to belong to it. Normally, that's what we want. But for the
        .               // purposes of converting a byte position to a line and column number, we can't come up with a
        .               // line and column number if the file is empty, because an empty file doesn't contain any
-- line 290 ----------------------------------------

1,024,272 ( 0.02%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/caching_source_map_view.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/sip128.rs
--------------------------------------------------------------------------------
Ir                 

-- line 91 ----------------------------------------
        .           // maximum of number bytes needed to fill an 8-byte-sized element on which
        .           // SipHash operates. Note that for variable-sized copies which are known to be
        .           // less than 8 bytes, this function will perform more work than necessary unless
        .           // the compiler is able to optimize the extra work away.
        .           #[inline]
        .           unsafe fn copy_nonoverlapping_small(src: *const u8, dst: *mut u8, count: usize) {
        .               debug_assert!(count <= 8);
        .           
   45,565 ( 0.00%)      if count == 8 {
        .                   ptr::copy_nonoverlapping(src, dst, 8);
        .                   return;
        .               }
        .           
        .               let mut i = 0;
   52,150 ( 0.00%)      if i + 3 < count {
        .                   ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);
        .                   i += 4;
        .               }
        .           
  114,363 ( 0.00%)      if i + 1 < count {
        .                   ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);
   12,599 ( 0.00%)          i += 2
        .               }
        .           
   52,150 ( 0.00%)      if i < count {
   28,500 ( 0.00%)          *dst.add(i) = *src.add(i);
        .                   i += 1;
        .               }
        .           
        .               debug_assert_eq!(i, count);
        .           }
        .           
        .           // # Implementation
        .           //
-- line 124 ----------------------------------------
-- line 201 ----------------------------------------
        .           
        .                   hasher
        .               }
        .           
        .               // A specialized write function for values with size <= 8.
        .               #[inline]
        .               fn short_write<T>(&mut self, x: T) {
        .                   let size = mem::size_of::<T>();
  697,775 ( 0.02%)          let nbuf = self.nbuf;
        .                   debug_assert!(size <= 8);
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .                   debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);
        .           
4,831,364 ( 0.11%)          if nbuf + size < BUFFER_SIZE {
        .                       unsafe {
        .                           // The memcpy call is optimized away because the size is known.
        .                           let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .                           ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);
        .                       }
        .           
1,502,755 ( 0.03%)              self.nbuf = nbuf + size;
        .           
        .                       return;
        .                   }
        .           
  249,134 ( 0.01%)          unsafe { self.short_write_process_buffer(x) }
        .               }
        .           
        .               // A specialized write function for values with size <= 8 that should only
        .               // be called when the write would cause the buffer to fill.
        .               //
        .               // SAFETY: the write of `x` into `self.buf` starting at byte offset
        .               // `self.nbuf` must cause `self.buf` to become fully initialized (and not
        .               // overflow) if it wasn't already.
        .               #[inline(never)]
   75,736 ( 0.00%)      unsafe fn short_write_process_buffer<T>(&mut self, x: T) {
        .                   let size = mem::size_of::<T>();
   75,736 ( 0.00%)          let nbuf = self.nbuf;
        .                   debug_assert!(size <= 8);
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .                   debug_assert!(nbuf + size >= BUFFER_SIZE);
        .                   debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);
        .           
        .                   // Copy first part of input into end of buffer, possibly into spill
        .                   // element. The memcpy call is optimized away because the size is known.
        .                   let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .                   ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);
        .           
        .                   // Process buffer.
        .                   for i in 0..BUFFER_CAPACITY {
  757,360 ( 0.02%)              let elem = self.buf.get_unchecked(i).assume_init().to_le();
  605,888 ( 0.01%)              self.state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut self.state);
  681,624 ( 0.01%)              self.state.v0 ^= elem;
        .                   }
        .           
        .                   // Copy remaining input into start of buffer by copying size - 1
        .                   // elements from spill (at most size - 1 bytes could have overflowed
        .                   // into the spill). The memcpy call is optimized away because the size
        .                   // is known. And the whole copy is optimized away for size == 1.
        .                   let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;
        .                   ptr::copy_nonoverlapping(src, self.buf.as_mut_ptr() as *mut u8, size - 1);
        .           
        .                   // This function should only be called when the write fills the buffer.
        .                   // Therefore, when size == 1, the new `self.nbuf` must be zero. The size
        .                   // is statically known, so the branch is optimized away.
  358,564 ( 0.01%)          self.nbuf = if size == 1 { 0 } else { nbuf + size - BUFFER_SIZE };
  302,944 ( 0.01%)          self.processed += BUFFER_SIZE;
  151,472 ( 0.00%)      }
        .           
        .               // A write function for byte slices.
        .               #[inline]
        .               fn slice_write(&mut self, msg: &[u8]) {
        .                   let length = msg.len();
   10,342 ( 0.00%)          let nbuf = self.nbuf;
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .           
  169,589 ( 0.00%)          if nbuf + length < BUFFER_SIZE {
        .                       unsafe {
        .                           let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .           
   61,614 ( 0.00%)                  if length <= 8 {
        .                               copy_nonoverlapping_small(msg.as_ptr(), dst, length);
        .                           } else {
        .                               // This memcpy is *not* optimized away.
        .                               ptr::copy_nonoverlapping(msg.as_ptr(), dst, length);
        .                           }
        .                       }
        .           
   31,386 ( 0.00%)              self.nbuf = nbuf + length;
        .           
        .                       return;
        .                   }
        .           
   19,066 ( 0.00%)          unsafe { self.slice_write_process_buffer(msg) }
        .               }
        .           
        .               // A write function for byte slices that should only be called when the
        .               // write would cause the buffer to fill.
        .               //
        .               // SAFETY: `self.buf` must be initialized up to the byte offset `self.nbuf`,
        .               // and `msg` must contain enough bytes to initialize the rest of the element
        .               // containing the byte offset `self.nbuf`.
        .               #[inline(never)]
   12,340 ( 0.00%)      unsafe fn slice_write_process_buffer(&mut self, msg: &[u8]) {
        .                   let length = msg.len();
    2,468 ( 0.00%)          let nbuf = self.nbuf;
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .                   debug_assert!(nbuf + length >= BUFFER_SIZE);
        .           
        .                   // Always copy first part of input into current element of buffer.
        .                   // This function should only be called when the write fills the buffer,
        .                   // so we know that there is enough input to fill the current element.
    7,404 ( 0.00%)          let valid_in_elem = nbuf % ELEM_SIZE;
    2,468 ( 0.00%)          let needed_in_elem = ELEM_SIZE - valid_in_elem;
        .           
        .                   let src = msg.as_ptr();
        .                   let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .                   copy_nonoverlapping_small(src, dst, needed_in_elem);
        .           
        .                   // Process buffer.
        .           
        .                   // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /
        .                   // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.
        .                   // We know that is true, because last step ensured we have a full
        .                   // element in the buffer.
    4,936 ( 0.00%)          let last = nbuf / ELEM_SIZE + 1;
        .           
        .                   for i in 0..last {
   19,217 ( 0.00%)              let elem = self.buf.get_unchecked(i).assume_init().to_le();
   21,685 ( 0.00%)              self.state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut self.state);
   38,434 ( 0.00%)              self.state.v0 ^= elem;
        .                   }
        .           
        .                   // Process the remaining element-sized chunks of input.
        .                   let mut processed = needed_in_elem;
    4,936 ( 0.00%)          let input_left = length - processed;
    2,421 ( 0.00%)          let elems_left = input_left / ELEM_SIZE;
        .                   let extra_bytes_left = input_left % ELEM_SIZE;
        .           
        .                   for _ in 0..elems_left {
      963 ( 0.00%)              let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();
      963 ( 0.00%)              self.state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut self.state);
      963 ( 0.00%)              self.state.v0 ^= elem;
    1,926 ( 0.00%)              processed += ELEM_SIZE;
        .                   }
        .           
        .                   // Copy remaining input into start of buffer.
        .                   let src = msg.as_ptr().add(processed);
        .                   let dst = self.buf.as_mut_ptr() as *mut u8;
        .                   copy_nonoverlapping_small(src, dst, extra_bytes_left);
        .           
    2,468 ( 0.00%)          self.nbuf = extra_bytes_left;
   12,340 ( 0.00%)          self.processed += nbuf + processed;
   14,808 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn finish128(mut self) -> (u64, u64) {
        .                   debug_assert!(self.nbuf < BUFFER_SIZE);
        .           
        .                   // Process full elements in buffer.
   41,313 ( 0.00%)          let last = self.nbuf / ELEM_SIZE;
        .           
        .                   // Since we're consuming self, avoid updating members for a potential
        .                   // performance gain.
   55,084 ( 0.00%)          let mut state = self.state;
        .           
        .                   for i in 0..last {
   42,267 ( 0.00%)              let elem = unsafe { self.buf.get_unchecked(i).assume_init().to_le() };
   42,267 ( 0.00%)              state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut state);
   42,267 ( 0.00%)              state.v0 ^= elem;
        .                   }
        .           
        .                   // Get remaining partial element.
   27,542 ( 0.00%)          let elem = if self.nbuf % ELEM_SIZE != 0 {
        .                       unsafe {
        .                           // Ensure element is initialized by writing zero bytes. At most
        .                           // `ELEM_SIZE - 1` are required given the above check. It's safe
        .                           // to write this many because we have the spill and we maintain
        .                           // `self.nbuf` such that this write will start before the spill.
        .                           let dst = (self.buf.as_mut_ptr() as *mut u8).add(self.nbuf);
        .                           ptr::write_bytes(dst, 0, ELEM_SIZE - 1);
   12,646 ( 0.00%)                  self.buf.get_unchecked(last).assume_init().to_le()
        .                       }
        .                   } else {
        .                       0
        .                   };
        .           
        .                   // Finalize the hash.
   39,443 ( 0.00%)          let length = self.processed + self.nbuf;
   26,048 ( 0.00%)          let b: u64 = ((length as u64 & 0xff) << 56) | elem;
        .           
   13,024 ( 0.00%)          state.v3 ^= b;
        .                   Sip24Rounds::c_rounds(&mut state);
   13,024 ( 0.00%)          state.v0 ^= b;
        .           
   13,024 ( 0.00%)          state.v2 ^= 0xee;
        .                   Sip24Rounds::d_rounds(&mut state);
   43,218 ( 0.00%)          let _0 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
        .           
   17,166 ( 0.00%)          state.v1 ^= 0xdd;
        .                   Sip24Rounds::d_rounds(&mut state);
   17,166 ( 0.00%)          let _1 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
        .           
        .                   (_0, _1)
        .               }
        .           }
        .           
        .           impl Hasher for SipHasher128 {
        .               #[inline]
        .               fn write_u8(&mut self, i: u8) {
-- line 414 ----------------------------------------
-- line 471 ----------------------------------------
        .           }
        .           
        .           #[derive(Debug, Clone, Default)]
        .           struct Sip24Rounds;
        .           
        .           impl Sip24Rounds {
        .               #[inline]
        .               fn c_rounds(state: &mut State) {
2,808,576 ( 0.06%)          compress!(state);
3,010,295 ( 0.07%)          compress!(state);
        .               }
        .           
        .               #[inline]
        .               fn d_rounds(state: &mut State) {
   86,428 ( 0.00%)          compress!(state);
   86,428 ( 0.00%)          compress!(state);
   86,428 ( 0.00%)          compress!(state);
   73,406 ( 0.00%)          compress!(state);
        .               }
        .           }

  523,493 ( 0.01%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/sip128.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs
--------------------------------------------------------------------------------
Ir                  

-- line 111 ----------------------------------------
         .           const EMPTY: u8 = 0b1111_1111;
         .           
         .           /// Control byte value for a deleted bucket.
         .           const DELETED: u8 = 0b1000_0000;
         .           
         .           /// Checks whether a control byte represents a full bucket (top bit is clear).
         .           #[inline]
         .           fn is_full(ctrl: u8) -> bool {
 1,941,804 ( 0.04%)      ctrl & 0x80 == 0
         .           }
         .           
         .           /// Checks whether a control byte represents a special value (top bit is set).
         .           #[inline]
         .           fn is_special(ctrl: u8) -> bool {
         .               ctrl & 0x80 != 0
         .           }
         .           
         .           /// Checks whether a special control value is EMPTY (just check 1 bit).
         .           #[inline]
         .           fn special_is_empty(ctrl: u8) -> bool {
         .               debug_assert!(is_special(ctrl));
   156,113 ( 0.00%)      ctrl & 0x01 != 0
         .           }
         .           
         .           /// Primary hash function, used to select the initial bucket to probe from.
         .           #[inline]
         .           #[allow(clippy::cast_possible_truncation)]
         .           fn h1(hash: u64) -> usize {
         .               // On 32-bit platforms we simply ignore the higher hash bits.
         .               hash as usize
-- line 140 ----------------------------------------
-- line 143 ----------------------------------------
         .           /// Secondary hash function, saved in the low 7 bits of the control byte.
         .           #[inline]
         .           #[allow(clippy::cast_possible_truncation)]
         .           fn h2(hash: u64) -> u8 {
         .               // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
         .               // value, some hash functions (such as FxHash) produce a usize result
         .               // instead, which means that the top 32 bits are 0 on 32-bit platforms.
         .               let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
29,281,609 ( 0.64%)      let top7 = hash >> (hash_len * 8 - 7);
         .               (top7 & 0x7f) as u8 // truncation
         .           }
         .           
         .           /// Probe sequence based on triangular numbers, which is guaranteed (since our
         .           /// table size is a power of two) to visit every group of elements exactly once.
         .           ///
         .           /// A triangular probe has us jump by 1 more group every time. So first we
         .           /// jump by 1 group (meaning we just continue our linear scan), then 2 groups
-- line 159 ----------------------------------------
-- line 170 ----------------------------------------
         .               #[inline]
         .               fn move_next(&mut self, bucket_mask: usize) {
         .                   // We should have found an empty bucket by now and ended the probe.
         .                   debug_assert!(
         .                       self.stride <= bucket_mask,
         .                       "Went past end of probe sequence"
         .                   );
         .           
   192,104 ( 0.00%)          self.stride += Group::WIDTH;
   192,104 ( 0.00%)          self.pos += self.stride;
   165,149 ( 0.00%)          self.pos &= bucket_mask;
         .               }
         .           }
         .           
         .           /// Returns the number of buckets needed to hold the given number of items,
         .           /// taking the maximum load factor into account.
         .           ///
         .           /// Returns `None` if an overflow occurs.
         .           // Workaround for emscripten bug emscripten-core/emscripten-fastcomp#258
         .           #[cfg_attr(target_os = "emscripten", inline(never))]
         .           #[cfg_attr(not(target_os = "emscripten"), inline)]
         .           fn capacity_to_buckets(cap: usize) -> Option<usize> {
         .               debug_assert_ne!(cap, 0);
         .           
         .               // For small tables we require at least 1 empty bucket so that lookups are
         .               // guaranteed to terminate if an element doesn't exist in the table.
   155,758 ( 0.00%)      if cap < 8 {
         .                   // We don't bother with a table size of 2 buckets since that can only
         .                   // hold a single element. Instead we skip directly to a 4 bucket table
         .                   // which can hold 3 elements.
   343,555 ( 0.01%)          return Some(if cap < 4 { 4 } else { 8 });
         .               }
         .           
         .               // Otherwise require 1/8 buckets to be empty (87.5% load)
         .               //
         .               // Be careful when modifying this, calculate_layout relies on the
         .               // overflow check here.
    55,008 ( 0.00%)      let adjusted_cap = cap.checked_mul(8)? / 7;
         .           
         .               // Any overflows will have been caught by the checked_mul. Also, any
         .               // rounding errors from the division above will be cleaned up by
         .               // next_power_of_two (which can't overflow because of the previous division).
         .               Some(adjusted_cap.next_power_of_two())
         .           }
         .           
         .           /// Returns the maximum effective capacity for the given bucket mask, taking
         .           /// the maximum load factor into account.
         .           #[inline]
         .           fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
   403,865 ( 0.01%)      if bucket_mask < 8 {
         .                   // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
         .                   // Keep in mind that the bucket mask is one less than the bucket count.
         .                   bucket_mask
         .               } else {
         .                   // For larger tables we reserve 12.5% of the slots as empty.
    75,926 ( 0.00%)          ((bucket_mask + 1) / 8) * 7
         .               }
         .           }
         .           
         .           /// Helper which allows the max calculation for ctrl_align to be statically computed for each T
         .           /// while keeping the rest of `calculate_layout_for` independent of `T`
         .           #[derive(Copy, Clone)]
         .           struct TableLayout {
         .               size: usize,
-- line 233 ----------------------------------------
-- line 246 ----------------------------------------
         .           
         .               #[inline]
         .               fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
         .                   debug_assert!(buckets.is_power_of_two());
         .           
         .                   let TableLayout { size, ctrl_align } = self;
         .                   // Manual layout calculation since Layout methods are not yet stable.
         .                   let ctrl_offset =
   322,490 ( 0.01%)              size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
   428,024 ( 0.01%)          let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
         .           
         .                   Some((
         .                       unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
         .                       ctrl_offset,
         .                   ))
         .               }
         .           }
         .           
-- line 263 ----------------------------------------
-- line 337 ----------------------------------------
         .                   }
         .               }
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub unsafe fn drop(&self) {
         .                   self.as_ptr().drop_in_place();
         .               }
         .               #[inline]
         .               pub unsafe fn read(&self) -> T {
     2,794 ( 0.00%)          self.as_ptr().read()
         .               }
         .               #[inline]
         .               pub unsafe fn write(&self, val: T) {
         .                   self.as_ptr().write(val);
         .               }
         .               #[inline]
         .               pub unsafe fn as_ref<'a>(&self) -> &'a T {
         .                   &*self.as_ptr()
-- line 353 ----------------------------------------
-- line 422 ----------------------------------------
         .               /// Creates a new empty hash table without allocating any memory, using the
         .               /// given allocator.
         .               ///
         .               /// In effect this returns a table with exactly 1 bucket. However we can
         .               /// leave the data pointer dangling since that bucket is never written to
         .               /// due to our load factor forcing us to always have at least 1 free bucket.
         .               #[inline]
         .               pub fn new_in(alloc: A) -> Self {
     3,375 ( 0.00%)          Self {
         .                       table: RawTableInner::new_in(alloc),
         .                       marker: PhantomData,
         .                   }
         .               }
         .           
         .               /// Allocates a new hash table with the given number of buckets.
         .               ///
         .               /// The control bytes are left uninitialized.
-- line 438 ----------------------------------------
-- line 440 ----------------------------------------
         .               unsafe fn new_uninitialized(
         .                   alloc: A,
         .                   buckets: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
         .                   debug_assert!(buckets.is_power_of_two());
         .           
         .                   Ok(Self {
       130 ( 0.00%)              table: RawTableInner::new_uninitialized(
         .                           alloc,
         .                           TableLayout::new::<T>(),
         .                           buckets,
         .                           fallibility,
         .                       )?,
         .                       marker: PhantomData,
         .                   })
         .               }
-- line 456 ----------------------------------------
-- line 458 ----------------------------------------
         .               /// Attempts to allocate a new hash table with at least enough capacity
         .               /// for inserting the given number of elements without reallocating.
         .               fn fallible_with_capacity(
         .                   alloc: A,
         .                   capacity: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
         .                   Ok(Self {
     8,770 ( 0.00%)              table: RawTableInner::fallible_with_capacity(
         .                           alloc,
         .                           TableLayout::new::<T>(),
         .                           capacity,
         .                           fallibility,
         .                       )?,
         .                       marker: PhantomData,
         .                   })
         .               }
-- line 474 ----------------------------------------
-- line 527 ----------------------------------------
         .                   debug_assert_ne!(self.table.bucket_mask, 0);
         .                   debug_assert!(index < self.buckets());
         .                   Bucket::from_base_index(self.data_end(), index)
         .               }
         .           
         .               /// Erases an element from the table without dropping it.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[deprecated(since = "0.8.1", note = "use erase or remove instead")]
    19,211 ( 0.00%)      pub unsafe fn erase_no_drop(&mut self, item: &Bucket<T>) {
    19,211 ( 0.00%)          let index = self.bucket_index(item);
         .                   self.table.erase(index);
    38,422 ( 0.00%)      }
         .           
         .               /// Erases an element from the table, dropping it in place.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[allow(clippy::needless_pass_by_value)]
         .               #[allow(deprecated)]
         .               pub unsafe fn erase(&mut self, item: Bucket<T>) {
         .                   // Erase the element from the table first since drop might panic.
    13,492 ( 0.00%)          self.erase_no_drop(&item);
         .                   item.drop();
         .               }
         .           
         .               /// Finds and erases an element from the table, dropping it in place.
         .               /// Returns true if an element was found.
         .               #[cfg(feature = "raw")]
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn erase_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> bool {
-- line 554 ----------------------------------------
-- line 563 ----------------------------------------
         .                   }
         .               }
         .           
         .               /// Removes an element from the table, returning it.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[allow(clippy::needless_pass_by_value)]
         .               #[allow(deprecated)]
         .               pub unsafe fn remove(&mut self, item: Bucket<T>) -> T {
    24,930 ( 0.00%)          self.erase_no_drop(&item);
       191 ( 0.00%)          item.read()
         .               }
         .           
         .               /// Finds and removes an element from the table, returning it.
         .               #[cfg_attr(feature = "inline-more", inline)]
   721,261 ( 0.02%)      pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T> {
         .                   // Avoid `Option::map` because it bloats LLVM IR.
     2,972 ( 0.00%)          match self.find(hash, eq) {
    13,915 ( 0.00%)              Some(bucket) => Some(unsafe { self.remove(bucket) }),
   144,827 ( 0.00%)              None => None,
         .                   }
 1,047,308 ( 0.02%)      }
         .           
         .               /// Marks all table buckets as empty without dropping their contents.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn clear_no_drop(&mut self) {
         .                   self.table.clear_no_drop();
         .               }
         .           
         .               /// Removes all elements from the table without freeing the backing memory.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn clear(&mut self) {
         .                   // Ensure that the table is reset even if one of the drops panic
         .                   let mut self_ = guard(self, |self_| self_.clear_no_drop());
         .                   unsafe {
         1 ( 0.00%)              self_.drop_elements();
         .                   }
         .               }
         .           
         7 ( 0.00%)      unsafe fn drop_elements(&mut self) {
    18,414 ( 0.00%)          if mem::needs_drop::<T>() && !self.is_empty() {
         .                       for item in self.iter() {
         .                           item.drop();
         .                       }
         .                   }
         8 ( 0.00%)      }
         .           
         .               /// Shrinks the table to fit `max(self.len(), min_size)` elements.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn shrink_to(&mut self, min_size: usize, hasher: impl Fn(&T) -> u64) {
         .                   // Calculate the minimal number of elements that we need to reserve
         .                   // space for.
         .                   let min_size = usize::max(self.table.items, min_size);
         .                   if min_size == 0 {
-- line 615 ----------------------------------------
-- line 642 ----------------------------------------
         .                       }
         .                   }
         .               }
         .           
         .               /// Ensures that at least `additional` items can be inserted into the table
         .               /// without reallocation.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
   405,296 ( 0.01%)          if additional > self.table.growth_left {
         .                       // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
   265,852 ( 0.01%)              if self
         .                           .reserve_rehash(additional, hasher, Fallibility::Infallible)
         .                           .is_err()
         .                       {
         .                           unsafe { hint::unreachable_unchecked() }
         .                       }
         .                   }
         .               }
         .           
-- line 660 ----------------------------------------
-- line 671 ----------------------------------------
         .                   } else {
         .                       Ok(())
         .                   }
         .               }
         .           
         .               /// Out-of-line slow path for `reserve` and `try_reserve`.
         .               #[cold]
         .               #[inline(never)]
   627,713 ( 0.01%)      fn reserve_rehash(
         .                   &mut self,
         .                   additional: usize,
         .                   hasher: impl Fn(&T) -> u64,
         .                   fallibility: Fallibility,
         .               ) -> Result<(), TryReserveError> {
         .                   unsafe {
         .                       self.table.reserve_rehash_inner(
         .                           additional,
-- line 687 ----------------------------------------
-- line 690 ----------------------------------------
         .                           TableLayout::new::<T>(),
         .                           if mem::needs_drop::<T>() {
         .                               Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
         .                           } else {
         .                               None
         .                           },
         .                       )
         .                   }
   470,560 ( 0.01%)      }
         .           
         .               /// Allocates a new table of a different size and moves the contents of the
         .               /// current table into it.
         .               fn resize(
         .                   &mut self,
         .                   capacity: usize,
         .                   hasher: impl Fn(&T) -> u64,
         .                   fallibility: Fallibility,
-- line 706 ----------------------------------------
-- line 714 ----------------------------------------
         .                       )
         .                   }
         .               }
         .           
         .               /// Inserts a new element into the table, and returns its raw bucket.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg_attr(feature = "inline-more", inline)]
 2,714,346 ( 0.06%)      pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
         .                   unsafe {
         .                       let mut index = self.table.find_insert_slot(hash);
         .           
         .                       // We can avoid growing the table once we have reached our load
         .                       // factor if we are replacing a tombstone. This works since the
         .                       // number of EMPTY slots does not change in this case.
     6,433 ( 0.00%)              let old_ctrl = *self.table.ctrl(index);
 1,812,621 ( 0.04%)              if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
         .                           self.reserve(1, hasher);
         .                           index = self.table.find_insert_slot(hash);
         .                       }
         .           
         .                       self.table.record_item_insert_at(index, old_ctrl, hash);
         .           
         .                       let bucket = self.bucket(index);
         4 ( 0.00%)              bucket.write(value);
         .                       bucket
         .                   }
 1,997,461 ( 0.04%)      }
         .           
         .               /// Attempts to insert a new element without growing the table and return its raw bucket.
         .               ///
         .               /// Returns an `Err` containing the given element if inserting it would require growing the
         .               /// table.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg(feature = "raw")]
-- line 749 ----------------------------------------
-- line 760 ----------------------------------------
         .                       }
         .                   }
         .               }
         .           
         .               /// Inserts a new element into the table, and returns a mutable reference to it.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg_attr(feature = "inline-more", inline)]
   532,960 ( 0.01%)      pub fn insert_entry(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> &mut T {
        52 ( 0.00%)          unsafe { self.insert(hash, value, hasher).as_mut() }
   399,720 ( 0.01%)      }
         .           
         .               /// Inserts a new element into the table, without growing the table.
         .               ///
         .               /// There must be enough space in the table to insert the new element.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[cfg(any(feature = "raw", feature = "rustc-internal-api"))]
     2,807 ( 0.00%)      pub unsafe fn insert_no_grow(&mut self, hash: u64, value: T) -> Bucket<T> {
   443,606 ( 0.01%)          let (index, old_ctrl) = self.table.prepare_insert_slot(hash);
    10,855 ( 0.00%)          let bucket = self.table.bucket(index);
         .           
         .                   // If we are replacing a DELETED entry then we don't need to update
         .                   // the load counter.
   921,534 ( 0.02%)          self.table.growth_left -= special_is_empty(old_ctrl) as usize;
         .           
         .                   bucket.write(value);
   737,109 ( 0.02%)          self.table.items += 1;
         .                   bucket
     5,409 ( 0.00%)      }
         .           
         .               /// Temporary removes a bucket, applying the given function to the removed
         .               /// element and optionally put back the returned value in the same bucket.
         .               ///
         .               /// Returns `true` if the bucket still contains an element
         .               ///
         .               /// This does not check if the given bucket is actually occupied.
         .               #[cfg_attr(feature = "inline-more", inline)]
-- line 798 ----------------------------------------
-- line 813 ----------------------------------------
         .                       true
         .                   } else {
         .                       false
         .                   }
         .               }
         .           
         .               /// Searches for an element in the table.
         .               #[inline]
    38,743 ( 0.00%)      pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
    21,592 ( 0.00%)          let result = self.table.find_inner(hash, &mut |index| unsafe {
    30,286 ( 0.00%)              eq(self.bucket(index).as_ref())
     6,561 ( 0.00%)          });
         .           
         .                   // Avoid `Option::map` because it bloats LLVM IR.
         .                   match result {
     2,507 ( 0.00%)              Some(index) => Some(unsafe { self.bucket(index) }),
         .                       None => None,
         .                   }
    43,552 ( 0.00%)      }
         .           
         .               /// Gets a reference to an element in the table.
         .               #[inline]
         .               pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
         .                   // Avoid `Option::map` because it bloats LLVM IR.
    39,294 ( 0.00%)          match self.find(hash, eq) {
         .                       Some(bucket) => Some(unsafe { bucket.as_ref() }),
         .                       None => None,
         .                   }
         .               }
         .           
         .               /// Gets a mutable reference to an element in the table.
         .               #[inline]
     2,163 ( 0.00%)      pub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {
         .                   // Avoid `Option::map` because it bloats LLVM IR.
    18,927 ( 0.00%)          match self.find(hash, eq) {
         .                       Some(bucket) => Some(unsafe { bucket.as_mut() }),
         .                       None => None,
         .                   }
     2,472 ( 0.00%)      }
         .           
         .               /// Attempts to get mutable references to `N` entries in the table at once.
         .               ///
         .               /// Returns an array of length `N` with the results of each query.
         .               ///
         .               /// At most one mutable reference will be returned to any entry. `None` will be returned if any
         .               /// of the hashes are duplicates. `None` will be returned if the hash is not found.
         .               ///
-- line 859 ----------------------------------------
-- line 920 ----------------------------------------
         .               #[inline]
         .               pub fn len(&self) -> usize {
         .                   self.table.items
         .               }
         .           
         .               /// Returns `true` if the table contains no elements.
         .               #[inline]
         .               pub fn is_empty(&self) -> bool {
   958,374 ( 0.02%)          self.len() == 0
         .               }
         .           
         .               /// Returns the number of buckets in the table.
         .               #[inline]
         .               pub fn buckets(&self) -> usize {
         .                   self.table.bucket_mask + 1
         .               }
         .           
         .               /// Returns an iterator over every element in the table. It is up to
         .               /// the caller to ensure that the `RawTable` outlives the `RawIter`.
         .               /// Because we cannot make the `next` method unsafe on the `RawIter`
         .               /// struct, we have to make the `iter` method unsafe.
         .               #[inline]
         .               pub unsafe fn iter(&self) -> RawIter<T> {
         4 ( 0.00%)          let data = Bucket::from_base_index(self.data_end(), 0);
         .                   RawIter {
         .                       iter: RawIterRange::new(self.table.ctrl.as_ptr(), data, self.table.buckets()),
   148,019 ( 0.00%)              items: self.table.items,
         .                   }
         .               }
         .           
         .               /// Returns an iterator over occupied buckets that could match a given hash.
         .               ///
         .               /// `RawTable` only stores 7 bits of the hash value, so this iterator may
         .               /// return items that have a hash value different than the one provided. You
         .               /// should always validate the returned values before using them.
-- line 954 ----------------------------------------
-- line 995 ----------------------------------------
         .               /// Iteration starts at the provided iterator's current location.
         .               ///
         .               /// It is up to the caller to ensure that the iterator is valid for this
         .               /// `RawTable` and covers all items that remain in the table.
         .               pub unsafe fn into_iter_from(self, iter: RawIter<T>) -> RawIntoIter<T, A> {
         .                   debug_assert_eq!(iter.len(), self.len());
         .           
         .                   let alloc = self.table.alloc.clone();
    12,296 ( 0.00%)          let allocation = self.into_allocation();
     9,222 ( 0.00%)          RawIntoIter {
    15,370 ( 0.00%)              iter,
         .                       allocation,
         .                       marker: PhantomData,
         .                       alloc,
         .                   }
         .               }
         .           
         .               /// Converts the table into a raw allocation. The contents of the table
         .               /// should be dropped using a `RawIter` before freeing the allocation.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout)> {
     5,999 ( 0.00%)          let alloc = if self.table.is_empty_singleton() {
         .                       None
         .                   } else {
         .                       // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
         .                       let (layout, ctrl_offset) = match calculate_layout::<T>(self.table.buckets()) {
         .                           Some(lco) => lco,
         .                           None => unsafe { hint::unreachable_unchecked() },
         .                       };
         .                       Some((
       622 ( 0.00%)                  unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().sub(ctrl_offset)) },
         .                           layout,
         .                       ))
         .                   };
         .                   mem::forget(self);
         .                   alloc
         .               }
         .           }
         .           
-- line 1033 ----------------------------------------
-- line 1042 ----------------------------------------
         .               T: Sync,
         .               A: Sync,
         .           {
         .           }
         .           
         .           impl<A> RawTableInner<A> {
         .               #[inline]
         .               const fn new_in(alloc: A) -> Self {
   884,894 ( 0.02%)          Self {
         .                       // Be careful to cast the entire slice to a raw pointer.
         .                       ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
         .                       bucket_mask: 0,
         .                       items: 0,
         .                       growth_left: 0,
         .                       alloc,
         .                   }
         .               }
         .           }
         .           
         .           impl<A: Allocator + Clone> RawTableInner<A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
   581,917 ( 0.01%)      unsafe fn new_uninitialized(
         .                   alloc: A,
         .                   table_layout: TableLayout,
         .                   buckets: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
         .                   debug_assert!(buckets.is_power_of_two());
         .           
         .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
-- line 1071 ----------------------------------------
-- line 1078 ----------------------------------------
         .                   // exceed `isize::MAX`. We can skip this check on 64-bit systems since
         .                   // such allocations will never succeed anyways.
         .                   //
         .                   // This mirrors what Vec does in the standard library.
         .                   if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
         .                       return Err(fallibility.capacity_overflow());
         .                   }
         .           
   134,968 ( 0.00%)          let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
         .                       Ok(block) => block.cast(),
         .                       Err(_) => return Err(fallibility.alloc_err(layout)),
         .                   };
         .           
         .                   let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
   320,376 ( 0.01%)          Ok(Self {
         .                       ctrl,
   131,301 ( 0.00%)              bucket_mask: buckets - 1,
         .                       items: 0,
         .                       growth_left: bucket_mask_to_capacity(buckets - 1),
         .                       alloc,
         .                   })
   423,542 ( 0.01%)      }
         .           
         .               #[inline]
    39,342 ( 0.00%)      fn fallible_with_capacity(
         .                   alloc: A,
         .                   table_layout: TableLayout,
         .                   capacity: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
    10,518 ( 0.00%)          if capacity == 0 {
     7,334 ( 0.00%)              Ok(Self::new_in(alloc))
         .                   } else {
         .                       unsafe {
         .                           let buckets =
         .                               capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
         .           
   264,867 ( 0.01%)                  let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
         .                           result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
         .           
    21,664 ( 0.00%)                  Ok(result)
         .                       }
         .                   }
    39,342 ( 0.00%)      }
         .           
         .               /// Searches for an empty or deleted bucket which is suitable for inserting
         .               /// a new element and sets the hash for that slot.
         .               ///
         .               /// There must be at least 1 empty bucket in the table.
         .               #[inline]
   153,461 ( 0.00%)      unsafe fn prepare_insert_slot(&self, hash: u64) -> (usize, u8) {
         .                   let index = self.find_insert_slot(hash);
   153,461 ( 0.00%)          let old_ctrl = *self.ctrl(index);
         .                   self.set_ctrl_h2(index, hash);
         .                   (index, old_ctrl)
   306,922 ( 0.01%)      }
         .           
         .               /// Searches for an empty or deleted bucket which is suitable for inserting
         .               /// a new element.
         .               ///
         .               /// There must be at least 1 empty bucket in the table.
         .               #[inline]
         .               fn find_insert_slot(&self, hash: u64) -> usize {
         .                   let mut probe_seq = self.probe_seq(hash);
         .                   loop {
         .                       unsafe {
         .                           let group = Group::load(self.ctrl(probe_seq.pos));
 1,254,390 ( 0.03%)                  if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
 3,693,466 ( 0.08%)                      let result = (probe_seq.pos + bit) & self.bucket_mask;
         .           
         .                               // In tables smaller than the group width, trailing control
         .                               // bytes outside the range of the table are filled with
         .                               // EMPTY entries. These will unfortunately trigger a
         .                               // match, but once masked may point to a full bucket that
         .                               // is already occupied. We detect this situation here and
         .                               // perform a second scan starting at the beginning of the
         .                               // table. This second scan is guaranteed to find an empty
         .                               // slot (due to the load factor) before hitting the trailing
         .                               // control bytes (containing EMPTY).
 1,683,564 ( 0.04%)                      if unlikely(is_full(*self.ctrl(result))) {
         .                                   debug_assert!(self.bucket_mask < Group::WIDTH);
         .                                   debug_assert_ne!(probe_seq.pos, 0);
         .                                   return Group::load_aligned(self.ctrl(0))
         .                                       .match_empty_or_deleted()
         .                                       .lowest_set_bit_nonzero();
         .                               }
         .           
         .                               return result;
-- line 1165 ----------------------------------------
-- line 1171 ----------------------------------------
         .           
         .               /// Searches for an element in the table. This uses dynamic dispatch to reduce the amount of
         .               /// code generated, but it is eliminated by LLVM optimizations.
         .               #[inline]
         .               fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
         .                   let h2_hash = h2(hash);
         .                   let mut probe_seq = self.probe_seq(hash);
         .           
    81,888 ( 0.00%)          loop {
         .                       let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
         .           
 3,712,300 ( 0.08%)              for bit in group.match_byte(h2_hash) {
 7,018,873 ( 0.15%)                  let index = (probe_seq.pos + bit) & self.bucket_mask;
         .           
 5,064,233 ( 0.11%)                  if likely(eq(index)) {
         .                               return Some(index);
         .                           }
         .                       }
         .           
 1,195,960 ( 0.03%)              if likely(group.match_empty().any_bit_set()) {
         .                           return None;
         .                       }
         .           
         .                       probe_seq.move_next(self.bucket_mask);
         .                   }
         .               }
         .           
         .               #[allow(clippy::mut_mut)]
-- line 1198 ----------------------------------------
-- line 1225 ----------------------------------------
         .                   Bucket::from_base_index(self.data_end(), index)
         .               }
         .           
         .               #[inline]
         .               unsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8 {
         .                   debug_assert_ne!(self.bucket_mask, 0);
         .                   debug_assert!(index < self.buckets());
         .                   let base: *mut u8 = self.data_end().as_ptr();
 4,529,416 ( 0.10%)          base.sub((index + 1) * size_of)
         .               }
         .           
         .               #[inline]
         .               unsafe fn data_end<T>(&self) -> NonNull<T> {
         .                   NonNull::new_unchecked(self.ctrl.as_ptr().cast())
         .               }
         .           
         .               /// Returns an iterator-like object for a probe sequence on the table.
         .               ///
         .               /// This iterator never terminates, but is guaranteed to visit each bucket
         .               /// group exactly once. The loop using `probe_seq` must terminate upon
         .               /// reaching a group containing an empty bucket.
         .               #[inline]
         .               fn probe_seq(&self, hash: u64) -> ProbeSeq {
         .                   ProbeSeq {
21,745,454 ( 0.48%)              pos: h1(hash) & self.bucket_mask,
         .                       stride: 0,
         .                   }
         .               }
         .           
         .               /// Returns the index of a bucket for which a value must be inserted if there is enough rooom
         .               /// in the table, otherwise returns error
         .               #[cfg(feature = "raw")]
         .               #[inline]
-- line 1257 ----------------------------------------
-- line 1263 ----------------------------------------
         .                   } else {
         .                       self.record_item_insert_at(index, old_ctrl, hash);
         .                       Ok(index)
         .                   }
         .               }
         .           
         .               #[inline]
         .               unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
 2,264,825 ( 0.05%)          self.growth_left -= special_is_empty(old_ctrl) as usize;
         .                   self.set_ctrl_h2(index, hash);
 1,811,824 ( 0.04%)          self.items += 1;
         .               }
         .           
         .               #[inline]
         .               fn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool {
         .                   let probe_seq_pos = self.probe_seq(hash).pos;
         .                   let probe_index =
         .                       |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;
         .                   probe_index(i) == probe_index(new_i)
-- line 1281 ----------------------------------------
-- line 1312 ----------------------------------------
         .                   // replicate the buckets at the end of the trailing group. For example
         .                   // with 2 buckets and a group size of 4, the control bytes will look
         .                   // like this:
         .                   //
         .                   //     Real    |             Replicated
         .                   // ---------------------------------------------
         .                   // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
         .                   // ---------------------------------------------
 3,527,318 ( 0.08%)          let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
         .           
 1,175,246 ( 0.03%)          *self.ctrl(index) = ctrl;
 1,175,954 ( 0.03%)          *self.ctrl(index2) = ctrl;
         .               }
         .           
         .               /// Returns a pointer to a control byte.
         .               #[inline]
         .               unsafe fn ctrl(&self, index: usize) -> *mut u8 {
         .                   debug_assert!(index < self.num_ctrl_bytes());
         .                   self.ctrl.as_ptr().add(index)
         .               }
         .           
         .               #[inline]
         .               fn buckets(&self) -> usize {
   423,611 ( 0.01%)          self.bucket_mask + 1
         .               }
         .           
         .               #[inline]
         .               fn num_ctrl_bytes(&self) -> usize {
   312,271 ( 0.01%)          self.bucket_mask + 1 + Group::WIDTH
         .               }
         .           
         .               #[inline]
         .               fn is_empty_singleton(&self) -> bool {
 1,625,861 ( 0.04%)          self.bucket_mask == 0
         .               }
         .           
         .               #[allow(clippy::mut_mut)]
         .               #[inline]
         .               unsafe fn prepare_resize(
         .                   &self,
         .                   table_layout: TableLayout,
         .                   capacity: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
         .                   debug_assert!(self.items <= capacity);
         .           
         .                   // Allocate and initialize the new table.
     8,517 ( 0.00%)          let mut new_table = RawTableInner::fallible_with_capacity(
         .                       self.alloc.clone(),
         .                       table_layout,
         .                       capacity,
         .                       fallibility,
         .                   )?;
   168,676 ( 0.00%)          new_table.growth_left -= self.items;
         .                   new_table.items = self.items;
         .           
         .                   // The hash function may panic, in which case we simply free the new
         .                   // table without dropping any elements that may have been copied into
         .                   // it.
         .                   //
         .                   // This guard is also used to free the old table on success, see
         .                   // the comment at the bottom of this function.
         .                   Ok(guard(new_table, move |self_| {
    77,105 ( 0.00%)              if !self_.is_empty_singleton() {
         .                           self_.free_buckets(table_layout);
         .                       }
         .                   }))
         .               }
         .           
         .               /// Reserves or rehashes to make room for `additional` more elements.
         .               ///
         .               /// This uses dynamic dispatch to reduce the amount of
-- line 1383 ----------------------------------------
-- line 1388 ----------------------------------------
         .                   &mut self,
         .                   additional: usize,
         .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
         .                   fallibility: Fallibility,
         .                   layout: TableLayout,
         .                   drop: Option<fn(*mut u8)>,
         .               ) -> Result<(), TryReserveError> {
         .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
   154,215 ( 0.00%)          let new_items = match self.items.checked_add(additional) {
         .                       Some(new_items) => new_items,
         .                       None => return Err(fallibility.capacity_overflow()),
         .                   };
   154,210 ( 0.00%)          let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
   323,682 ( 0.01%)          if new_items <= full_capacity / 2 {
         .                       // Rehash in-place without re-allocating if we have plenty of spare
         .                       // capacity that is locked up due to DELETED entries.
         .                       self.rehash_in_place(hasher, layout.size, drop);
         .                       Ok(())
         .                   } else {
         .                       // Otherwise, conservatively resize to at least the next size up
         .                       // to avoid churning deletes into frequent rehashes.
         .                       self.resize_inner(
    77,105 ( 0.00%)                  usize::max(new_items, full_capacity + 1),
         .                           hasher,
         .                           fallibility,
         .                           layout,
         .                       )
         .                   }
         .               }
         .           
         .               /// Allocates a new table of a different size and moves the contents of the
-- line 1418 ----------------------------------------
-- line 1424 ----------------------------------------
         .               #[inline(always)]
         .               unsafe fn resize_inner(
         .                   &mut self,
         .                   capacity: usize,
         .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
         .                   fallibility: Fallibility,
         .                   layout: TableLayout,
         .               ) -> Result<(), TryReserveError> {
    21,291 ( 0.00%)          let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
         .           
         .                   // Copy all elements to the new table.
         .                   for i in 0..self.buckets() {
   711,196 ( 0.02%)              if !is_full(*self.ctrl(i)) {
         .                           continue;
         .                       }
         .           
         .                       // This may panic.
         .                       let hash = hasher(self, i);
         .           
         .                       // We can use a simpler version of insert() here since:
         .                       // - there are no DELETED entries.
-- line 1444 ----------------------------------------
-- line 1454 ----------------------------------------
         .                   }
         .           
         .                   // We successfully copied all elements without panicking. Now replace
         .                   // self with the new table. The old table will have its memory freed but
         .                   // the items will not be dropped (since they have been moved into the
         .                   // new table).
         .                   mem::swap(self, &mut new_table);
         .           
    77,105 ( 0.00%)          Ok(())
         .               }
         .           
         .               /// Rehashes the contents of the table in place (i.e. without changing the
         .               /// allocation).
         .               ///
         .               /// If `hasher` panics then some the table's contents may be lost.
         .               ///
         .               /// This uses dynamic dispatch to reduce the amount of
-- line 1470 ----------------------------------------
-- line 1554 ----------------------------------------
         .               #[inline]
         .               unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
         .                   // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
         .                   let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
         .                       Some(lco) => lco,
         .                       None => hint::unreachable_unchecked(),
         .                   };
         .                   self.alloc.deallocate(
    53,984 ( 0.00%)              NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
         .                       layout,
         .                   );
         .               }
         .           
         .               /// Marks all table buckets as empty without dropping their contents.
         .               #[inline]
         .               fn clear_no_drop(&mut self) {
    12,244 ( 0.00%)          if !self.is_empty_singleton() {
         .                       unsafe {
         .                           self.ctrl(0).write_bytes(EMPTY, self.num_ctrl_bytes());
         .                       }
         .                   }
    16,893 ( 0.00%)          self.items = 0;
    12,263 ( 0.00%)          self.growth_left = bucket_mask_to_capacity(self.bucket_mask);
         .               }
         .           
         .               #[inline]
         .               unsafe fn erase(&mut self, index: usize) {
         .                   debug_assert!(is_full(*self.ctrl(index)));
   140,223 ( 0.00%)          let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;
         .                   let empty_before = Group::load(self.ctrl(index_before)).match_empty();
         .                   let empty_after = Group::load(self.ctrl(index)).match_empty();
         .           
         .                   // If we are inside a continuous block of Group::WIDTH full or deleted
         .                   // cells then a probe window may have seen a full block when trying to
         .                   // insert. We therefore need to keep that block non-empty so that
         .                   // lookups will continue searching to the next probe window.
         .                   //
         .                   // Note that in this context `leading_zeros` refers to the bytes at the
         .                   // end of a group, while `trailing_zeros` refers to the bytes at the
         .                   // beginning of a group.
   560,892 ( 0.01%)          let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {
         .                       DELETED
         .                   } else {
   690,140 ( 0.02%)              self.growth_left += 1;
         .                       EMPTY
         .                   };
         .                   self.set_ctrl(index, ctrl);
   560,892 ( 0.01%)          self.items -= 1;
         .               }
         .           }
         .           
         .           impl<T: Clone, A: Allocator + Clone> Clone for RawTable<T, A> {
     9,016 ( 0.00%)      fn clone(&self) -> Self {
     1,151 ( 0.00%)          if self.table.is_empty_singleton() {
         .                       Self::new_in(self.table.alloc.clone())
         .                   } else {
         .                       unsafe {
         .                           let mut new_table = ManuallyDrop::new(
         .                               // Avoid `Result::ok_or_else` because it bloats LLVM IR.
         .                               match Self::new_uninitialized(
         .                                   self.table.alloc.clone(),
         .                                   self.table.buckets(),
-- line 1615 ----------------------------------------
-- line 1624 ----------------------------------------
         .                               // We need to free the memory allocated for the new table.
         .                               new_table.free_buckets();
         .                           });
         .           
         .                           // Return the newly created table.
         .                           ManuallyDrop::into_inner(new_table)
         .                       }
         .                   }
    10,143 ( 0.00%)      }
         .           
         .               fn clone_from(&mut self, source: &Self) {
         .                   if source.table.is_empty_singleton() {
         .                       *self = Self::new_in(self.table.alloc.clone());
         .                   } else {
         .                       unsafe {
         .                           // First, drop all our elements without clearing the control bytes.
         .                           self.drop_elements();
-- line 1640 ----------------------------------------
-- line 1687 ----------------------------------------
         .                       .table
         .                       .ctrl(0)
         .                       .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());
         .                   source
         .                       .data_start()
         .                       .copy_to_nonoverlapping(self.data_start(), self.table.buckets());
         .           
         .                   self.table.items = source.table.items;
        52 ( 0.00%)          self.table.growth_left = source.table.growth_left;
         .               }
         .           }
         .           
         .           impl<T: Clone, A: Allocator + Clone> RawTable<T, A> {
         .               /// Common code for clone and clone_from. Assumes `self.buckets() == source.buckets()`.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               unsafe fn clone_from_impl(&mut self, source: &Self, mut on_panic: impl FnMut(&mut Self)) {
         .                   // Copy the control bytes unchanged. We do this in a single pass
-- line 1703 ----------------------------------------
-- line 1790 ----------------------------------------
         .               fn default() -> Self {
         .                   Self::new_in(Default::default())
         .               }
         .           }
         .           
         .           #[cfg(feature = "nightly")]
         .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawTable<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
   918,868 ( 0.02%)      fn drop(&mut self) {
   707,457 ( 0.02%)          if !self.table.is_empty_singleton() {
         .                       unsafe {
         .                           self.drop_elements();
         .                           self.free_buckets();
         .                       }
         .                   }
   990,556 ( 0.02%)      }
         .           }
         .           #[cfg(not(feature = "nightly"))]
         .           impl<T, A: Allocator + Clone> Drop for RawTable<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn drop(&mut self) {
         .                   if !self.table.is_empty_singleton() {
         .                       unsafe {
         .                           self.drop_elements();
-- line 1813 ----------------------------------------
-- line 1817 ----------------------------------------
         .               }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> IntoIterator for RawTable<T, A> {
         .               type Item = T;
         .               type IntoIter = RawIntoIter<T, A>;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
    12,296 ( 0.00%)      fn into_iter(self) -> RawIntoIter<T, A> {
         .                   unsafe {
         .                       let iter = self.iter();
         .                       self.into_iter_from(iter)
         .                   }
    15,370 ( 0.00%)      }
         .           }
         .           
         .           /// Iterator over a sub-range of a table. Unlike `RawIter` this iterator does
         .           /// not track an item count.
         .           pub(crate) struct RawIterRange<T> {
         .               // Mask of full buckets in the current group. Bits are cleared from this
         .               // mask as each element is processed.
         .               current_group: BitMask,
-- line 1838 ----------------------------------------
-- line 1934 ----------------------------------------
         .           
         .           impl<T> Iterator for RawIterRange<T> {
         .               type Item = Bucket<T>;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn next(&mut self) -> Option<Bucket<T>> {
         .                   unsafe {
         .                       loop {
   303,728 ( 0.01%)                  if let Some(index) = self.current_group.lowest_set_bit() {
    43,324 ( 0.00%)                      self.current_group = self.current_group.remove_lowest_bit();
    77,132 ( 0.00%)                      return Some(self.data.next_n(index));
         .                           }
         .           
   324,448 ( 0.01%)                  if self.next_ctrl >= self.end {
         .                               return None;
         .                           }
         .           
         .                           // We might read past self.end up to the next group boundary,
         .                           // but this is fine because it only occurs on tables smaller
         .                           // than the group size where the trailing control bytes are all
         .                           // EMPTY. On larger tables self.end is guaranteed to be aligned
         .                           // to the group size (since tables are power-of-two sized).
     4,741 ( 0.00%)                  self.current_group = Group::load_aligned(self.next_ctrl).match_full();
     5,561 ( 0.00%)                  self.data = self.data.next_n(Group::WIDTH);
     7,459 ( 0.00%)                  self.next_ctrl = self.next_ctrl.add(Group::WIDTH);
         .                       }
         .                   }
         .               }
         .           
         .               #[inline]
         .               fn size_hint(&self) -> (usize, Option<usize>) {
         .                   // We don't have an item count, so just guess based on the range size.
         .                   (
-- line 1966 ----------------------------------------
-- line 2102 ----------------------------------------
         .                           }
         .                       } else {
         .                           // We must have already iterated past the removed item.
         .                       }
         .                   }
         .               }
         .           
         .               unsafe fn drop_elements(&mut self) {
     1,976 ( 0.00%)          if mem::needs_drop::<T>() && self.len() != 0 {
         .                       for item in self {
         .                           item.drop();
         .                       }
         .                   }
         .               }
         .           }
         .           
         .           impl<T> Clone for RawIter<T> {
-- line 2118 ----------------------------------------
-- line 2124 ----------------------------------------
         .                   }
         .               }
         .           }
         .           
         .           impl<T> Iterator for RawIter<T> {
         .               type Item = Bucket<T>;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
    58,295 ( 0.00%)      fn next(&mut self) -> Option<Bucket<T>> {
   119,516 ( 0.00%)          if let Some(b) = self.iter.next() {
   539,408 ( 0.01%)              self.items -= 1;
         .                       Some(b)
         .                   } else {
         .                       // We don't check against items == 0 here to allow the
         .                       // compiler to optimize away the item count entirely if the
         .                       // iterator length is never queried.
         .                       debug_assert_eq!(self.items, 0);
         .                       None
         .                   }
   116,590 ( 0.00%)      }
         .           
         .               #[inline]
         .               fn size_hint(&self) -> (usize, Option<usize>) {
         .                   (self.items, Some(self.items))
         .               }
         .           }
         .           
         .           impl<T> ExactSizeIterator for RawIter<T> {}
-- line 2151 ----------------------------------------
-- line 2177 ----------------------------------------
         .               T: Sync,
         .               A: Sync,
         .           {
         .           }
         .           
         .           #[cfg(feature = "nightly")]
         .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
     3,370 ( 0.00%)      fn drop(&mut self) {
         .                   unsafe {
         .                       // Drop all remaining elements
         .                       self.iter.drop_elements();
         .           
         .                       // Free the table
    28,795 ( 0.00%)              if let Some((ptr, layout)) = self.allocation {
         .                           self.alloc.deallocate(ptr, layout);
         .                       }
         .                   }
       278 ( 0.00%)      }
         .           }
         .           #[cfg(not(feature = "nightly"))]
         .           impl<T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn drop(&mut self) {
         .                   unsafe {
         .                       // Drop all remaining elements
         .                       self.iter.drop_elements();
-- line 2203 ----------------------------------------
-- line 2209 ----------------------------------------
         .                   }
         .               }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> Iterator for RawIntoIter<T, A> {
         .               type Item = T;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
     2,189 ( 0.00%)      fn next(&mut self) -> Option<T> {
     1,317 ( 0.00%)          unsafe { Some(self.iter.next()?.read()) }
     5,239 ( 0.00%)      }
         .           
         .               #[inline]
         .               fn size_hint(&self) -> (usize, Option<usize>) {
         4 ( 0.00%)          self.iter.size_hint()
         .               }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> ExactSizeIterator for RawIntoIter<T, A> {}
         .           impl<T, A: Allocator + Clone> FusedIterator for RawIntoIter<T, A> {}
         .           
         .           /// Iterator which consumes elements without freeing the table storage.
         .           pub struct RawDrain<'a, T, A: Allocator + Clone = Global> {
-- line 2231 ----------------------------------------
-- line 2259 ----------------------------------------
         .           where
         .               T: Sync,
         .               A: Sync,
         .           {
         .           }
         .           
         .           impl<T, A: Allocator + Clone> Drop for RawDrain<'_, T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
     1,712 ( 0.00%)      fn drop(&mut self) {
         .                   unsafe {
         .                       // Drop all remaining elements. Note that this may panic.
         .                       self.iter.drop_elements();
         .           
         .                       // Reset the contents of the table now that all elements have been
         .                       // dropped.
         .                       self.table.clear_no_drop();
         .           
         .                       // Move the now empty table back to its original location.
       214 ( 0.00%)              self.orig_table
         .                           .as_ptr()
         .                           .copy_from_nonoverlapping(&*self.table, 1);
         .                   }
     1,712 ( 0.00%)      }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> Iterator for RawDrain<'_, T, A> {
         .               type Item = T;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn next(&mut self) -> Option<T> {
         .                   unsafe {
-- line 2289 ----------------------------------------

12,477,064 ( 0.27%)  <counts for unidentified lines in /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs
--------------------------------------------------------------------------------
Ir                 

-- line 141 ----------------------------------------
        .               /// ```
        .               /// let a = [1, 2, 3];
        .               /// assert!(!a.is_empty());
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_stable(feature = "const_slice_is_empty", since = "1.39.0")]
        .               #[inline]
        .               pub const fn is_empty(&self) -> bool {
  498,438 ( 0.01%)          self.len() == 0
        .               }
        .           
        .               /// Returns the first element of the slice, or `None` if it is empty.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let v = [10, 40, 30];
-- line 157 ----------------------------------------
-- line 159 ----------------------------------------
        .               ///
        .               /// let w: &[i32] = &[];
        .               /// assert_eq!(None, w.first());
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
        .               #[inline]
        .               pub const fn first(&self) -> Option<&T> {
    4,206 ( 0.00%)          if let [first, ..] = self { Some(first) } else { None }
        .               }
        .           
        .               /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let x = &mut [0, 1, 2];
-- line 175 ----------------------------------------
-- line 178 ----------------------------------------
        .               ///     *first = 5;
        .               /// }
        .               /// assert_eq!(x, &[5, 1, 2]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_unstable(feature = "const_slice_first_last", issue = "83570")]
        .               #[inline]
        .               pub const fn first_mut(&mut self) -> Option<&mut T> {
    2,048 ( 0.00%)          if let [first, ..] = self { Some(first) } else { None }
        .               }
        .           
        .               /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let x = &[0, 1, 2];
-- line 194 ----------------------------------------
-- line 237 ----------------------------------------
        .               ///     assert_eq!(last, &2);
        .               ///     assert_eq!(elements, &[0, 1]);
        .               /// }
        .               /// ```
        .               #[stable(feature = "slice_splits", since = "1.5.0")]
        .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
        .               #[inline]
        .               pub const fn split_last(&self) -> Option<(&T, &[T])> {
   20,346 ( 0.00%)          if let [init @ .., last] = self { Some((last, init)) } else { None }
        .               }
        .           
        .               /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let x = &mut [0, 1, 2];
-- line 253 ----------------------------------------
-- line 276 ----------------------------------------
        .               ///
        .               /// let w: &[i32] = &[];
        .               /// assert_eq!(None, w.last());
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
        .               #[inline]
        .               pub const fn last(&self) -> Option<&T> {
  334,556 ( 0.01%)          if let [.., last] = self { Some(last) } else { None }
        .               }
        .           
        .               /// Returns a mutable pointer to the last item in the slice.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let x = &mut [0, 1, 2];
-- line 292 ----------------------------------------
-- line 295 ----------------------------------------
        .               ///     *last = 10;
        .               /// }
        .               /// assert_eq!(x, &[0, 1, 10]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_unstable(feature = "const_slice_first_last", issue = "83570")]
        .               #[inline]
        .               pub const fn last_mut(&mut self) -> Option<&mut T> {
  654,447 ( 0.01%)          if let [.., last] = self { Some(last) } else { None }
        .               }
        .           
        .               /// Returns a reference to an element or subslice depending on the type of
        .               /// index.
        .               ///
        .               /// - If given a position, returns a reference to the element at that
        .               ///   position or `None` if out of bounds.
        .               /// - If given a range, returns the subslice corresponding to that range,
-- line 311 ----------------------------------------
-- line 448 ----------------------------------------
        .               /// }
        .               /// ```
        .               ///
        .               /// [`as_mut_ptr`]: slice::as_mut_ptr
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_stable(feature = "const_slice_as_ptr", since = "1.32.0")]
        .               #[inline]
        .               pub const fn as_ptr(&self) -> *const T {
  606,144 ( 0.01%)          self as *const [T] as *const T
        .               }
        .           
        .               /// Returns an unsafe mutable pointer to the slice's buffer.
        .               ///
        .               /// The caller must ensure that the slice outlives the pointer this
        .               /// function returns, or else it will end up pointing to garbage.
        .               ///
        .               /// Modifying the container referenced by this slice may cause its buffer
-- line 464 ----------------------------------------
-- line 476 ----------------------------------------
        .               ///     }
        .               /// }
        .               /// assert_eq!(x, &[3, 4, 6]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_unstable(feature = "const_ptr_offset", issue = "71499")]
        .               #[inline]
        .               pub const fn as_mut_ptr(&mut self) -> *mut T {
       19 ( 0.00%)          self as *mut [T] as *mut T
        .               }
        .           
        .               /// Returns the two raw pointers spanning the slice.
        .               ///
        .               /// The returned range is half-open, which means that the end pointer
        .               /// points *one past* the last element of the slice. This way, an empty
        .               /// slice is represented by two equal pointers, and the difference between
        .               /// the two pointers represents the size of the slice.
-- line 492 ----------------------------------------
-- line 556 ----------------------------------------
        .               /// [`as_mut_ptr`]: slice::as_mut_ptr
        .               #[stable(feature = "slice_ptr_range", since = "1.48.0")]
        .               #[rustc_const_unstable(feature = "const_ptr_offset", issue = "71499")]
        .               #[inline]
        .               pub const fn as_mut_ptr_range(&mut self) -> Range<*mut T> {
        .                   let start = self.as_mut_ptr();
        .                   // SAFETY: See as_ptr_range() above for why `add` here is safe.
        .                   let end = unsafe { start.add(self.len()) };
        2 ( 0.00%)          start..end
        .               }
        .           
        .               /// Swaps two elements in the slice.
        .               ///
        .               /// # Arguments
        .               ///
        .               /// * a - The index of the first element
        .               /// * b - The index of the second element
-- line 572 ----------------------------------------
-- line 582 ----------------------------------------
        .               /// v.swap(2, 4);
        .               /// assert!(v == ["a", "b", "e", "d", "c"]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_unstable(feature = "const_swap", issue = "83163")]
        .               #[inline]
        .               #[track_caller]
        .               pub const fn swap(&mut self, a: usize, b: usize) {
   22,256 ( 0.00%)          let _ = &self[a];
   72,736 ( 0.00%)          let _ = &self[b];
        .           
        .                   // SAFETY: we just checked that both `a` and `b` are in bounds
        .                   unsafe { self.swap_unchecked(a, b) }
        .               }
        .           
        .               /// Swaps two elements in the slice, without doing bounds checking.
        .               ///
        .               /// For a safe alternative see [`swap`].
-- line 599 ----------------------------------------
-- line 644 ----------------------------------------
        .               /// ```
        .               /// let mut v = [1, 2, 3];
        .               /// v.reverse();
        .               /// assert!(v == [3, 2, 1]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[inline]
        .               pub fn reverse(&mut self) {
        2 ( 0.00%)          let half_len = self.len() / 2;
        .                   let Range { start, end } = self.as_mut_ptr_range();
        .           
        .                   // These slices will skip the middle item for an odd length,
        .                   // since that one doesn't need to move.
        .                   let (front_half, back_half) =
        .                       // SAFETY: Both are subparts of the original slice, so the memory
        .                       // range is valid, and they don't overlap because they're each only
        .                       // half (or less) of the original slice.
-- line 660 ----------------------------------------
-- line 677 ----------------------------------------
        .           
        .                       // Because this function is first compiled in isolation,
        .                       // this check tells LLVM that the indexing below is
        .                       // in-bounds.  Then after inlining -- once the actual
        .                       // lengths of the slices are known -- it's removed.
        .                       let (a, b) = (&mut a[..n], &mut b[..n]);
        .           
        .                       for i in 0..n {
    2,156 ( 0.00%)                  mem::swap(&mut a[i], &mut b[n - 1 - i]);
        .                       }
        .                   }
        .               }
        .           
        .               /// Returns an iterator over the slice.
        .               ///
        .               /// # Examples
        .               ///
-- line 693 ----------------------------------------
-- line 1499 ----------------------------------------
        .               ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);
        .               ///     assert_eq!(right, []);
        .               /// }
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[inline]
        .               #[track_caller]
        .               pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {
      414 ( 0.00%)          assert!(mid <= self.len());
        .                   // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        .                   // fulfills the requirements of `from_raw_parts_mut`.
        .                   unsafe { self.split_at_unchecked(mid) }
        .               }
        .           
        .               /// Divides one mutable slice into two at an index.
        .               ///
        .               /// The first will contain all indices from `[0, mid)` (excluding
-- line 1515 ----------------------------------------
-- line 1530 ----------------------------------------
        .               /// left[1] = 2;
        .               /// right[1] = 4;
        .               /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[inline]
        .               #[track_caller]
        .               pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
   38,086 ( 0.00%)          assert!(mid <= self.len());
        .                   // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        .                   // fulfills the requirements of `from_raw_parts_mut`.
        .                   unsafe { self.split_at_mut_unchecked(mid) }
        .               }
        .           
        .               /// Divides one slice into two at an index, without doing bounds checking.
        .               ///
        .               /// The first will contain all indices from `[0, mid)` (excluding
-- line 1546 ----------------------------------------
-- line 1628 ----------------------------------------
        .               pub unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
        .                   let len = self.len();
        .                   let ptr = self.as_mut_ptr();
        .           
        .                   // SAFETY: Caller has to check that `0 <= mid <= self.len()`.
        .                   //
        .                   // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference
        .                   // is fine.
    5,691 ( 0.00%)          unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }
        .               }
        .           
        .               /// Divides one slice into an array and a remainder slice at an index.
        .               ///
        .               /// The array will contain all indices from `[0, N)` (excluding
        .               /// the index `N` itself) and the slice will contain all
        .               /// indices from `[N, len)` (excluding the index `len` itself).
        .               ///
-- line 1644 ----------------------------------------
-- line 2113 ----------------------------------------
        .               /// assert!(!v.iter().any(|e| e == "hi"));
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[inline]
        .               pub fn contains(&self, x: &T) -> bool
        .               where
        .                   T: PartialEq,
        .               {
      468 ( 0.00%)          cmp::SliceContains::slice_contains(x, self)
        .               }
        .           
        .               /// Returns `true` if `needle` is a prefix of the slice.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let v = [10, 40, 30];
-- line 2129 ----------------------------------------
-- line 2142 ----------------------------------------
        .               /// assert!(v.starts_with(&[]));
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               pub fn starts_with(&self, needle: &[T]) -> bool
        .               where
        .                   T: PartialEq,
        .               {
        .                   let n = needle.len();
    4,841 ( 0.00%)          self.len() >= n && needle == &self[..n]
        .               }
        .           
        .               /// Returns `true` if `needle` is a suffix of the slice.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// let v = [10, 40, 30];
-- line 2158 ----------------------------------------
-- line 2171 ----------------------------------------
        .               /// assert!(v.ends_with(&[]));
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               pub fn ends_with(&self, needle: &[T]) -> bool
        .               where
        .                   T: PartialEq,
        .               {
        .                   let (m, n) = (self.len(), needle.len());
    4,772 ( 0.00%)          m >= n && needle == &self[m - n..]
        .               }
        .           
        .               /// Returns a subslice with the prefix removed.
        .               ///
        .               /// If the slice starts with `prefix`, returns the subslice after the prefix, wrapped in `Some`.
        .               /// If `prefix` is empty, simply returns the original slice.
        .               ///
        .               /// If the slice does not start with `prefix`, returns `None`.
-- line 2187 ----------------------------------------
-- line 2293 ----------------------------------------
        .               /// s.insert(idx, num);
        .               /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);
        .               /// ```
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               pub fn binary_search(&self, x: &T) -> Result<usize, usize>
        .               where
        .                   T: Ord,
        .               {
        3 ( 0.00%)          self.binary_search_by(|p| p.cmp(x))
        .               }
        .           
        .               /// Binary searches this sorted slice with a comparator function.
        .               ///
        .               /// The comparator function should implement an order consistent
        .               /// with the sort order of the underlying slice, returning an
        .               /// order code that indicates whether its argument is `Less`,
        .               /// `Equal` or `Greater` the desired target.
-- line 2309 ----------------------------------------
-- line 2345 ----------------------------------------
        .               #[inline]
        .               pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>
        .               where
        .                   F: FnMut(&'a T) -> Ordering,
        .               {
        .                   let mut size = self.len();
        .                   let mut left = 0;
        .                   let mut right = size;
2,226,639 ( 0.05%)          while left < right {
3,012,909 ( 0.07%)              let mid = left + size / 2;
        .           
        .                       // SAFETY: the call is made safe by the following invariants:
        .                       // - `mid >= 0`
        .                       // - `mid < size`: `mid` is limited by `[left; right)` bound.
  302,880 ( 0.01%)              let cmp = f(unsafe { self.get_unchecked(mid) });
        .           
        .                       // The reason why we use if/else control flow rather than match
        .                       // is because match reorders comparison operations, which is perf sensitive.
        .                       // This is x86 asm for u8: https://rust.godbolt.org/z/8Y8Pra.
  890,305 ( 0.02%)              if cmp == Less {
1,524,246 ( 0.03%)                  left = mid + 1;
  397,400 ( 0.01%)              } else if cmp == Greater {
        .                           right = mid;
        .                       } else {
        .                           // SAFETY: same as the `get_unchecked` above
        .                           unsafe { crate::intrinsics::assume(mid < self.len()) };
        .                           return Ok(mid);
        .                       }
        .           
2,577,143 ( 0.06%)              size = right - left;
        .                   }
        .                   Err(left)
        .               }
        .           
        .               /// Binary searches this sorted slice with a key extraction function.
        .               ///
        .               /// Assumes that the slice is sorted by the key, for instance with
        .               /// [`sort_by_key`] using the same key extraction function.
-- line 2382 ----------------------------------------
-- line 3203 ----------------------------------------
        .                   #[track_caller]
        .                   fn len_mismatch_fail(dst_len: usize, src_len: usize) -> ! {
        .                       panic!(
        .                           "source slice length ({}) does not match destination slice length ({})",
        .                           src_len, dst_len,
        .                       );
        .                   }
        .           
  116,938 ( 0.00%)          if self.len() != src.len() {
        .                       len_mismatch_fail(self.len(), src.len());
        .                   }
        .           
        .                   // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was
        .                   // checked to have the same length. The slices cannot overlap because
        .                   // mutable references are exclusive.
        .                   unsafe {
        .                       ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());
-- line 3219 ----------------------------------------
-- line 3382 ----------------------------------------
        .                   }
        .                   let gcd: usize = gcd(mem::size_of::<T>(), mem::size_of::<U>());
        .                   let ts: usize = mem::size_of::<U>() / gcd;
        .                   let us: usize = mem::size_of::<T>() / gcd;
        .           
        .                   // Armed with this knowledge, we can find how many `U`s we can fit!
        .                   let us_len = self.len() / ts * us;
        .                   // And how many `T`s will be in the trailing slice!
   46,538 ( 0.00%)          let ts_len = self.len() % ts;
        .                   (us_len, ts_len)
        .               }
        .           
        .               /// Transmute the slice to a slice of another type, ensuring alignment of the types is
        .               /// maintained.
        .               ///
        .               /// This method splits the slice into three distinct slices: prefix, correctly aligned middle
        .               /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest
-- line 3398 ----------------------------------------
-- line 3429 ----------------------------------------
        .                       return (self, &[], &[]);
        .                   }
        .           
        .                   // First, find at what point do we split between the first and 2nd slice. Easy with
        .                   // ptr.align_offset.
        .                   let ptr = self.as_ptr();
        .                   // SAFETY: See the `align_to_mut` method for the detailed safety comment.
        .                   let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };
   46,538 ( 0.00%)          if offset > self.len() {
        .                       (self, &[], &[])
        .                   } else {
        .                       let (left, rest) = self.split_at(offset);
        .                       let (us_len, ts_len) = rest.align_to_offsets::<U>();
        .                       // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,
        .                       // since the caller guarantees that we can transmute `T` to `U` safely.
        .                       unsafe {
        .                           (
        .                               left,
        .                               from_raw_parts(rest.as_ptr() as *const U, us_len),
   46,538 ( 0.00%)                      from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),
        .                           )
        .                       }
        .                   }
        .               }
        .           
        .               /// Transmute the slice to a slice of another type, ensuring alignment of the types is
        .               /// maintained.
        .               ///
-- line 3456 ----------------------------------------

2,115,343 ( 0.05%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_trait_selection/src/traits/fulfill.rs
--------------------------------------------------------------------------------
Ir                 

-- line 33 ----------------------------------------
        .           
        .           impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {
        .               /// Note that we include both the `ParamEnv` and the `Predicate`,
        .               /// as the `ParamEnv` can influence whether fulfillment succeeds
        .               /// or fails.
        .               type CacheKey = ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>;
        .           
        .               fn as_cache_key(&self) -> Self::CacheKey {
  160,290 ( 0.00%)          self.obligation.param_env.and(self.obligation.predicate)
        .               }
        .           }
        .           
        .           /// The fulfillment context is used to drive trait resolution. It
        .           /// consists of a list of obligations that must be (eventually)
        .           /// satisfied. The job is to track which are satisfied, which yielded
        .           /// errors, and which are still pending. At any point, users can call
        .           /// `select_where_possible`, and the fulfillment context will try to do
-- line 49 ----------------------------------------
-- line 95 ----------------------------------------
        .           }
        .           
        .           // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.
        .           #[cfg(all(target_arch = "x86_64", target_pointer_width = "64"))]
        .           static_assert_size!(PendingPredicateObligation<'_>, 72);
        .           
        .           impl<'a, 'tcx> FulfillmentContext<'tcx> {
        .               /// Creates a new fulfillment context.
    5,975 ( 0.00%)      pub fn new() -> FulfillmentContext<'tcx> {
   76,440 ( 0.00%)          FulfillmentContext {
    6,707 ( 0.00%)              predicates: ObligationForest::new(),
        .                       relationships: FxHashMap::default(),
        .                       register_region_obligations: true,
        .                       usable_in_snapshot: false,
        .                   }
    5,975 ( 0.00%)      }
        .           
        .               pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {
       15 ( 0.00%)          FulfillmentContext {
        5 ( 0.00%)              predicates: ObligationForest::new(),
        .                       relationships: FxHashMap::default(),
        .                       register_region_obligations: true,
        .                       usable_in_snapshot: true,
        .                   }
        .               }
        .           
        .               pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {
   17,972 ( 0.00%)          FulfillmentContext {
    4,493 ( 0.00%)              predicates: ObligationForest::new(),
        .                       relationships: FxHashMap::default(),
        .                       register_region_obligations: false,
        .                       usable_in_snapshot: false,
        .                   }
        .               }
        .           
        .               /// Attempts to select obligations using `selcx`.
        .               fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>) -> Vec<FulfillmentError<'tcx>> {
   61,026 ( 0.00%)          let span = debug_span!("select", obligation_forest_size = ?self.predicates.len());
        .                   let _enter = span.enter();
        .           
        .                   let mut errors = Vec::new();
        .           
        .                   loop {
        .                       debug!("select: starting another iteration");
        .           
        .                       // Process pending obligations.
        .                       let outcome: Outcome<_, _> =
  257,096 ( 0.01%)                  self.predicates.process_obligations(&mut FulfillProcessor {
        .                               selcx,
   36,728 ( 0.00%)                      register_region_obligations: self.register_region_obligations,
        .                           });
        .                       debug!("select: outcome={:#?}", outcome);
        .           
        .                       // FIXME: if we kept the original cache key, we could mark projection
        .                       // obligations as complete for the projection cache here.
        .           
        .                       errors.extend(outcome.errors.into_iter().map(to_fulfillment_error));
        .           
        .                       // If nothing new was added, no need to keep looping.
   73,456 ( 0.00%)              if outcome.stalled {
        .                           break;
        .                       }
        .                   }
        .           
        .                   debug!(
        .                       "select({} predicates remaining, {} errors) done",
        .                       self.predicates.len(),
        .                       errors.len()
-- line 162 ----------------------------------------
-- line 169 ----------------------------------------
        .           impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {
        .               /// "Normalize" a projection type `<SomeType as SomeTrait>::X` by
        .               /// creating a fresh type variable `$0` as well as a projection
        .               /// predicate `<SomeType as SomeTrait>::X == $0`. When the
        .               /// inference engine runs, it will attempt to find an impl of
        .               /// `SomeTrait` or a where-clause that lets us unify `$0` with
        .               /// something concrete. If this fails, we'll unify `$0` with
        .               /// `projection_ty` again.
      110 ( 0.00%)      #[tracing::instrument(level = "debug", skip(self, infcx, param_env, cause))]
        .               fn normalize_projection_type(
        .                   &mut self,
        .                   infcx: &InferCtxt<'_, 'tcx>,
        .                   param_env: ty::ParamEnv<'tcx>,
        .                   projection_ty: ty::ProjectionTy<'tcx>,
        .                   cause: ObligationCause<'tcx>,
        .               ) -> Ty<'tcx> {
        .                   debug_assert!(!projection_ty.has_escaping_bound_vars());
        .           
        .                   // FIXME(#20304) -- cache
        .           
        .                   let mut selcx = SelectionContext::new(infcx);
        .                   let mut obligations = vec![];
       45 ( 0.00%)          let normalized_ty = project::normalize_projection_type(
        .                       &mut selcx,
        .                       param_env,
        .                       projection_ty,
       25 ( 0.00%)              cause,
        .                       0,
        .                       &mut obligations,
        .                   );
        .                   self.register_predicate_obligations(infcx, obligations);
        .           
        .                   debug!(?normalized_ty);
        .           
        .                   normalized_ty
        .               }
        .           
  116,586 ( 0.00%)      fn register_predicate_obligation(
        .                   &mut self,
        .                   infcx: &InferCtxt<'_, 'tcx>,
        .                   obligation: PredicateObligation<'tcx>,
        .               ) {
        .                   // this helps to reduce duplicate errors, as well as making
        .                   // debug output much nicer to read and so on.
   58,293 ( 0.00%)          let obligation = infcx.resolve_vars_if_possible(obligation);
        .           
        .                   debug!(?obligation, "register_predicate_obligation");
        .           
  116,586 ( 0.00%)          assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);
        .           
   58,293 ( 0.00%)          super::relationships::update(self, infcx, &obligation);
        .           
        .                   self.predicates
        .                       .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });
   97,155 ( 0.00%)      }
        .           
  157,904 ( 0.00%)      fn select_all_or_error(&mut self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<FulfillmentError<'tcx>> {
        .                   {
   19,738 ( 0.00%)              let errors = self.select_where_possible(infcx);
   19,738 ( 0.00%)              if !errors.is_empty() {
        .                           return errors;
        .                       }
        .                   }
        .           
   98,690 ( 0.00%)          self.predicates.to_errors(CodeAmbiguity).into_iter().map(to_fulfillment_error).collect()
  138,166 ( 0.00%)      }
        .           
  305,130 ( 0.01%)      fn select_where_possible(
        .                   &mut self,
        .                   infcx: &InferCtxt<'_, 'tcx>,
        .               ) -> Vec<FulfillmentError<'tcx>> {
        .                   let mut selcx = SelectionContext::new(infcx);
        .                   self.select(&mut selcx)
  274,617 ( 0.01%)      }
        .           
      216 ( 0.00%)      fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {
        .                   self.predicates.map_pending_obligations(|o| o.obligation.clone())
      288 ( 0.00%)      }
        .           
        .               fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {
       24 ( 0.00%)          &mut self.relationships
       24 ( 0.00%)      }
        .           }
        .           
        .           struct FulfillProcessor<'a, 'b, 'tcx> {
        .               selcx: &'a mut SelectionContext<'b, 'tcx>,
        .               register_region_obligations: bool,
        .           }
        .           
        .           fn mk_pending(os: Vec<PredicateObligation<'_>>) -> Vec<PendingPredicateObligation<'_>> {
-- line 258 ----------------------------------------
-- line 275 ----------------------------------------
        .               #[inline(always)]
        .               fn process_obligation(
        .                   &mut self,
        .                   pending_obligation: &mut Self::Obligation,
        .               ) -> ProcessResult<Self::Obligation, Self::Error> {
        .                   // If we were stalled on some unresolved variables, first check whether
        .                   // any of them have been resolved; if not, don't bother doing more work
        .                   // yet.
2,740,749 ( 0.06%)          let change = match pending_obligation.stalled_on.len() {
        .                       // Match arms are in order of frequency, which matters because this
        .                       // code is so hot. 1 and 0 dominate; 2+ is fairly rare.
        .                       1 => {
1,332,231 ( 0.03%)                  let infer_var = pending_obligation.stalled_on[0];
  444,077 ( 0.01%)                  self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)
        .                       }
        .                       0 => {
        .                           // In this case we haven't changed, but wish to make a change.
        .                           true
        .                       }
        .                       _ => {
        .                           // This `for` loop was once a call to `all()`, but this lower-level
        .                           // form was a perf win. See #64545 for details.
    8,685 ( 0.00%)                  (|| {
   16,692 ( 0.00%)                      for &infer_var in &pending_obligation.stalled_on {
        .                                   if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {
        .                                       return true;
        .                                   }
        .                               }
        .                               false
        .                           })()
        .                       }
        .                   };
-- line 306 ----------------------------------------
-- line 309 ----------------------------------------
        .                       debug!(
        .                           "process_predicate: pending obligation {:?} still stalled on {:?}",
        .                           self.selcx.infcx().resolve_vars_if_possible(pending_obligation.obligation.clone()),
        .                           pending_obligation.stalled_on
        .                       );
        .                       return ProcessResult::Unchanged;
        .                   }
        .           
   73,209 ( 0.00%)          self.progress_changed_obligations(pending_obligation)
        .               }
        .           
        .               fn process_backedge<'c, I>(
        .                   &mut self,
        .                   cycle: I,
        .                   _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,
        .               ) where
        .                   I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,
-- line 325 ----------------------------------------
-- line 333 ----------------------------------------
        .               }
        .           }
        .           
        .           impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {
        .               // The code calling this method is extremely hot and only rarely
        .               // actually uses this, so move this part of the code
        .               // out of that loop.
        .               #[inline(never)]
  244,030 ( 0.01%)      fn progress_changed_obligations(
        .                   &mut self,
        .                   pending_obligation: &mut PendingPredicateObligation<'tcx>,
        .               ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {
        .                   pending_obligation.stalled_on.truncate(0);
        .           
        .                   let obligation = &mut pending_obligation.obligation;
        .           
   73,209 ( 0.00%)          if obligation.predicate.has_infer_types_or_consts() {
   12,809 ( 0.00%)              obligation.predicate =
   38,427 ( 0.00%)                  self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);
        .                   }
        .           
        .                   debug!(?obligation, ?obligation.cause, "process_obligation");
        .           
        .                   let infcx = self.selcx.infcx();
        .           
   23,188 ( 0.00%)          let binder = obligation.predicate.kind();
  170,821 ( 0.00%)          match binder.no_bound_vars() {
        .                       None => match binder.skip_binder() {
        .                           // Evaluation will discard candidates using the leak check.
        .                           // This means we need to pass it the bound version of our
        .                           // predicate.
        .                           ty::PredicateKind::Trait(trait_ref) => {
        .                               let trait_obligation = obligation.with(binder.rebind(trait_ref));
        .           
        .                               self.process_trait_obligation(
-- line 367 ----------------------------------------
-- line 397 ----------------------------------------
        .                           ty::PredicateKind::TypeWellFormedFromEnv(..) => {
        .                               bug!("TypeWellFormedFromEnv is only used for Chalk")
        .                           }
        .                       },
        .                       Some(pred) => match pred {
        .                           ty::PredicateKind::Trait(data) => {
        .                               let trait_obligation = obligation.with(Binder::dummy(data));
        .           
   54,340 ( 0.00%)                      self.process_trait_obligation(
        .                                   obligation,
  239,096 ( 0.01%)                          trait_obligation,
        .                                   &mut pending_obligation.stalled_on,
        .                               )
        .                           }
        .           
        .                           ty::PredicateKind::RegionOutlives(data) => {
    3,672 ( 0.00%)                      match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {
    2,448 ( 0.00%)                          Ok(()) => ProcessResult::Changed(vec![]),
        .                                   Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),
        .                               }
        .                           }
        .           
        .                           ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {
    4,666 ( 0.00%)                      if self.register_region_obligations {
   11,665 ( 0.00%)                          self.selcx.infcx().register_region_obligation_with_cause(
        .                                       t_a,
        .                                       r_b,
        .                                       &obligation.cause,
        .                                   );
        .                               }
        .                               ProcessResult::Changed(vec![])
        .                           }
        .           
        .                           ty::PredicateKind::Projection(ref data) => {
        .                               let project_obligation = obligation.with(Binder::dummy(*data));
        .           
    9,105 ( 0.00%)                      self.process_projection_obligation(
        .                                   obligation,
   27,315 ( 0.00%)                          project_obligation,
        .                                   &mut pending_obligation.stalled_on,
        .                               )
        .                           }
        .           
        .                           ty::PredicateKind::ObjectSafe(trait_def_id) => {
       96 ( 0.00%)                      if !self.selcx.tcx().is_object_safe(trait_def_id) {
        .                                   ProcessResult::Error(CodeSelectionError(Unimplemented))
        .                               } else {
        .                                   ProcessResult::Changed(vec![])
        .                               }
        .                           }
        .           
        .                           ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {
      255 ( 0.00%)                      match self.selcx.infcx().closure_kind(closure_substs) {
        .                                   Some(closure_kind) => {
      510 ( 0.00%)                              if closure_kind.extends(kind) {
        .                                           ProcessResult::Changed(vec![])
        .                                       } else {
        .                                           ProcessResult::Error(CodeSelectionError(Unimplemented))
        .                                       }
        .                                   }
        .                                   None => ProcessResult::Unchanged,
        .                               }
        .                           }
        .           
        .                           ty::PredicateKind::WellFormed(arg) => {
   57,561 ( 0.00%)                      match wf::obligations(
        .                                   self.selcx.infcx(),
   16,446 ( 0.00%)                          obligation.param_env,
   16,446 ( 0.00%)                          obligation.cause.body_id,
   24,669 ( 0.00%)                          obligation.recursion_depth + 1,
        .                                   arg,
        .                                   obligation.cause.span,
        .                               ) {
        .                                   None => {
    5,548 ( 0.00%)                              pending_obligation.stalled_on =
    9,709 ( 0.00%)                                  vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];
    2,774 ( 0.00%)                              ProcessResult::Unchanged
        .                                   }
   20,508 ( 0.00%)                          Some(os) => ProcessResult::Changed(mk_pending(os)),
        .                               }
        .                           }
        .           
        .                           ty::PredicateKind::Subtype(subtype) => {
    3,440 ( 0.00%)                      match self.selcx.infcx().subtype_predicate(
        .                                   &obligation.cause,
        .                                   obligation.param_env,
        .                                   Binder::dummy(subtype),
        .                               ) {
        .                                   None => {
        .                                       // None means that both are unresolved.
    2,145 ( 0.00%)                              pending_obligation.stalled_on = vec![
      429 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),
      858 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),
        .                                       ];
        .                                       ProcessResult::Unchanged
        .                                   }
        .                                   Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),
        .                                   Some(Err(err)) => {
        .                                       let expected_found =
        .                                           ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);
        .                                       ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(
-- line 497 ----------------------------------------
-- line 498 ----------------------------------------
        .                                           expected_found,
        .                                           err,
        .                                       ))
        .                                   }
        .                               }
        .                           }
        .           
        .                           ty::PredicateKind::Coerce(coerce) => {
       16 ( 0.00%)                      match self.selcx.infcx().coerce_predicate(
        .                                   &obligation.cause,
        .                                   obligation.param_env,
        .                                   Binder::dummy(coerce),
        .                               ) {
        .                                   None => {
        .                                       // None means that both are unresolved.
        5 ( 0.00%)                              pending_obligation.stalled_on = vec![
        1 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(coerce.a).unwrap(),
        2 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(coerce.b).unwrap(),
        .                                       ];
        .                                       ProcessResult::Unchanged
        .                                   }
        .                                   Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),
        .                                   Some(Err(err)) => {
        .                                       let expected_found = ExpectedFound::new(false, coerce.a, coerce.b);
        .                                       ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(
        .                                           expected_found,
        .                                           err,
        .                                       ))
        .                                   }
        .                               }
        .                           }
        .           
        .                           ty::PredicateKind::ConstEvaluatable(uv) => {
       30 ( 0.00%)                      match const_evaluatable::is_const_evaluatable(
        .                                   self.selcx.infcx(),
       60 ( 0.00%)                          uv,
       10 ( 0.00%)                          obligation.param_env,
        5 ( 0.00%)                          obligation.cause.span,
        .                               ) {
        .                                   Ok(()) => ProcessResult::Changed(vec![]),
        .                                   Err(NotConstEvaluatable::MentionsInfer) => {
        .                                       pending_obligation.stalled_on.clear();
        .                                       pending_obligation.stalled_on.extend(
        .                                           uv.substs
        .                                               .iter()
        .                                               .filter_map(TyOrConstInferVar::maybe_from_generic_arg),
-- line 543 ----------------------------------------
-- line 639 ----------------------------------------
        .                                   }
        .                               }
        .                           }
        .                           ty::PredicateKind::TypeWellFormedFromEnv(..) => {
        .                               bug!("TypeWellFormedFromEnv is only used for Chalk")
        .                           }
        .                       },
        .                   }
  219,627 ( 0.00%)      }
        .           
  206,492 ( 0.00%)      #[instrument(level = "debug", skip(self, obligation, stalled_on))]
        .               fn process_trait_obligation(
        .                   &mut self,
        .                   obligation: &PredicateObligation<'tcx>,
        .                   trait_obligation: TraitObligation<'tcx>,
        .                   stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,
        .               ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {
   10,868 ( 0.00%)          let infcx = self.selcx.infcx();
   32,604 ( 0.00%)          if obligation.predicate.is_global() {
        .                       // no type variables present, can use evaluation for better caching.
        .                       // FIXME: consider caching errors too.
   12,272 ( 0.00%)              if infcx.predicate_must_hold_considering_regions(obligation) {
        .                           debug!(
        .                               "selecting trait at depth {} evaluated to holds",
        .                               obligation.recursion_depth
        .                           );
   12,248 ( 0.00%)                  return ProcessResult::Changed(vec![]);
        .                       }
        .                   }
        .           
   33,208 ( 0.00%)          match self.selcx.select(&trait_obligation) {
        .                       Ok(Some(impl_source)) => {
        .                           debug!("selecting trait at depth {} yielded Ok(Some)", obligation.recursion_depth);
   40,734 ( 0.00%)                  ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))
        .                       }
        .                       Ok(None) => {
        .                           debug!("selecting trait at depth {} yielded Ok(None)", obligation.recursion_depth);
        .           
        .                           // This is a bit subtle: for the most part, the
        .                           // only reason we can fail to make progress on
        .                           // trait selection is because we don't have enough
        .                           // information about the types in the trait.
        .                           stalled_on.clear();
        .                           stalled_on.extend(substs_infer_vars(
        .                               self.selcx,
    2,481 ( 0.00%)                      trait_obligation.predicate.map_bound(|pred| pred.trait_ref.substs),
        .                           ));
        .           
        .                           debug!(
        .                               "process_predicate: pending obligation {:?} now stalled on {:?}",
        .                               infcx.resolve_vars_if_possible(obligation.clone()),
        .                               stalled_on
        .                           );
        .           
    2,481 ( 0.00%)                  ProcessResult::Unchanged
        .                       }
        .                       Err(selection_err) => {
        .                           debug!("selecting trait at depth {} yielded Err", obligation.recursion_depth);
        .           
        .                           ProcessResult::Error(CodeSelectionError(selection_err))
        .                       }
        .                   }
        .               }
        .           
   20,031 ( 0.00%)      fn process_projection_obligation(
        .                   &mut self,
        .                   obligation: &PredicateObligation<'tcx>,
        .                   project_obligation: PolyProjectionObligation<'tcx>,
        .                   stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,
        .               ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {
    1,821 ( 0.00%)          let tcx = self.selcx.tcx();
        .           
    5,463 ( 0.00%)          if obligation.predicate.is_global() {
        .                       // no type variables present, can use evaluation for better caching.
        .                       // FIXME: consider caching errors too.
      474 ( 0.00%)              if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {
    1,422 ( 0.00%)                  if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(
        .                               &mut self.selcx,
    1,659 ( 0.00%)                      project_obligation.predicate,
        .                           ) {
        .                               // If `predicate_must_hold_considering_regions` succeeds, then we've
        .                               // evaluated all sub-obligations. We can therefore mark the 'root'
        .                               // obligation as complete, and skip evaluating sub-obligations.
    1,422 ( 0.00%)                      self.selcx
        .                                   .infcx()
        .                                   .inner
        .                                   .borrow_mut()
        .                                   .projection_cache()
        .                                   .complete(key, EvaluationResult::EvaluatedToOk);
        .                           }
      474 ( 0.00%)                  return ProcessResult::Changed(vec![]);
        .                       } else {
        .                           tracing::debug!("Does NOT hold: {:?}", obligation);
        .                       }
        .                   }
        .           
   11,088 ( 0.00%)          match project::poly_project_and_unify_type(self.selcx, &project_obligation) {
        .                       Ok(Ok(Some(os))) => ProcessResult::Changed(mk_pending(os)),
        .                       Ok(Ok(None)) => {
        .                           stalled_on.clear();
        .                           stalled_on.extend(substs_infer_vars(
        .                               self.selcx,
      894 ( 0.00%)                      project_obligation.predicate.map_bound(|pred| pred.projection_ty.substs),
        .                           ));
      894 ( 0.00%)                  ProcessResult::Unchanged
        .                       }
        .                       // Let the caller handle the recursion
        .                       Ok(Err(project::InProgress)) => ProcessResult::Changed(mk_pending(vec![
        .                           project_obligation.with(project_obligation.predicate.to_predicate(tcx)),
        .                       ])),
        .                       Err(e) => ProcessResult::Error(CodeProjectionError(e)),
        .                   }
   14,568 ( 0.00%)      }
        .           }
        .           
        .           /// Returns the set of inference variables contained in `substs`.
        .           fn substs_infer_vars<'a, 'tcx>(
        .               selcx: &mut SelectionContext<'a, 'tcx>,
        .               substs: ty::Binder<'tcx, SubstsRef<'tcx>>,
        .           ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {
        .               selcx
        .                   .infcx()
        .                   .resolve_vars_if_possible(substs)
        .                   .skip_binder() // ok because this check doesn't care about regions
        .                   .iter()
        .                   .filter(|arg| arg.has_infer_types_or_consts())
        .                   .flat_map(|arg| {
   19,055 ( 0.00%)              let mut walker = arg.walk();
   34,299 ( 0.00%)              while let Some(c) = walker.next() {
    3,811 ( 0.00%)                  if !c.has_infer_types_or_consts() {
        .                               walker.visited.remove(&c);
        .                               walker.skip_current_subtree();
        .                           }
        .                       }
        .                       walker.visited.into_iter()
        .                   })
        .                   .filter_map(TyOrConstInferVar::maybe_from_generic_arg)
        .           }
-- line 776 ----------------------------------------

2,096,832 ( 0.05%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_trait_selection/src/traits/fulfill.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/library/std/src/sys/unix/alloc.rs
--------------------------------------------------------------------------------
Ir                 

-- line 5 ----------------------------------------
        .           #[stable(feature = "alloc_system_type", since = "1.28.0")]
        .           unsafe impl GlobalAlloc for System {
        .               #[inline]
        .               unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        .                   // jemalloc provides alignment less than MIN_ALIGN for small allocations.
        .                   // So only rely on MIN_ALIGN if size >= align.
        .                   // Also see <https://github.com/rust-lang/rust/issues/45955> and
        .                   // <https://github.com/rust-lang/rust/issues/62251#issuecomment-507580914>.
3,399,558 ( 0.07%)          if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {
2,549,667 ( 0.06%)              libc::malloc(layout.size()) as *mut u8
        .                   } else {
        .                       #[cfg(target_os = "macos")]
        .                       {
        .                           if layout.align() > (1 << 31) {
        .                               return ptr::null_mut();
        .                           }
        .                       }
        .                       aligned_malloc(&layout)
        .                   }
        .               }
        .           
        .               #[inline]
        .               unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        .                   // See the comment above in `alloc` for why this check looks the way it does.
  321,696 ( 0.01%)          if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {
  482,544 ( 0.01%)              libc::calloc(layout.size(), 1) as *mut u8
        .                   } else {
        .                       let ptr = self.alloc(layout);
        .                       if !ptr.is_null() {
        .                           ptr::write_bytes(ptr, 0, layout.size());
        .                       }
        .                       ptr
        .                   }
        .               }
        .           
        .               #[inline]
        .               unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {
  930,303 ( 0.02%)          libc::free(ptr as *mut libc::c_void)
        .               }
        .           
        .               #[inline]
        .               unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
  313,104 ( 0.01%)          if layout.align() <= MIN_ALIGN && layout.align() <= new_size {
  626,208 ( 0.01%)              libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8
        .                   } else {
        .                       realloc_fallback(self, ptr, layout, new_size)
        .                   }
        .               }
        .           }
        .           
        .           cfg_if::cfg_if! {
        .               if #[cfg(any(
-- line 56 ----------------------------------------
-- line 84 ----------------------------------------
        .               } else if #[cfg(target_os = "wasi")] {
        .                   #[inline]
        .                   unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
        .                       libc::aligned_alloc(layout.align(), layout.size()) as *mut u8
        .                   }
        .               } else {
        .                   #[inline]
        .                   unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
        1 ( 0.00%)              let mut out = ptr::null_mut();
        .                       // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.
        .                       // Since these are all powers of 2, we can just use max.
        .                       let align = layout.align().max(crate::mem::size_of::<usize>());
        2 ( 0.00%)              let ret = libc::posix_memalign(&mut out, align, layout.size());
        2 ( 0.00%)              if ret != 0 { ptr::null_mut() } else { out as *mut u8 }
        .                   }
        .               }
        .           }

        1 ( 0.00%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/library/std/src/sys/unix/alloc.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/obligation_forest/mod.rs
--------------------------------------------------------------------------------
Ir                 

-- line 121 ----------------------------------------
        .           #[derive(Debug)]
        .           pub enum ProcessResult<O, E> {
        .               Unchanged,
        .               Changed(Vec<O>),
        .               Error(E),
        .           }
        .           
        .           #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
   30,938 ( 0.00%)  struct ObligationTreeId(usize);
        .           
        .           type ObligationTreeIdGenerator =
        .               std::iter::Map<std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;
        .           
        .           pub struct ObligationForest<O: ForestObligation> {
        .               /// The list of obligations. In between calls to `process_obligations`,
        .               /// this list only contains nodes in the `Pending` or `Waiting` state.
        .               ///
-- line 137 ----------------------------------------
-- line 181 ----------------------------------------
        .               has_parent: bool,
        .           
        .               /// Identifier of the obligation tree to which this node belongs.
        .               obligation_tree_id: ObligationTreeId,
        .           }
        .           
        .           impl<O> Node<O> {
        .               fn new(parent: Option<usize>, obligation: O, obligation_tree_id: ObligationTreeId) -> Node<O> {
  314,224 ( 0.01%)          Node {
        .                       obligation,
        .                       state: Cell::new(NodeState::Pending),
   32,149 ( 0.00%)              dependents: if let Some(parent_index) = parent { vec![parent_index] } else { vec![] },
        .                       has_parent: parent.is_some(),
        .                       obligation_tree_id,
        .                   }
        .               }
        .           }
        .           
        .           /// The state of one node in some tree within the forest. This represents the
        .           /// current state of processing for the obligation (of type `O`) associated
-- line 200 ----------------------------------------
-- line 223 ----------------------------------------
        .           ///  |     compress()
        .           ///  v
        .           /// (Removed)
        .           /// ```
        .           /// The `Error` state can be introduced in several places, via `error_at()`.
        .           ///
        .           /// Outside of `ObligationForest` methods, nodes should be either `Pending` or
        .           /// `Waiting`.
  898,190 ( 0.02%)  #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        .           enum NodeState {
        .               /// This obligation has not yet been selected successfully. Cannot have
        .               /// subobligations.
        .               Pending,
        .           
        .               /// This obligation was selected successfully, but may or may not have
        .               /// subobligations.
        .               Success,
-- line 239 ----------------------------------------
-- line 279 ----------------------------------------
        .               pub stalled: bool,
        .           }
        .           
        .           impl<O, E> OutcomeTrait for Outcome<O, E> {
        .               type Error = Error<O, E>;
        .               type Obligation = O;
        .           
        .               fn new() -> Self {
   73,456 ( 0.00%)          Self { stalled: true, errors: vec![] }
        .               }
        .           
        .               fn mark_not_stalled(&mut self) {
   19,211 ( 0.00%)          self.stalled = false;
        .               }
        .           
        .               fn is_stalled(&self) -> bool {
   11,536 ( 0.00%)          self.stalled
        .               }
        .           
        .               fn record_completed(&mut self, _outcome: &Self::Obligation) {
        .                   // do nothing
        .               }
        .           
        .               fn record_error(&mut self, error: Self::Error) {
        .                   self.errors.push(error)
-- line 303 ----------------------------------------
-- line 306 ----------------------------------------
        .           
        .           #[derive(Debug, PartialEq, Eq)]
        .           pub struct Error<O, E> {
        .               pub error: E,
        .               pub backtrace: Vec<O>,
        .           }
        .           
        .           impl<O: ForestObligation> ObligationForest<O> {
   11,177 ( 0.00%)      pub fn new() -> ObligationForest<O> {
  134,124 ( 0.00%)          ObligationForest {
        .                       nodes: vec![],
        .                       done_cache: Default::default(),
        .                       active_cache: Default::default(),
        .                       reused_node_vec: vec![],
        .                       obligation_tree_id_generator: (0..).map(ObligationTreeId),
        .                       error_cache: Default::default(),
        .                   }
   11,177 ( 0.00%)      }
        .           
        .               /// Returns the total number of nodes in the forest that have not
        .               /// yet been fully resolved.
        .               pub fn len(&self) -> usize {
        .                   self.nodes.len()
        .               }
        .           
        .               /// Registers an obligation.
        .               pub fn register_obligation(&mut self, obligation: O) {
        .                   // Ignore errors here - there is no guarantee of success.
  252,603 ( 0.01%)          let _ = self.register_obligation_at(obligation, None);
        .               }
        .           
        .               // Returns Err(()) if we already know this obligation failed.
  302,203 ( 0.01%)      fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {
   54,946 ( 0.00%)          let cache_key = obligation.as_cache_key();
   54,946 ( 0.00%)          if self.done_cache.contains(&cache_key) {
        .                       debug!("register_obligation_at: ignoring already done obligation: {:?}", obligation);
        .                       return Ok(());
        .                   }
        .           
  132,000 ( 0.00%)          match self.active_cache.entry(cache_key) {
        .                       Entry::Occupied(o) => {
    4,722 ( 0.00%)                  let node = &mut self.nodes[*o.get()];
    4,722 ( 0.00%)                  if let Some(parent_index) = parent {
        .                               // If the node is already in `active_cache`, it has already
        .                               // had its chance to be marked with a parent. So if it's
        .                               // not already present, just dump `parent` into the
        .                               // dependents as a non-parent.
    2,439 ( 0.00%)                      if !node.dependents.contains(&parent_index) {
        .                                   node.dependents.push(parent_index);
        .                               }
        .                           }
    7,083 ( 0.00%)                  if let NodeState::Error = node.state.get() { Err(()) } else { Ok(()) }
        .                       }
   58,917 ( 0.00%)              Entry::Vacant(v) => {
  117,834 ( 0.00%)                  let obligation_tree_id = match parent {
    8,340 ( 0.00%)                      Some(parent_index) => self.nodes[parent_index].obligation_tree_id,
        .                               None => self.obligation_tree_id_generator.next().unwrap(),
        .                           };
        .           
        .                           let already_failed = parent.is_some()
        .                               && self
        .                                   .error_cache
        .                                   .get(&obligation_tree_id)
        .                                   .map_or(false, |errors| errors.contains(v.key()));
        .           
        .                           if already_failed {
        .                               Err(())
        .                           } else {
   19,639 ( 0.00%)                      let new_index = self.nodes.len();
        .                               v.insert(new_index);
        .                               self.nodes.push(Node::new(parent, obligation, obligation_tree_id));
        .                               Ok(())
        .                           }
        .                       }
        .                   }
  247,257 ( 0.01%)      }
        .           
        .               /// Converts all remaining obligations to the given error.
  138,166 ( 0.00%)      pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {
        .                   let errors = self
        .                       .nodes
        .                       .iter()
        .                       .enumerate()
        .                       .filter(|(_index, node)| node.state.get() == NodeState::Pending)
        .                       .map(|(index, _node)| Error { error: error.clone(), backtrace: self.error_at(index) })
        .                       .collect();
        .           
   39,476 ( 0.00%)          self.compress(|_| assert!(false));
        .                   errors
  118,428 ( 0.00%)      }
        .           
        .               /// Returns the set of obligations that are in a pending state.
        .               pub fn map_pending_obligations<P, F>(&self, f: F) -> Vec<P>
        .               where
        .                   F: Fn(&O) -> P,
        .               {
        5 ( 0.00%)          self.nodes
        .                       .iter()
        .                       .filter(|node| node.state.get() == NodeState::Pending)
        .                       .map(|node| f(&node.obligation))
        .                       .collect()
        .               }
        .           
        .               fn insert_into_error_cache(&mut self, index: usize) {
        .                   let node = &self.nodes[index];
-- line 410 ----------------------------------------
-- line 414 ----------------------------------------
        .                       .insert(node.obligation.as_cache_key());
        .               }
        .           
        .               /// Performs a pass through the obligation list. This must
        .               /// be called in a loop until `outcome.stalled` is false.
        .               ///
        .               /// This _cannot_ be unrolled (presently, at least).
        .               #[inline(never)]
  330,552 ( 0.01%)      pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT
        .               where
        .                   P: ObligationProcessor<Obligation = O>,
        .                   OUT: OutcomeTrait<Obligation = O, Error = Error<O, P::Error>>,
        .               {
        .                   let mut outcome = OUT::new();
        .           
        .                   // Note that the loop body can append new nodes, and those new nodes
        .                   // will then be processed by subsequent iterations of the loop.
        .                   //
        .                   // We can't use an iterator for the loop because `self.nodes` is
        .                   // appended to and the borrow checker would complain. We also can't use
        .                   // `for index in 0..self.nodes.len() { ... }` because the range would
        .                   // be computed with the initial length, and we would miss the appended
        .                   // nodes. Therefore we use a `while` loop.
        .                   let mut index = 0;
  505,818 ( 0.01%)          while let Some(node) = self.nodes.get_mut(index) {
        .                       // `processor.process_obligation` can modify the predicate within
        .                       // `node.obligation`, and that predicate is the key used for
        .                       // `self.active_cache`. This means that `self.active_cache` can get
        .                       // out of sync with `nodes`. It's not very common, but it does
        .                       // happen, and code in `compress` has to allow for it.
  938,180 ( 0.02%)              if node.state.get() != NodeState::Pending {
    2,479 ( 0.00%)                  index += 1;
        .                           continue;
        .                       }
        .           
  111,631 ( 0.00%)              match processor.process_obligation(&mut node.obligation) {
        .                           ProcessResult::Unchanged => {
        .                               // No change in state.
        .                           }
   76,844 ( 0.00%)                  ProcessResult::Changed(children) => {
        .                               // We are not (yet) stalled.
        .                               outcome.mark_not_stalled();
        .                               node.state.set(NodeState::Success);
        .           
   92,928 ( 0.00%)                      for child in children {
  136,714 ( 0.00%)                          let st = self.register_obligation_at(child, Some(index));
   16,084 ( 0.00%)                          if let Err(()) = st {
        .                                       // Error already reported - propagate it
        .                                       // to our node.
        .                                       self.error_at(index);
        .                                   }
        .                               }
        .                           }
        .                           ProcessResult::Error(err) => {
        .                               outcome.mark_not_stalled();
        .                               outcome.record_error(Error { error: err, backtrace: self.error_at(index) });
        .                           }
        .                       }
  933,222 ( 0.02%)              index += 1;
        .                   }
        .           
        .                   // There's no need to perform marking, cycle processing and compression when nothing
        .                   // changed.
   11,536 ( 0.00%)          if !outcome.is_stalled() {
        .                       self.mark_successes();
        .                       self.process_cycles(processor);
   12,430 ( 0.00%)              self.compress(|obl| outcome.record_completed(obl));
        .                   }
        .           
        .                   outcome
  330,552 ( 0.01%)      }
        .           
        .               /// Returns a vector of obligations for `p` and all of its
        .               /// ancestors, putting them into the error state in the process.
        .               fn error_at(&self, mut index: usize) -> Vec<O> {
        .                   let mut error_stack: Vec<usize> = vec![];
        .                   let mut trace = vec![];
        .           
        .                   loop {
-- line 492 ----------------------------------------
-- line 516 ----------------------------------------
        .                   trace
        .               }
        .           
        .               /// Mark all `Waiting` nodes as `Success`, except those that depend on a
        .               /// pending node.
        .               fn mark_successes(&self) {
        .                   // Convert all `Waiting` nodes to `Success`.
        .                   for node in &self.nodes {
  212,281 ( 0.00%)              if node.state.get() == NodeState::Waiting {
        .                           node.state.set(NodeState::Success);
        .                       }
        .                   }
        .           
        .                   // Convert `Success` nodes that depend on a pending node back to
        .                   // `Waiting`.
        .                   for node in &self.nodes {
  134,533 ( 0.00%)              if node.state.get() == NodeState::Pending {
        .                           // This call site is hot.
        .                           self.inlined_mark_dependents_as_waiting(node);
        .                       }
        .                   }
        .               }
        .           
        .               // This always-inlined function is for the hot call site.
        .               #[inline(always)]
        .               fn inlined_mark_dependents_as_waiting(&self, node: &Node<O>) {
    1,171 ( 0.00%)          for &index in node.dependents.iter() {
        .                       let node = &self.nodes[index];
    1,171 ( 0.00%)              let state = node.state.get();
    1,171 ( 0.00%)              if state == NodeState::Success {
        .                           // This call site is cold.
    2,385 ( 0.00%)                  self.uninlined_mark_dependents_as_waiting(node);
        .                       } else {
        .                           debug_assert!(state == NodeState::Waiting || state == NodeState::Error)
        .                       }
        .                   }
        .               }
        .           
        .               // This never-inlined function is for the cold call site.
        .               #[inline(never)]
    5,565 ( 0.00%)      fn uninlined_mark_dependents_as_waiting(&self, node: &Node<O>) {
        .                   // Mark node Waiting in the cold uninlined code instead of the hot inlined
        .                   node.state.set(NodeState::Waiting);
        .                   self.inlined_mark_dependents_as_waiting(node)
    6,360 ( 0.00%)      }
        .           
        .               /// Report cycles between all `Success` nodes, and convert all `Success`
        .               /// nodes to `Done`. This must be called after `mark_successes`.
        .               fn process_cycles<P>(&mut self, processor: &mut P)
        .               where
        .                   P: ObligationProcessor<Obligation = O>,
        .               {
    6,215 ( 0.00%)          let mut stack = std::mem::take(&mut self.reused_node_vec);
        .                   for (index, node) in self.nodes.iter().enumerate() {
        .                       // For some benchmarks this state test is extremely hot. It's a win
        .                       // to handle the no-op cases immediately to avoid the cost of the
        .                       // function call.
  134,533 ( 0.00%)              if node.state.get() == NodeState::Success {
   94,875 ( 0.00%)                  self.find_cycles_from_node(&mut stack, processor, index);
        .                       }
        .                   }
        .           
        .                   debug_assert!(stack.is_empty());
   49,720 ( 0.00%)          self.reused_node_vec = stack;
        .               }
        .           
  214,182 ( 0.00%)      fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)
        .               where
        .                   P: ObligationProcessor<Obligation = O>,
        .               {
        .                   let node = &self.nodes[index];
   47,596 ( 0.00%)          if node.state.get() == NodeState::Success {
      472 ( 0.00%)              match stack.iter().rposition(|&n| n == index) {
        .                           None => {
        .                               stack.push(index);
    4,823 ( 0.00%)                      for &dep_index in node.dependents.iter() {
   19,292 ( 0.00%)                          self.find_cycles_from_node(stack, processor, dep_index);
        .                               }
        .                               stack.pop();
        .                               node.state.set(NodeState::Done);
        .                           }
        .                           Some(rpos) => {
        .                               // Cycle detected.
        .                               processor.process_backedge(
        .                                   stack[rpos..].iter().map(|&i| &self.nodes[i].obligation),
        .                                   PhantomData,
        .                               );
        .                           }
        .                       }
        .                   }
  190,384 ( 0.00%)      }
        .           
        .               /// Compresses the vector, removing all popped nodes. This adjusts the
        .               /// indices and hence invalidates any outstanding indices. `process_cycles`
        .               /// must be run beforehand to remove any cycles on `Success` nodes.
        .               #[inline(never)]
  187,886 ( 0.00%)      fn compress(&mut self, mut outcome_cb: impl FnMut(&O)) {
   25,953 ( 0.00%)          let orig_nodes_len = self.nodes.len();
        .                   let mut node_rewrites: Vec<_> = std::mem::take(&mut self.reused_node_vec);
        .                   debug_assert!(node_rewrites.is_empty());
        .                   node_rewrites.extend(0..orig_nodes_len);
        .                   let mut dead_nodes = 0;
        .           
        .                   // Move removable nodes to the end, preserving the order of the
        .                   // remaining nodes.
        .                   //
        .                   // LOOP INVARIANT:
        .                   //     self.nodes[0..index - dead_nodes] are the first remaining nodes
        .                   //     self.nodes[index - dead_nodes..index] are all dead
        .                   //     self.nodes[index..] are unchanged
        .                   for index in 0..orig_nodes_len {
        .                       let node = &self.nodes[index];
  697,525 ( 0.02%)              match node.state.get() {
        .                           NodeState::Pending | NodeState::Waiting => {
  230,644 ( 0.01%)                      if dead_nodes > 0 {
   66,864 ( 0.00%)                          self.nodes.swap(index, index - dead_nodes);
  111,440 ( 0.00%)                          node_rewrites[index] -= dead_nodes;
        .                               }
        .                           }
        .                           NodeState::Done => {
        .                               // This lookup can fail because the contents of
        .                               // `self.active_cache` are not guaranteed to match those of
        .                               // `self.nodes`. See the comment in `process_obligation`
        .                               // for more details.
   70,098 ( 0.00%)                      if let Some((predicate, _)) =
   57,633 ( 0.00%)                          self.active_cache.remove_entry(&node.obligation.as_cache_key())
        .                               {
        .                                   self.done_cache.insert(predicate);
        .                               } else {
        .                                   self.done_cache.insert(node.obligation.as_cache_key().clone());
        .                               }
        .                               // Extract the success stories.
        .                               outcome_cb(&node.obligation);
   38,422 ( 0.00%)                      node_rewrites[index] = orig_nodes_len;
   38,422 ( 0.00%)                      dead_nodes += 1;
        .                           }
        .                           NodeState::Error => {
        .                               // We *intentionally* remove the node from the cache at this point. Otherwise
        .                               // tests must come up with a different type on every type error they
        .                               // check against.
        .                               self.active_cache.remove(&node.obligation.as_cache_key());
        .                               self.insert_into_error_cache(index);
        .                               node_rewrites[index] = orig_nodes_len;
-- line 658 ----------------------------------------
-- line 659 ----------------------------------------
        .                               dead_nodes += 1;
        .                           }
        .                           NodeState::Success => unreachable!(),
        .                       }
        .                   }
        .           
        .                   if dead_nodes > 0 {
        .                       // Remove the dead nodes and rewrite indices.
   11,876 ( 0.00%)              self.nodes.truncate(orig_nodes_len - dead_nodes);
    5,938 ( 0.00%)              self.apply_rewrites(&node_rewrites);
        .                   }
        .           
        .                   node_rewrites.truncate(0);
  103,812 ( 0.00%)          self.reused_node_vec = node_rewrites;
  207,624 ( 0.00%)      }
        .           
        .               #[inline(never)]
   53,442 ( 0.00%)      fn apply_rewrites(&mut self, node_rewrites: &[usize]) {
        .                   let orig_nodes_len = node_rewrites.len();
        .           
        .                   for node in &mut self.nodes {
        .                       let mut i = 0;
  114,191 ( 0.00%)              while let Some(dependent) = node.dependents.get_mut(i) {
    2,328 ( 0.00%)                  let new_index = node_rewrites[*dependent];
    1,164 ( 0.00%)                  if new_index >= orig_nodes_len {
        .                               node.dependents.swap_remove(i);
        .                               if i == 0 && node.has_parent {
        .                                   // We just removed the parent.
        .                                   node.has_parent = false;
        .                               }
        .                           } else {
      582 ( 0.00%)                      *dependent = new_index;
    1,164 ( 0.00%)                      i += 1;
        .                           }
        .                       }
        .                   }
        .           
        .                   // This updating of `self.active_cache` is necessary because the
        .                   // removal of nodes within `compress` can fail. See above.
        .                   self.active_cache.retain(|_predicate, index| {
  481,420 ( 0.01%)              let new_index = node_rewrites[*index];
  240,710 ( 0.01%)              if new_index >= orig_nodes_len {
        .                           false
        .                       } else {
  113,609 ( 0.00%)                  *index = new_index;
        .                           true
        .                       }
        .                   });
   47,504 ( 0.00%)      }
        .           }

1,373,905 ( 0.03%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/obligation_forest/mod.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/dl-lookup.c
  ./malloc/malloc.c
  ./stdlib/msort.c
  ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S
  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
219,053,529 ( 4.79%)  events annotated

