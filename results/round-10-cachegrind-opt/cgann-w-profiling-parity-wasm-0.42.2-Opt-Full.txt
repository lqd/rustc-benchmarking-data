--------------------------------------------------------------------------------
I1 cache:         65536 B, 64 B, 4-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         67108864 B, 64 B, 64-way associative
Command:          /usr/home/liquid/.rustup/toolchains/w-profiling/bin/rustc --crate-name parity_wasm --edition=2018 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C opt-level=3 -C embed-bitcode=no --cfg feature="default" --cfg feature="std" -C metadata=6e348d1bad35d48d -C extra-filename=-6e348d1bad35d48d --out-dir /usr/home/liquid/tmp/.tmp33hcVL/target/release/deps -L dependency=/usr/home/liquid/tmp/.tmp33hcVL/target/release/deps -Adeprecated -Aunknown-lints -Zincremental-verify-ich
Data file:        results/cgout-w-profiling-parity-wasm-0.42.2-Opt-Full
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       0.1
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
30,584,161,781 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                    file:function
--------------------------------------------------------------------------------
877,692,915 ( 2.87%)  ./malloc/malloc.c:_int_free
799,435,701 ( 2.61%)  ./malloc/malloc.c:_int_malloc
612,553,596 ( 2.00%)  ???:llvm::InstCombinerImpl::run()
561,607,133 ( 1.84%)  ???:llvm::isNonEscapingLocalObject(llvm::Value const*, llvm::SmallDenseMap<llvm::Value const*, bool, 8u, llvm::DenseMapInfo<llvm::Value const*>, llvm::detail::DenseMapPair<llvm::Value const*, bool> >*)
555,215,826 ( 1.82%)  ./malloc/malloc.c:malloc
430,850,454 ( 1.41%)  ???:combineInstructionsOverFunction(llvm::Function&, llvm::InstCombineWorklist&, llvm::AAResults*, llvm::AssumptionCache&, llvm::TargetLibraryInfo&, llvm::TargetTransformInfo&, llvm::DominatorTree&, llvm::OptimizationRemarkEmitter&, llvm::BlockFrequencyInfo*, llvm::ProfileSummaryInfo*, unsigned int, llvm::LoopInfo*)
385,206,944 ( 1.26%)  ???:llvm::SelectionDAG::Combine(llvm::CombineLevel, llvm::AAResults*, llvm::CodeGenOpt::Level)
381,721,734 ( 1.25%)  ???:llvm::FPPassManager::runOnFunction(llvm::Function&)
321,108,342 ( 1.05%)  ???:llvm::MachineInstr::isIdenticalTo(llvm::MachineInstr const&, llvm::MachineInstr::MICheckType) const
284,129,946 ( 0.93%)  ./malloc/malloc.c:free
272,482,249 ( 0.89%)  ???:llvm::BasicAAResult::alias(llvm::MemoryLocation const&, llvm::MemoryLocation const&, llvm::AAQueryInfo&)
271,522,274 ( 0.89%)  ???:llvm::AnalysisManager<llvm::Function>::getResultImpl(llvm::AnalysisKey*, llvm::Function&)
254,370,937 ( 0.83%)  ???:llvm::AnalysisManager<llvm::Function>::invalidate(llvm::Function&, llvm::PreservedAnalyses const&)
250,603,728 ( 0.82%)  ???:llvm::BitstreamCursor::readRecord(unsigned int, llvm::SmallVectorImpl<unsigned long>&, llvm::StringRef*)
233,722,298 ( 0.76%)  ???:llvm::InstCombinerImpl::visitCallInst(llvm::CallInst&)
224,875,057 ( 0.74%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::BatchUpdateInfo*)
216,345,951 ( 0.71%)  ???:llvm::DataLayout::getAlignment(llvm::Type*, bool) const
205,048,812 ( 0.67%)  ???:runCVP(llvm::Module&) [clone .llvm.11785992503873176614]
187,846,161 ( 0.61%)  ???:computeKnownBits(llvm::Value const*, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&) [clone .llvm.15619146473165121143]
183,497,482 ( 0.60%)  ???:llvm::ValueHandleBase::AddToUseList()
174,821,432 ( 0.57%)  ???:llvm::TargetLibraryInfoImpl::getLibFunc(llvm::Function const&, llvm::LibFunc&) const
174,261,320 ( 0.57%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe
174,045,973 ( 0.57%)  ???:bool llvm::DenseMapBase<llvm::DenseMap<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*, llvm::DenseMapInfo<(anonymous namespace)::SimpleValue>, llvm::detail::DenseMapPair<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*> >, (anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*, llvm::DenseMapInfo<(anonymous namespace)::SimpleValue>, llvm::detail::DenseMapPair<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*> >::LookupBucketFor<(anonymous namespace)::SimpleValue>((anonymous namespace)::SimpleValue const&, llvm::detail::DenseMapPair<(anonymous namespace)::SimpleValue, llvm::ScopedHashTableVal<(anonymous namespace)::SimpleValue, llvm::Value*>*> const*&) const
173,475,215 ( 0.57%)  ???:llvm::BasicAAResult::getModRefInfo(llvm::CallBase const*, llvm::MemoryLocation const&, llvm::AAQueryInfo&)
170,952,734 ( 0.56%)  ???:llvm::removeUnreachableBlocks(llvm::Function&, llvm::DomTreeUpdater*, llvm::MemorySSAUpdater*)
163,430,428 ( 0.53%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
163,236,680 ( 0.53%)  ???:llvm::BranchFolder::TryTailMergeBlocks(llvm::MachineBasicBlock*, llvm::MachineBasicBlock*, unsigned int)
158,356,232 ( 0.52%)  ???:llvm::DataLayout::getTypeSizeInBits(llvm::Type*) const
153,397,320 ( 0.50%)  ???:llvm::SimplifyInstruction(llvm::Instruction*, llvm::SimplifyQuery const&, llvm::OptimizationRemarkEmitter*)
152,047,173 ( 0.50%)  ???:llvm::LiveVariables::runOnBlock(llvm::MachineBasicBlock*, unsigned int)
149,148,797 ( 0.49%)  ???:llvm::AttributeSetNode::get(llvm::LLVMContext&, llvm::AttrBuilder const&)
148,633,206 ( 0.49%)  ???:llvm::AttributeList::addAttributes(llvm::LLVMContext&, unsigned int, llvm::AttrBuilder const&) const
143,309,324 ( 0.47%)  ???:computeKnownBitsFromOperator(llvm::Operator const*, llvm::APInt const&, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&)
140,865,948 ( 0.46%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_erms
138,139,439 ( 0.45%)  ???:(anonymous namespace)::eliminateDeadStores(llvm::Function&, llvm::AAResults&, llvm::MemorySSA&, llvm::DominatorTree&, llvm::PostDominatorTree&, llvm::TargetLibraryInfo const&, llvm::LoopInfo const&) [clone .llvm.5769264623867638418]
129,052,985 ( 0.42%)  ???:llvm::SROA::runOnAlloca(llvm::AllocaInst&)
123,880,523 ( 0.41%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::runSemiNCA(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, unsigned int)
121,610,438 ( 0.40%)  ./malloc/malloc.c:malloc_consolidate
118,240,671 ( 0.39%)  ???:SimplifyICmpInst(unsigned int, llvm::Value*, llvm::Value*, llvm::SimplifyQuery const&, unsigned int) [clone .llvm.1619516508949622737]
111,226,989 ( 0.36%)  ???:llvm::GVN::processBlock(llvm::BasicBlock*)
111,184,081 ( 0.36%)  ???:llvm::SROA::runImpl(llvm::Function&, llvm::DominatorTree&, llvm::AssumptionCache&)
107,986,687 ( 0.35%)  ???:llvm::AttributeList::get(llvm::LLVMContext&, llvm::ArrayRef<llvm::AttributeList>)
107,771,404 ( 0.35%)  ???:(anonymous namespace)::LazyValueInfoImpl::solve() [clone .llvm.4316243980339171764]
102,857,004 ( 0.34%)  ???:llvm::FindFunctionBackedges(llvm::Function const&, llvm::SmallVectorImpl<std::pair<llvm::BasicBlock const*, llvm::BasicBlock const*> >&)
102,171,014 ( 0.33%)  ???:llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode*, unsigned char const*, unsigned int)
 98,917,259 ( 0.32%)  ???:llvm::InlineFunction(llvm::CallBase&, llvm::InlineFunctionInfo&, llvm::AAResults*, bool, llvm::Function*)
 98,215,979 ( 0.32%)  ???:(anonymous namespace)::MachineCopyPropagation::runOnMachineFunction(llvm::MachineFunction&)
 96,979,803 ( 0.32%)  ???:llvm::simplifyCFG(llvm::BasicBlock*, llvm::TargetTransformInfo const&, llvm::DomTreeUpdater*, llvm::SimplifyCFGOptions const&, llvm::ArrayRef<llvm::WeakVH>)
 96,104,679 ( 0.31%)  ???:(anonymous namespace)::EarlyCSE::run() [clone .llvm.7062997131228810369]
 94,435,239 ( 0.31%)  ???:llvm::InstCombinerImpl::visitICmpInst(llvm::ICmpInst&)
 94,334,358 ( 0.31%)  ???:llvm::MemorySSA::buildMemorySSA(llvm::BatchAAResults&)
 93,400,120 ( 0.31%)  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long)
 88,546,189 ( 0.29%)  ???:llvm::SimplifyGEPInst(llvm::Type*, llvm::ArrayRef<llvm::Value*>, llvm::SimplifyQuery const&)
 88,067,233 ( 0.29%)  ???:llvm::Intrinsic::getDeclaration(llvm::Module*, unsigned int, llvm::ArrayRef<llvm::Type*>)
 84,783,770 ( 0.28%)  ???:llvm::Type::isSizedDerivedType(llvm::SmallPtrSetImpl<llvm::Type*>*) const
 84,164,478 ( 0.28%)  ./malloc/malloc.c:unlink_chunk.constprop.0
 81,384,066 ( 0.27%)  ???:(anonymous namespace)::LazyValueInfoImpl::getEdgeValue(llvm::Value*, llvm::BasicBlock*, llvm::BasicBlock*, llvm::Instruction*) [clone .llvm.4316243980339171764]
 79,853,553 ( 0.26%)  ???:(anonymous namespace)::DeadMachineInstructionElim::eliminateDeadMI(llvm::MachineFunction&)
 79,636,830 ( 0.26%)  ???:isKnownNonZero(llvm::Value const*, llvm::APInt const&, unsigned int, (anonymous namespace)::Query const&) [clone .llvm.15619146473165121143]
 78,424,913 ( 0.26%)  ???:computeKnownBitsFromAssume(llvm::Value const*, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&)
 76,935,232 ( 0.25%)  ???:llvm::coro::declaresIntrinsics(llvm::Module const&, std::initializer_list<llvm::StringRef>)
 75,865,328 ( 0.25%)  ???:llvm::LiveVariables::HandleRegMask(llvm::MachineOperand const&)
 69,976,205 ( 0.23%)  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2
 69,769,835 ( 0.23%)  ???:llvm::AAResults::getModRefInfo(llvm::Instruction const*, llvm::Optional<llvm::MemoryLocation> const&, llvm::AAQueryInfo&)
 68,102,408 ( 0.22%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::FindRoots(llvm::DominatorTreeBase<llvm::BasicBlock, true> const&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::BatchUpdateInfo*)
 67,732,972 ( 0.22%)  ???:llvm::ScalarEvolution::getAddExpr(llvm::SmallVectorImpl<llvm::SCEV const*>&, llvm::SCEV::NoWrapFlags, unsigned int)
 67,421,881 ( 0.22%)  ???:llvm::PMDataManager::verifyPreservedAnalysis(llvm::Pass*)
 67,366,704 ( 0.22%)  ???:llvm::ScheduleDAGSDNodes::BuildSchedUnits()
 67,038,265 ( 0.22%)  ???:llvm::TargetLoweringBase::getTypeConversion(llvm::LLVMContext&, llvm::EVT) const
 65,982,775 ( 0.22%)  ???:llvm::SROA::rewritePartition(llvm::AllocaInst&, llvm::sroa::AllocaSlices&, llvm::sroa::Partition&)
 64,900,662 ( 0.21%)  ???:llvm::SmallPtrSetImplBase::insert_imp_big(void const*)
 64,854,196 ( 0.21%)  ???:llvm::AAResults::Model<llvm::BasicAAResult>::getModRefBehavior(llvm::CallBase const*)
 64,475,556 ( 0.21%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::BasicBlock, true>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::BatchUpdateInfo*)
 64,358,214 ( 0.21%)  ???:llvm::LivePhysRegs::stepBackward(llvm::MachineInstr const&)
 64,351,371 ( 0.21%)  ???:(anonymous namespace)::DAGCombiner::combine(llvm::SDNode*)
 64,115,110 ( 0.21%)  ???:llvm::MemoryDependenceResults::getNonLocalPointerDepFromBB(llvm::Instruction*, llvm::PHITransAddr const&, llvm::MemoryLocation const&, bool, llvm::BasicBlock*, llvm::SmallVectorImpl<llvm::NonLocalDepResult>&, llvm::DenseMap<llvm::BasicBlock*, llvm::Value*, llvm::DenseMapInfo<llvm::BasicBlock*>, llvm::detail::DenseMapPair<llvm::BasicBlock*, llvm::Value*> >&, bool, bool)
 63,738,288 ( 0.21%)  ???:(anonymous namespace)::Verifier::visitInstruction(llvm::Instruction&)
 63,194,413 ( 0.21%)  ???:llvm::detail::PassModel<llvm::Function, llvm::PassManager<llvm::Function, llvm::AnalysisManager<llvm::Function>>, llvm::PreservedAnalyses, llvm::AnalysisManager<llvm::Function>>::run(llvm::Function&, llvm::AnalysisManager<llvm::Function>&)
 60,031,795 ( 0.20%)  ???:bool llvm::SetVector<llvm::AllocaInst*, llvm::SmallVector<llvm::AllocaInst*, 16u>, llvm::DenseSet<llvm::AllocaInst*, llvm::DenseMapInfo<llvm::AllocaInst*> > >::remove_if<llvm::SROA::runImpl(llvm::Function&, llvm::DominatorTree&, llvm::AssumptionCache&)::$_8>(llvm::SROA::runImpl(llvm::Function&, llvm::DominatorTree&, llvm::AssumptionCache&)::$_8)
 59,241,910 ( 0.19%)  ???:llvm::MD5::final(llvm::MD5::MD5Result&)
 58,125,270 ( 0.19%)  ???:llvm::IDFCalculatorBase<llvm::BasicBlock, false>::calculate(llvm::SmallVectorImpl<llvm::BasicBlock*>&)
 57,356,070 ( 0.19%)  ???:(anonymous namespace)::AggressiveDeadCodeElimination::performDeadCodeElimination()
 56,508,991 ( 0.18%)  ???:llvm::LoopInfoBase<llvm::BasicBlock, llvm::Loop>::analyze(llvm::DominatorTreeBase<llvm::BasicBlock, false> const&)
 55,744,908 ( 0.18%)  ???:llvm::PopulateLoopsDFS<llvm::BasicBlock, llvm::Loop>::traverse(llvm::BasicBlock*)
 54,731,501 ( 0.18%)  ???:(anonymous namespace)::SimplifyCFGOpt::simplifyCondBranch(llvm::BranchInst*, llvm::IRBuilder<llvm::ConstantFolder, llvm::IRBuilderDefaultInserter>&)
 54,676,424 ( 0.18%)  ???:llvm::MD5::update(llvm::StringRef)
 54,264,535 ( 0.18%)  ???:llvm::SROA::splitAlloca(llvm::AllocaInst&, llvm::sroa::AllocaSlices&)
 54,104,083 ( 0.18%)  ???:computeKnownBits(llvm::Value const*, llvm::APInt const&, llvm::KnownBits&, unsigned int, (anonymous namespace)::Query const&)
 53,593,441 ( 0.18%)  ???:llvm::LiveIntervals::HMEditor::updateAllRanges(llvm::MachineInstr*)
 53,580,770 ( 0.18%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
 52,821,514 ( 0.17%)  ???:updateCGAndAnalysisManagerForPass(llvm::LazyCallGraph&, llvm::LazyCallGraph::SCC&, llvm::LazyCallGraph::Node&, llvm::AnalysisManager<llvm::LazyCallGraph::SCC, llvm::LazyCallGraph&>&, llvm::CGSCCUpdateResult&, llvm::AnalysisManager<llvm::Function>&, bool) [clone .llvm.5426518467876156712]
 52,484,900 ( 0.17%)  ???:llvm::MachineInstr::addOperand(llvm::MachineFunction&, llvm::MachineOperand const&)
 52,145,729 ( 0.17%)  ???:llvm::InstCombinerImpl::visitAllocSite(llvm::Instruction&)
 51,870,092 ( 0.17%)  ???:(anonymous namespace)::PruningFunctionCloner::CloneBlock(llvm::BasicBlock const*, llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::Instruction, true, false, void>, false, true>, std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> >&)
 51,406,448 ( 0.17%)  ???:(anonymous namespace)::BitcodeReader::parseModule(unsigned long, bool, llvm::function_ref<llvm::Optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > (llvm::StringRef)>)
 51,370,977 ( 0.17%)  ???:llvm::BlockFrequencyInfoImpl<llvm::BasicBlock>::initializeRPOT()
 51,037,759 ( 0.17%)  ???:llvm::InstCombinerImpl::visitBitCast(llvm::BitCastInst&)
 50,756,397 ( 0.17%)  ???:llvm::DemandedBits::isInstructionDead(llvm::Instruction*)
 50,617,375 ( 0.17%)  ???:llvm::InstCombinerImpl::visitAllocaInst(llvm::AllocaInst&)
 50,451,438 ( 0.16%)  ???:llvm::Instruction::eraseFromParent()
 50,191,832 ( 0.16%)  ???:(anonymous namespace)::CVPLatticeFunc::ComputeInstructionState(llvm::Instruction&, llvm::DenseMap<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > >, (anonymous namespace)::CVPLatticeVal, llvm::DenseMapInfo<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > > >, llvm::detail::DenseMapPair<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > >, (anonymous namespace)::CVPLatticeVal> >&, llvm::SparseSolver<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > >, (anonymous namespace)::CVPLatticeVal, llvm::LatticeKeyInfo<llvm::PointerIntPair<llvm::Value*, 2u, (anonymous namespace)::IPOGrouping, llvm::PointerLikeTypeTraits<llvm::Value*>, llvm::PointerIntPairInfo<llvm::Value*, 2u, llvm::PointerLikeTypeTraits<llvm::Value*> > > > >&)
 50,073,704 ( 0.16%)  ???:llvm::Value::stripAndAccumulateConstantOffsets(llvm::DataLayout const&, llvm::APInt&, bool, llvm::function_ref<bool (llvm::Value&, llvm::APInt&)>) const
 49,896,854 ( 0.16%)  ???:llvm::AAResults::Model<llvm::BasicAAResult>::pointsToConstantMemory(llvm::MemoryLocation const&, llvm::AAQueryInfo&, bool)
 49,739,260 ( 0.16%)  ???:llvm::LiveRangeUpdater::flush()
 49,529,471 ( 0.16%)  ???:llvm::InstCombinerImpl::visitLoadInst(llvm::LoadInst&)
 48,998,685 ( 0.16%)  ???:llvm::InstCombinerImpl::SimplifyDemandedUseBits(llvm::Value*, llvm::APInt, llvm::KnownBits&, unsigned int, llvm::Instruction*)
 48,794,299 ( 0.16%)  ???:runImpl(llvm::Function&, llvm::LazyValueInfo*, llvm::DominatorTree*, llvm::SimplifyQuery const&) [clone .llvm.16011871802505272439]
 47,707,287 ( 0.16%)  ???:llvm::BlockFrequencyInfoImpl<llvm::BasicBlock>::tryToComputeMassInFunction()
 47,635,343 ( 0.16%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, true> >::runSemiNCA(llvm::DominatorTreeBase<llvm::BasicBlock, true>&, unsigned int)
 47,562,963 ( 0.16%)  ???:llvm::FoldingSetBase::FindNodeOrInsertPos(llvm::FoldingSetNodeID const&, void*&, llvm::FoldingSetBase::FoldingSetInfo const&)
 46,022,173 ( 0.15%)  ???:llvm::AttributeList::addAttribute(llvm::LLVMContext&, unsigned int, llvm::Attribute::AttrKind) const
 45,630,834 ( 0.15%)  ???:llvm::DAGTypeLegalizer::run()
 45,596,759 ( 0.15%)  ???:llvm::ReassociatePass::BuildRankMap(llvm::Function&, llvm::ReversePostOrderTraversal<llvm::Function*, llvm::GraphTraits<llvm::Function*> >&)
 45,509,217 ( 0.15%)  ???:llvm::JumpThreadingPass::processBlock(llvm::BasicBlock*)
 45,435,507 ( 0.15%)  ???:(anonymous namespace)::StackColoring::runOnMachineFunction(llvm::MachineFunction&)
 45,305,258 ( 0.15%)  ???:llvm::MemorySSA::OptimizeUses::optimizeUses()
 44,577,580 ( 0.15%)  ???:???
 43,955,910 ( 0.14%)  ???:llvm::LoopBase<llvm::BasicBlock, llvm::Loop>::verifyLoop() const
 43,335,542 ( 0.14%)  ???:(anonymous namespace)::BitcodeReader::parseFunctionBody(llvm::Function*)
 43,110,988 ( 0.14%)  ???:(anonymous namespace)::SelectionDAGLegalize::LegalizeOp(llvm::SDNode*) [clone .llvm.8386621111310650999]
 42,309,440 ( 0.14%)  ???:std::back_insert_iterator<std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> > > std::__copy_move_a2<false, llvm::po_iterator<llvm::Function const*, llvm::SmallPtrSet<llvm::BasicBlock const*, 8u>, false, llvm::GraphTraits<llvm::Function const*> >, std::back_insert_iterator<std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> > > >(llvm::po_iterator<llvm::Function const*, llvm::SmallPtrSet<llvm::BasicBlock const*, 8u>, false, llvm::GraphTraits<llvm::Function const*> >, llvm::po_iterator<llvm::Function const*, llvm::SmallPtrSet<llvm::BasicBlock const*, 8u>, false, llvm::GraphTraits<llvm::Function const*> >, std::back_insert_iterator<std::vector<llvm::BasicBlock const*, std::allocator<llvm::BasicBlock const*> > >)
 42,181,787 ( 0.14%)  ???:llvm::SelectionDAG::Legalize()
 41,822,917 ( 0.14%)  ???:llvm::SCCPInstVisitor::solve()
 41,631,617 ( 0.14%)  ???:llvm::InstCombinerImpl::visitStoreInst(llvm::StoreInst&)
 41,491,008 ( 0.14%)  ???:llvm::BlockFrequencyInfoImplBase::finalizeMetrics()
 41,073,714 ( 0.13%)  ???:llvm::ConstantFoldTerminator(llvm::BasicBlock*, bool, llvm::TargetLibraryInfo const*, llvm::DomTreeUpdater*)
 40,994,691 ( 0.13%)  ???:llvm::SelectionDAG::MorphNodeTo(llvm::SDNode*, unsigned int, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>)
 40,657,254 ( 0.13%)  ???:llvm::ScalarEvolution::getRangeRef(llvm::SCEV const*, llvm::ScalarEvolution::RangeSignHint)
 40,110,993 ( 0.13%)  ???:llvm::ScalarEvolution::getSCEV(llvm::Value*)
 40,074,764 ( 0.13%)  ???:llvm::AttributeList::addParamAttribute(llvm::LLVMContext&, llvm::ArrayRef<unsigned int>, llvm::Attribute) const
 39,987,048 ( 0.13%)  ???:(anonymous namespace)::ClobberWalker<llvm::BatchAAResults>::addSearches(llvm::MemoryPhi*, llvm::SmallVectorImpl<unsigned int>&, unsigned int)
 39,871,824 ( 0.13%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilderMut<rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_hash::<hashbrown::map::equivalent<rustc_middle::ty::sty::TyKind, rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>>::{closure#0}>
 39,365,131 ( 0.13%)  ???:llvm::InstrEmitter::EmitMachineNode(llvm::SDNode*, bool, bool, llvm::DenseMap<llvm::SDValue, llvm::Register, llvm::DenseMapInfo<llvm::SDValue>, llvm::detail::DenseMapPair<llvm::SDValue, llvm::Register> >&)
 39,026,534 ( 0.13%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_sse2_unaligned_erms
 38,570,767 ( 0.13%)  ???:(anonymous namespace)::MachineBlockPlacement::selectBestCandidateBlock((anonymous namespace)::BlockChain const&, llvm::SmallVectorImpl<llvm::MachineBasicBlock*>&)
 38,401,978 ( 0.13%)  ???:llvm::SelectionDAG::getConstant(llvm::ConstantInt const&, llvm::SDLoc const&, llvm::EVT, bool, bool)
 37,745,686 ( 0.12%)  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2
 37,656,666 ( 0.12%)  ???:llvm::X86InstrInfo::analyzeBranch(llvm::MachineBasicBlock&, llvm::MachineBasicBlock*&, llvm::MachineBasicBlock*&, llvm::SmallVectorImpl<llvm::MachineOperand>&, bool) const
 37,526,869 ( 0.12%)  ???:(anonymous namespace)::LazyValueInfoImpl::getValueInBlock(llvm::Value*, llvm::BasicBlock*, llvm::Instruction*) [clone .llvm.4316243980339171764]
 36,932,911 ( 0.12%)  ???:getAdjustedPtr(llvm::IRBuilder<llvm::ConstantFolder, (anonymous namespace)::IRBuilderPrefixedInserter>&, llvm::DataLayout const&, llvm::Value*, llvm::APInt, llvm::Type*, llvm::Twine const&)
 36,750,423 ( 0.12%)  ???:llvm::raw_svector_ostream::write_impl(char const*, unsigned long)
 36,726,351 ( 0.12%)  ???:llvm::Instruction::~Instruction()
 35,485,433 ( 0.12%)  ???:llvm::ConstantRange::makeExactICmpRegion(llvm::CmpInst::Predicate, llvm::APInt const&)
 35,371,625 ( 0.12%)  ???:std::back_insert_iterator<std::vector<llvm::BasicBlock*, std::allocator<llvm::BasicBlock*> > > std::__copy_move_a<false, llvm::po_iterator<llvm::Function*, llvm::SmallPtrSet<llvm::BasicBlock*, 8u>, false, llvm::GraphTraits<llvm::Function*> >, std::back_insert_iterator<std::vector<llvm::BasicBlock*, std::allocator<llvm::BasicBlock*> > > >(llvm::po_iterator<llvm::Function*, llvm::SmallPtrSet<llvm::BasicBlock*, 8u>, false, llvm::GraphTraits<llvm::Function*> >, llvm::po_iterator<llvm::Function*, llvm::SmallPtrSet<llvm::BasicBlock*, 8u>, false, llvm::GraphTraits<llvm::Function*> >, std::back_insert_iterator<std::vector<llvm::BasicBlock*, std::allocator<llvm::BasicBlock*> > >)
 35,024,245 ( 0.11%)  ???:llvm::Type::getPrimitiveSizeInBits() const
 34,554,876 ( 0.11%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_trait_selection/src/traits/fulfill.rs:<rustc_data_structures::obligation_forest::ObligationForest<rustc_trait_selection::traits::fulfill::PendingPredicateObligation>>::process_obligations::<rustc_trait_selection::traits::fulfill::FulfillProcessor, rustc_data_structures::obligation_forest::Outcome<rustc_trait_selection::traits::fulfill::PendingPredicateObligation, rustc_infer::traits::FulfillmentErrorCode>>
 34,514,819 ( 0.11%)  ???:llvm::LivePhysRegs::addPristines(llvm::MachineFunction const&)
 34,179,493 ( 0.11%)  ???:llvm::BranchProbabilityInfo::SccInfo::SccInfo(llvm::Function const&)
 33,365,782 ( 0.11%)  ???:llvm::ConstantInt::get(llvm::IntegerType*, unsigned long, bool)
 32,741,219 ( 0.11%)  ???:llvm::Value::~Value()
 32,606,133 ( 0.11%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::MachineBasicBlock, false> >::runSemiNCA(llvm::DominatorTreeBase<llvm::MachineBasicBlock, false>&, unsigned int)
 32,474,518 ( 0.11%)  ???:llvm::GEPOperator::accumulateConstantOffset(llvm::DataLayout const&, llvm::APInt&, llvm::function_ref<bool (llvm::Value&, llvm::APInt&)>) const
 32,336,345 ( 0.11%)  ???:llvm::ScalarEvolution::getMulExpr(llvm::SmallVectorImpl<llvm::SCEV const*>&, llvm::SCEV::NoWrapFlags, unsigned int)
 32,154,814 ( 0.11%)  ???:llvm::BranchProbabilityInfo::calculate(llvm::Function const&, llvm::LoopInfo const&, llvm::TargetLibraryInfo const*, llvm::DominatorTree*, llvm::PostDominatorTree*)
 32,001,704 ( 0.10%)  ???:llvm::Value::setName(llvm::Twine const&)
 31,996,945 ( 0.10%)  ???:llvm::FoldBranchToCommonDest(llvm::BranchInst*, llvm::DomTreeUpdater*, llvm::MemorySSAUpdater*, llvm::TargetTransformInfo const*, unsigned int)
 31,957,181 ( 0.10%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::MachineBasicBlock, false> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::MachineBasicBlock, false>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::MachineBasicBlock, false> >::BatchUpdateInfo*)
 31,564,007 ( 0.10%)  ???:(anonymous namespace)::CallAnalyzer::analyze()
 31,360,449 ( 0.10%)  ???:llvm::SelectionDAG::computeKnownBits(llvm::SDValue, llvm::APInt const&, unsigned int) const
 31,342,115 ( 0.10%)  ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2
 30,725,443 ( 0.10%)  ???:llvm::Value::stripPointerCasts() const

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs
--------------------------------------------------------------------------------
Ir                   

-- line 111 ----------------------------------------
          .           const EMPTY: u8 = 0b1111_1111;
          .           
          .           /// Control byte value for a deleted bucket.
          .           const DELETED: u8 = 0b1000_0000;
          .           
          .           /// Checks whether a control byte represents a full bucket (top bit is clear).
          .           #[inline]
          .           fn is_full(ctrl: u8) -> bool {
  5,227,099 ( 0.02%)      ctrl & 0x80 == 0
          .           }
          .           
          .           /// Checks whether a control byte represents a special value (top bit is set).
          .           #[inline]
          .           fn is_special(ctrl: u8) -> bool {
          .               ctrl & 0x80 != 0
          .           }
          .           
          .           /// Checks whether a special control value is EMPTY (just check 1 bit).
          .           #[inline]
          .           fn special_is_empty(ctrl: u8) -> bool {
          .               debug_assert!(is_special(ctrl));
    336,882 ( 0.00%)      ctrl & 0x01 != 0
          .           }
          .           
          .           /// Primary hash function, used to select the initial bucket to probe from.
          .           #[inline]
          .           #[allow(clippy::cast_possible_truncation)]
          .           fn h1(hash: u64) -> usize {
          .               // On 32-bit platforms we simply ignore the higher hash bits.
          .               hash as usize
-- line 140 ----------------------------------------
-- line 143 ----------------------------------------
          .           /// Secondary hash function, saved in the low 7 bits of the control byte.
          .           #[inline]
          .           #[allow(clippy::cast_possible_truncation)]
          .           fn h2(hash: u64) -> u8 {
          .               // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
          .               // value, some hash functions (such as FxHash) produce a usize result
          .               // instead, which means that the top 32 bits are 0 on 32-bit platforms.
          .               let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
101,071,280 ( 0.33%)      let top7 = hash >> (hash_len * 8 - 7);
          .               (top7 & 0x7f) as u8 // truncation
          .           }
          .           
          .           /// Probe sequence based on triangular numbers, which is guaranteed (since our
          .           /// table size is a power of two) to visit every group of elements exactly once.
          .           ///
          .           /// A triangular probe has us jump by 1 more group every time. So first we
          .           /// jump by 1 group (meaning we just continue our linear scan), then 2 groups
-- line 159 ----------------------------------------
-- line 170 ----------------------------------------
          .               #[inline]
          .               fn move_next(&mut self, bucket_mask: usize) {
          .                   // We should have found an empty bucket by now and ended the probe.
          .                   debug_assert!(
          .                       self.stride <= bucket_mask,
          .                       "Went past end of probe sequence"
          .                   );
          .           
    738,084 ( 0.00%)          self.stride += Group::WIDTH;
    738,084 ( 0.00%)          self.pos += self.stride;
    621,390 ( 0.00%)          self.pos &= bucket_mask;
          .               }
          .           }
          .           
          .           /// Returns the number of buckets needed to hold the given number of items,
          .           /// taking the maximum load factor into account.
          .           ///
          .           /// Returns `None` if an overflow occurs.
          .           // Workaround for emscripten bug emscripten-core/emscripten-fastcomp#258
          .           #[cfg_attr(target_os = "emscripten", inline(never))]
          .           #[cfg_attr(not(target_os = "emscripten"), inline)]
          .           fn capacity_to_buckets(cap: usize) -> Option<usize> {
          .               debug_assert_ne!(cap, 0);
          .           
          .               // For small tables we require at least 1 empty bucket so that lookups are
          .               // guaranteed to terminate if an element doesn't exist in the table.
    339,596 ( 0.00%)      if cap < 8 {
          .                   // We don't bother with a table size of 2 buckets since that can only
          .                   // hold a single element. Instead we skip directly to a 4 bucket table
          .                   // which can hold 3 elements.
    740,180 ( 0.00%)          return Some(if cap < 4 { 4 } else { 8 });
          .               }
          .           
          .               // Otherwise require 1/8 buckets to be empty (87.5% load)
          .               //
          .               // Be careful when modifying this, calculate_layout relies on the
          .               // overflow check here.
    130,572 ( 0.00%)      let adjusted_cap = cap.checked_mul(8)? / 7;
          .           
          .               // Any overflows will have been caught by the checked_mul. Also, any
          .               // rounding errors from the division above will be cleaned up by
          .               // next_power_of_two (which can't overflow because of the previous division).
          .               Some(adjusted_cap.next_power_of_two())
          .           }
          .           
          .           /// Returns the maximum effective capacity for the given bucket mask, taking
          .           /// the maximum load factor into account.
          .           #[inline]
          .           fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
    943,929 ( 0.00%)      if bucket_mask < 8 {
          .                   // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
          .                   // Keep in mind that the bucket mask is one less than the bucket count.
          .                   bucket_mask
          .               } else {
          .                   // For larger tables we reserve 12.5% of the slots as empty.
    218,526 ( 0.00%)          ((bucket_mask + 1) / 8) * 7
          .               }
          .           }
          .           
          .           /// Helper which allows the max calculation for ctrl_align to be statically computed for each T
          .           /// while keeping the rest of `calculate_layout_for` independent of `T`
          .           #[derive(Copy, Clone)]
          .           struct TableLayout {
          .               size: usize,
-- line 233 ----------------------------------------
-- line 246 ----------------------------------------
          .           
          .               #[inline]
          .               fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
          .                   debug_assert!(buckets.is_power_of_two());
          .           
          .                   let TableLayout { size, ctrl_align } = self;
          .                   // Manual layout calculation since Layout methods are not yet stable.
          .                   let ctrl_offset =
    680,199 ( 0.00%)              size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
    918,747 ( 0.00%)          let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
          .           
          .                   Some((
          .                       unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
          .                       ctrl_offset,
          .                   ))
          .               }
          .           }
          .           
-- line 263 ----------------------------------------
-- line 337 ----------------------------------------
          .                   }
          .               }
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub unsafe fn drop(&self) {
          .                   self.as_ptr().drop_in_place();
          .               }
          .               #[inline]
          .               pub unsafe fn read(&self) -> T {
      4,986 ( 0.00%)          self.as_ptr().read()
          .               }
          .               #[inline]
          .               pub unsafe fn write(&self, val: T) {
          .                   self.as_ptr().write(val);
          .               }
          .               #[inline]
          .               pub unsafe fn as_ref<'a>(&self) -> &'a T {
          .                   &*self.as_ptr()
-- line 353 ----------------------------------------
-- line 422 ----------------------------------------
          .               /// Creates a new empty hash table without allocating any memory, using the
          .               /// given allocator.
          .               ///
          .               /// In effect this returns a table with exactly 1 bucket. However we can
          .               /// leave the data pointer dangling since that bucket is never written to
          .               /// due to our load factor forcing us to always have at least 1 free bucket.
          .               #[inline]
          .               pub fn new_in(alloc: A) -> Self {
      4,350 ( 0.00%)          Self {
          .                       table: RawTableInner::new_in(alloc),
          .                       marker: PhantomData,
          .                   }
          .               }
          .           
          .               /// Allocates a new hash table with the given number of buckets.
          .               ///
          .               /// The control bytes are left uninitialized.
-- line 438 ----------------------------------------
-- line 440 ----------------------------------------
          .               unsafe fn new_uninitialized(
          .                   alloc: A,
          .                   buckets: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
          .                   debug_assert!(buckets.is_power_of_two());
          .           
          .                   Ok(Self {
        235 ( 0.00%)              table: RawTableInner::new_uninitialized(
          .                           alloc,
          .                           TableLayout::new::<T>(),
          .                           buckets,
          .                           fallibility,
          .                       )?,
          .                       marker: PhantomData,
          .                   })
          .               }
-- line 456 ----------------------------------------
-- line 458 ----------------------------------------
          .               /// Attempts to allocate a new hash table with at least enough capacity
          .               /// for inserting the given number of elements without reallocating.
          .               fn fallible_with_capacity(
          .                   alloc: A,
          .                   capacity: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
          .                   Ok(Self {
     20,202 ( 0.00%)              table: RawTableInner::fallible_with_capacity(
          .                           alloc,
          .                           TableLayout::new::<T>(),
          .                           capacity,
          .                           fallibility,
          .                       )?,
          .                       marker: PhantomData,
          .                   })
          .               }
-- line 474 ----------------------------------------
-- line 527 ----------------------------------------
          .                   debug_assert_ne!(self.table.bucket_mask, 0);
          .                   debug_assert!(index < self.buckets());
          .                   Bucket::from_base_index(self.data_end(), index)
          .               }
          .           
          .               /// Erases an element from the table without dropping it.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[deprecated(since = "0.8.1", note = "use erase or remove instead")]
     68,517 ( 0.00%)      pub unsafe fn erase_no_drop(&mut self, item: &Bucket<T>) {
     68,517 ( 0.00%)          let index = self.bucket_index(item);
          .                   self.table.erase(index);
    137,034 ( 0.00%)      }
          .           
          .               /// Erases an element from the table, dropping it in place.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[allow(clippy::needless_pass_by_value)]
          .               #[allow(deprecated)]
          .               pub unsafe fn erase(&mut self, item: Bucket<T>) {
          .                   // Erase the element from the table first since drop might panic.
     44,348 ( 0.00%)          self.erase_no_drop(&item);
          .                   item.drop();
          .               }
          .           
          .               /// Finds and erases an element from the table, dropping it in place.
          .               /// Returns true if an element was found.
          .               #[cfg(feature = "raw")]
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn erase_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> bool {
-- line 554 ----------------------------------------
-- line 563 ----------------------------------------
          .                   }
          .               }
          .           
          .               /// Removes an element from the table, returning it.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[allow(clippy::needless_pass_by_value)]
          .               #[allow(deprecated)]
          .               pub unsafe fn remove(&mut self, item: Bucket<T>) -> T {
     92,686 ( 0.00%)          self.erase_no_drop(&item);
        388 ( 0.00%)          item.read()
          .               }
          .           
          .               /// Finds and removes an element from the table, returning it.
          .               #[cfg_attr(feature = "inline-more", inline)]
  1,860,353 ( 0.01%)      pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T> {
          .                   // Avoid `Option::map` because it bloats LLVM IR.
      4,964 ( 0.00%)          match self.find(hash, eq) {
     30,716 ( 0.00%)              Some(bucket) => Some(unsafe { self.remove(bucket) }),
    426,171 ( 0.00%)              None => None,
          .                   }
  2,513,397 ( 0.01%)      }
          .           
          .               /// Marks all table buckets as empty without dropping their contents.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn clear_no_drop(&mut self) {
          .                   self.table.clear_no_drop();
          .               }
          .           
          .               /// Removes all elements from the table without freeing the backing memory.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn clear(&mut self) {
          .                   // Ensure that the table is reset even if one of the drops panic
          .                   let mut self_ = guard(self, |self_| self_.clear_no_drop());
          .                   unsafe {
          1 ( 0.00%)              self_.drop_elements();
          .                   }
          .               }
          .           
          7 ( 0.00%)      unsafe fn drop_elements(&mut self) {
     35,138 ( 0.00%)          if mem::needs_drop::<T>() && !self.is_empty() {
          .                       for item in self.iter() {
          .                           item.drop();
          .                       }
          .                   }
          8 ( 0.00%)      }
          .           
          .               /// Shrinks the table to fit `max(self.len(), min_size)` elements.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn shrink_to(&mut self, min_size: usize, hasher: impl Fn(&T) -> u64) {
          .                   // Calculate the minimal number of elements that we need to reserve
          .                   // space for.
          .                   let min_size = usize::max(self.table.items, min_size);
          .                   if min_size == 0 {
-- line 615 ----------------------------------------
-- line 642 ----------------------------------------
          .                       }
          .                   }
          .               }
          .           
          .               /// Ensures that at least `additional` items can be inserted into the table
          .               /// without reallocation.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
    954,508 ( 0.00%)          if additional > self.table.growth_left {
          .                       // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
    600,567 ( 0.00%)              if self
          .                           .reserve_rehash(additional, hasher, Fallibility::Infallible)
          .                           .is_err()
          .                       {
          .                           unsafe { hint::unreachable_unchecked() }
          .                       }
          .                   }
          .               }
          .           
-- line 660 ----------------------------------------
-- line 671 ----------------------------------------
          .                   } else {
          .                       Ok(())
          .                   }
          .               }
          .           
          .               /// Out-of-line slow path for `reserve` and `try_reserve`.
          .               #[cold]
          .               #[inline(never)]
  1,357,554 ( 0.00%)      fn reserve_rehash(
          .                   &mut self,
          .                   additional: usize,
          .                   hasher: impl Fn(&T) -> u64,
          .                   fallibility: Fallibility,
          .               ) -> Result<(), TryReserveError> {
          .                   unsafe {
          .                       self.table.reserve_rehash_inner(
          .                           additional,
-- line 687 ----------------------------------------
-- line 690 ----------------------------------------
          .                           TableLayout::new::<T>(),
          .                           if mem::needs_drop::<T>() {
          .                               Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
          .                           } else {
          .                               None
          .                           },
          .                       )
          .                   }
  1,013,728 ( 0.00%)      }
          .           
          .               /// Allocates a new table of a different size and moves the contents of the
          .               /// current table into it.
          .               fn resize(
          .                   &mut self,
          .                   capacity: usize,
          .                   hasher: impl Fn(&T) -> u64,
          .                   fallibility: Fallibility,
-- line 706 ----------------------------------------
-- line 714 ----------------------------------------
          .                       )
          .                   }
          .               }
          .           
          .               /// Inserts a new element into the table, and returns its raw bucket.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg_attr(feature = "inline-more", inline)]
  6,483,336 ( 0.02%)      pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
          .                   unsafe {
          .                       let mut index = self.table.find_insert_slot(hash);
          .           
          .                       // We can avoid growing the table once we have reached our load
          .                       // factor if we are replacing a tombstone. This works since the
          .                       // number of EMPTY slots does not change in this case.
     13,406 ( 0.00%)              let old_ctrl = *self.table.ctrl(index);
  4,951,288 ( 0.02%)              if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
          .                           self.reserve(1, hasher);
          .                           index = self.table.find_insert_slot(hash);
          .                       }
          .           
          .                       self.table.record_item_insert_at(index, old_ctrl, hash);
          .           
          .                       let bucket = self.bucket(index);
          4 ( 0.00%)              bucket.write(value);
          .                       bucket
          .                   }
  4,780,194 ( 0.02%)      }
          .           
          .               /// Attempts to insert a new element without growing the table and return its raw bucket.
          .               ///
          .               /// Returns an `Err` containing the given element if inserting it would require growing the
          .               /// table.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg(feature = "raw")]
-- line 749 ----------------------------------------
-- line 760 ----------------------------------------
          .                       }
          .                   }
          .               }
          .           
          .               /// Inserts a new element into the table, and returns a mutable reference to it.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg_attr(feature = "inline-more", inline)]
  2,331,936 ( 0.01%)      pub fn insert_entry(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> &mut T {
        500 ( 0.00%)          unsafe { self.insert(hash, value, hasher).as_mut() }
  1,748,952 ( 0.01%)      }
          .           
          .               /// Inserts a new element into the table, without growing the table.
          .               ///
          .               /// There must be enough space in the table to insert the new element.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[cfg(any(feature = "raw", feature = "rustc-internal-api"))]
     15,473 ( 0.00%)      pub unsafe fn insert_no_grow(&mut self, hash: u64, value: T) -> Bucket<T> {
    904,068 ( 0.00%)          let (index, old_ctrl) = self.table.prepare_insert_slot(hash);
     38,979 ( 0.00%)          let bucket = self.table.bucket(index);
          .           
          .                   // If we are replacing a DELETED entry then we don't need to update
          .                   // the load counter.
  1,942,842 ( 0.01%)          self.table.growth_left -= special_is_empty(old_ctrl) as usize;
          .           
          .                   bucket.write(value);
  1,538,080 ( 0.01%)          self.table.items += 1;
          .                   bucket
     30,900 ( 0.00%)      }
          .           
          .               /// Temporary removes a bucket, applying the given function to the removed
          .               /// element and optionally put back the returned value in the same bucket.
          .               ///
          .               /// Returns `true` if the bucket still contains an element
          .               ///
          .               /// This does not check if the given bucket is actually occupied.
          .               #[cfg_attr(feature = "inline-more", inline)]
-- line 798 ----------------------------------------
-- line 813 ----------------------------------------
          .                       true
          .                   } else {
          .                       false
          .                   }
          .               }
          .           
          .               /// Searches for an element in the table.
          .               #[inline]
    182,176 ( 0.00%)      pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
     28,400 ( 0.00%)          let result = self.table.find_inner(hash, &mut |index| unsafe {
     58,585 ( 0.00%)              eq(self.bucket(index).as_ref())
      9,904 ( 0.00%)          });
          .           
          .                   // Avoid `Option::map` because it bloats LLVM IR.
          .                   match result {
      3,477 ( 0.00%)              Some(index) => Some(unsafe { self.bucket(index) }),
          .                       None => None,
          .                   }
    207,144 ( 0.00%)      }
          .           
          .               /// Gets a reference to an element in the table.
          .               #[inline]
          .               pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
          .                   // Avoid `Option::map` because it bloats LLVM IR.
     80,357 ( 0.00%)          match self.find(hash, eq) {
          .                       Some(bucket) => Some(unsafe { bucket.as_ref() }),
          .                       None => None,
          .                   }
          .               }
          .           
          .               /// Gets a mutable reference to an element in the table.
          .               #[inline]
     11,501 ( 0.00%)      pub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {
          .                   // Avoid `Option::map` because it bloats LLVM IR.
     85,503 ( 0.00%)          match self.find(hash, eq) {
          .                       Some(bucket) => Some(unsafe { bucket.as_mut() }),
          .                       None => None,
          .                   }
     13,144 ( 0.00%)      }
          .           
          .               /// Attempts to get mutable references to `N` entries in the table at once.
          .               ///
          .               /// Returns an array of length `N` with the results of each query.
          .               ///
          .               /// At most one mutable reference will be returned to any entry. `None` will be returned if any
          .               /// of the hashes are duplicates. `None` will be returned if the hash is not found.
          .               ///
-- line 859 ----------------------------------------
-- line 920 ----------------------------------------
          .               #[inline]
          .               pub fn len(&self) -> usize {
          .                   self.table.items
          .               }
          .           
          .               /// Returns `true` if the table contains no elements.
          .               #[inline]
          .               pub fn is_empty(&self) -> bool {
  2,746,269 ( 0.01%)          self.len() == 0
          .               }
          .           
          .               /// Returns the number of buckets in the table.
          .               #[inline]
          .               pub fn buckets(&self) -> usize {
          .                   self.table.bucket_mask + 1
          .               }
          .           
          .               /// Returns an iterator over every element in the table. It is up to
          .               /// the caller to ensure that the `RawTable` outlives the `RawIter`.
          .               /// Because we cannot make the `next` method unsafe on the `RawIter`
          .               /// struct, we have to make the `iter` method unsafe.
          .               #[inline]
          .               pub unsafe fn iter(&self) -> RawIter<T> {
          5 ( 0.00%)          let data = Bucket::from_base_index(self.data_end(), 0);
          .                   RawIter {
          .                       iter: RawIterRange::new(self.table.ctrl.as_ptr(), data, self.table.buckets()),
    334,993 ( 0.00%)              items: self.table.items,
          .                   }
          .               }
          .           
          .               /// Returns an iterator over occupied buckets that could match a given hash.
          .               ///
          .               /// `RawTable` only stores 7 bits of the hash value, so this iterator may
          .               /// return items that have a hash value different than the one provided. You
          .               /// should always validate the returned values before using them.
-- line 954 ----------------------------------------
-- line 995 ----------------------------------------
          .               /// Iteration starts at the provided iterator's current location.
          .               ///
          .               /// It is up to the caller to ensure that the iterator is valid for this
          .               /// `RawTable` and covers all items that remain in the table.
          .               pub unsafe fn into_iter_from(self, iter: RawIter<T>) -> RawIntoIter<T, A> {
          .                   debug_assert_eq!(iter.len(), self.len());
          .           
          .                   let alloc = self.table.alloc.clone();
     17,820 ( 0.00%)          let allocation = self.into_allocation();
     13,365 ( 0.00%)          RawIntoIter {
     22,275 ( 0.00%)              iter,
          .                       allocation,
          .                       marker: PhantomData,
          .                       alloc,
          .                   }
          .               }
          .           
          .               /// Converts the table into a raw allocation. The contents of the table
          .               /// should be dropped using a `RawIter` before freeing the allocation.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout)> {
      8,332 ( 0.00%)          let alloc = if self.table.is_empty_singleton() {
          .                       None
          .                   } else {
          .                       // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
          .                       let (layout, ctrl_offset) = match calculate_layout::<T>(self.table.buckets()) {
          .                           Some(lco) => lco,
          .                           None => unsafe { hint::unreachable_unchecked() },
          .                       };
          .                       Some((
      1,029 ( 0.00%)                  unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().sub(ctrl_offset)) },
          .                           layout,
          .                       ))
          .                   };
          .                   mem::forget(self);
          .                   alloc
          .               }
          .           }
          .           
-- line 1033 ----------------------------------------
-- line 1042 ----------------------------------------
          .               T: Sync,
          .               A: Sync,
          .           {
          .           }
          .           
          .           impl<A> RawTableInner<A> {
          .               #[inline]
          .               const fn new_in(alloc: A) -> Self {
  2,037,804 ( 0.01%)          Self {
          .                       // Be careful to cast the entire slice to a raw pointer.
          .                       ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
          .                       bucket_mask: 0,
          .                       items: 0,
          .                       growth_left: 0,
          .                       alloc,
          .                   }
          .               }
          .           }
          .           
          .           impl<A: Allocator + Clone> RawTableInner<A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
  1,196,648 ( 0.00%)      unsafe fn new_uninitialized(
          .                   alloc: A,
          .                   table_layout: TableLayout,
          .                   buckets: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
          .                   debug_assert!(buckets.is_power_of_two());
          .           
          .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
-- line 1071 ----------------------------------------
-- line 1078 ----------------------------------------
          .                   // exceed `isize::MAX`. We can skip this check on 64-bit systems since
          .                   // such allocations will never succeed anyways.
          .                   //
          .                   // This mirrors what Vec does in the standard library.
          .                   if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
          .                       return Err(fallibility.capacity_overflow());
          .                   }
          .           
    283,530 ( 0.00%)          let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
          .                       Ok(block) => block.cast(),
          .                       Err(_) => return Err(fallibility.alloc_err(layout)),
          .                   };
          .           
          .                   let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
    658,554 ( 0.00%)          Ok(Self {
          .                       ctrl,
    279,604 ( 0.00%)              bucket_mask: buckets - 1,
          .                       items: 0,
          .                       growth_left: bucket_mask_to_capacity(buckets - 1),
          .                       alloc,
          .                   })
    870,938 ( 0.00%)      }
          .           
          .               #[inline]
     80,738 ( 0.00%)      fn fallible_with_capacity(
          .                   alloc: A,
          .                   table_layout: TableLayout,
          .                   capacity: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
     20,918 ( 0.00%)          if capacity == 0 {
      9,657 ( 0.00%)              Ok(Self::new_in(alloc))
          .                   } else {
          .                       unsafe {
          .                           let buckets =
          .                               capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
          .           
    542,124 ( 0.00%)                  let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
          .                           result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
          .           
     49,993 ( 0.00%)                  Ok(result)
          .                       }
          .                   }
     80,738 ( 0.00%)      }
          .           
          .               /// Searches for an empty or deleted bucket which is suitable for inserting
          .               /// a new element and sets the hash for that slot.
          .               ///
          .               /// There must be at least 1 empty bucket in the table.
          .               #[inline]
    321,446 ( 0.00%)      unsafe fn prepare_insert_slot(&self, hash: u64) -> (usize, u8) {
          .                   let index = self.find_insert_slot(hash);
    321,446 ( 0.00%)          let old_ctrl = *self.ctrl(index);
          .                   self.set_ctrl_h2(index, hash);
          .                   (index, old_ctrl)
    642,892 ( 0.00%)      }
          .           
          .               /// Searches for an empty or deleted bucket which is suitable for inserting
          .               /// a new element.
          .               ///
          .               /// There must be at least 1 empty bucket in the table.
          .               #[inline]
          .               fn find_insert_slot(&self, hash: u64) -> usize {
          .                   let mut probe_seq = self.probe_seq(hash);
          .                   loop {
          .                       unsafe {
          .                           let group = Group::load(self.ctrl(probe_seq.pos));
  3,368,948 ( 0.01%)                  if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
  9,814,037 ( 0.03%)                      let result = (probe_seq.pos + bit) & self.bucket_mask;
          .           
          .                               // In tables smaller than the group width, trailing control
          .                               // bytes outside the range of the table are filled with
          .                               // EMPTY entries. These will unfortunately trigger a
          .                               // match, but once masked may point to a full bucket that
          .                               // is already occupied. We detect this situation here and
          .                               // perform a second scan starting at the beginning of the
          .                               // table. This second scan is guaranteed to find an empty
          .                               // slot (due to the load factor) before hitting the trailing
          .                               // control bytes (containing EMPTY).
  4,507,414 ( 0.01%)                      if unlikely(is_full(*self.ctrl(result))) {
          .                                   debug_assert!(self.bucket_mask < Group::WIDTH);
          .                                   debug_assert_ne!(probe_seq.pos, 0);
          .                                   return Group::load_aligned(self.ctrl(0))
          .                                       .match_empty_or_deleted()
          .                                       .lowest_set_bit_nonzero();
          .                               }
          .           
          .                               return result;
-- line 1165 ----------------------------------------
-- line 1171 ----------------------------------------
          .           
          .               /// Searches for an element in the table. This uses dynamic dispatch to reduce the amount of
          .               /// code generated, but it is eliminated by LLVM optimizations.
          .               #[inline]
          .               fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
          .                   let h2_hash = h2(hash);
          .                   let mut probe_seq = self.probe_seq(hash);
          .           
    289,692 ( 0.00%)          loop {
          .                       let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
          .           
 11,029,294 ( 0.04%)              for bit in group.match_byte(h2_hash) {
 21,348,867 ( 0.07%)                  let index = (probe_seq.pos + bit) & self.bucket_mask;
          .           
 15,112,220 ( 0.05%)                  if likely(eq(index)) {
          .                               return Some(index);
          .                           }
          .                       }
          .           
  3,320,684 ( 0.01%)              if likely(group.match_empty().any_bit_set()) {
          .                           return None;
          .                       }
          .           
          .                       probe_seq.move_next(self.bucket_mask);
          .                   }
          .               }
          .           
          .               #[allow(clippy::mut_mut)]
          .               #[inline]
          .               unsafe fn prepare_rehash_in_place(&mut self) {
          .                   // Bulk convert all full control bytes to DELETED, and all DELETED
          .                   // control bytes to EMPTY. This effectively frees up all buckets
          .                   // containing a DELETED entry.
          6 ( 0.00%)          for i in (0..self.buckets()).step_by(Group::WIDTH) {
          .                       let group = Group::load_aligned(self.ctrl(i));
          .                       let group = group.convert_special_to_empty_and_full_to_deleted();
          .                       group.store_aligned(self.ctrl(i));
          .                   }
          .           
          .                   // Fix up the trailing control bytes. See the comments in set_ctrl
          .                   // for the handling of tables smaller than the group width.
          6 ( 0.00%)          if self.buckets() < Group::WIDTH {
          .                       self.ctrl(0)
          .                           .copy_to(self.ctrl(Group::WIDTH), self.buckets());
          .                   } else {
          .                       self.ctrl(0)
          .                           .copy_to(self.ctrl(self.buckets()), Group::WIDTH);
          .                   }
          .               }
          .           
-- line 1220 ----------------------------------------
-- line 1225 ----------------------------------------
          .                   Bucket::from_base_index(self.data_end(), index)
          .               }
          .           
          .               #[inline]
          .               unsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8 {
          .                   debug_assert_ne!(self.bucket_mask, 0);
          .                   debug_assert!(index < self.buckets());
          .                   let base: *mut u8 = self.data_end().as_ptr();
 12,731,776 ( 0.04%)          base.sub((index + 1) * size_of)
          .               }
          .           
          .               #[inline]
          .               unsafe fn data_end<T>(&self) -> NonNull<T> {
          .                   NonNull::new_unchecked(self.ctrl.as_ptr().cast())
          .               }
          .           
          .               /// Returns an iterator-like object for a probe sequence on the table.
          .               ///
          .               /// This iterator never terminates, but is guaranteed to visit each bucket
          .               /// group exactly once. The loop using `probe_seq` must terminate upon
          .               /// reaching a group containing an empty bucket.
          .               #[inline]
          .               fn probe_seq(&self, hash: u64) -> ProbeSeq {
          .                   ProbeSeq {
 60,060,427 ( 0.20%)              pos: h1(hash) & self.bucket_mask,
          .                       stride: 0,
          .                   }
          .               }
          .           
          .               /// Returns the index of a bucket for which a value must be inserted if there is enough rooom
          .               /// in the table, otherwise returns error
          .               #[cfg(feature = "raw")]
          .               #[inline]
-- line 1257 ----------------------------------------
-- line 1263 ----------------------------------------
          .                   } else {
          .                       self.record_item_insert_at(index, old_ctrl, hash);
          .                       Ok(index)
          .                   }
          .               }
          .           
          .               #[inline]
          .               unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
  6,185,873 ( 0.02%)          self.growth_left -= special_is_empty(old_ctrl) as usize;
          .                   self.set_ctrl_h2(index, hash);
  4,948,656 ( 0.02%)          self.items += 1;
          .               }
          .           
          .               #[inline]
          .               fn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool {
          .                   let probe_seq_pos = self.probe_seq(hash).pos;
          .                   let probe_index =
          .                       |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;
         48 ( 0.00%)          probe_index(i) == probe_index(new_i)
          .               }
          .           
          .               /// Sets a control byte to the hash, and possibly also the replicated control byte at
          .               /// the end of the array.
          .               #[inline]
          .               unsafe fn set_ctrl_h2(&self, index: usize, hash: u64) {
          .                   self.set_ctrl(index, h2(hash));
          .               }
-- line 1289 ----------------------------------------
-- line 1312 ----------------------------------------
          .                   // replicate the buckets at the end of the trailing group. For example
          .                   // with 2 buckets and a group size of 4, the control bytes will look
          .                   // like this:
          .                   //
          .                   //     Real    |             Replicated
          .                   // ---------------------------------------------
          .                   // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
          .                   // ---------------------------------------------
  9,502,318 ( 0.03%)          let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
          .           
  3,165,518 ( 0.01%)          *self.ctrl(index) = ctrl;
  3,166,438 ( 0.01%)          *self.ctrl(index2) = ctrl;
          .               }
          .           
          .               /// Returns a pointer to a control byte.
          .               #[inline]
          .               unsafe fn ctrl(&self, index: usize) -> *mut u8 {
          .                   debug_assert!(index < self.num_ctrl_bytes());
          .                   self.ctrl.as_ptr().add(index)
          .               }
          .           
          .               #[inline]
          .               fn buckets(&self) -> usize {
    940,789 ( 0.00%)          self.bucket_mask + 1
          .               }
          .           
          .               #[inline]
          .               fn num_ctrl_bytes(&self) -> usize {
    781,009 ( 0.00%)          self.bucket_mask + 1 + Group::WIDTH
          .               }
          .           
          .               #[inline]
          .               fn is_empty_singleton(&self) -> bool {
  3,689,193 ( 0.01%)          self.bucket_mask == 0
          .               }
          .           
          .               #[allow(clippy::mut_mut)]
          .               #[inline]
          .               unsafe fn prepare_resize(
          .                   &self,
          .                   table_layout: TableLayout,
          .                   capacity: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
          .                   debug_assert!(self.items <= capacity);
          .           
          .                   // Allocate and initialize the new table.
     15,492 ( 0.00%)          let mut new_table = RawTableInner::fallible_with_capacity(
          .                       self.alloc.clone(),
          .                       table_layout,
          .                       capacity,
          .                       fallibility,
          .                   )?;
    377,704 ( 0.00%)          new_table.growth_left -= self.items;
          .                   new_table.items = self.items;
          .           
          .                   // The hash function may panic, in which case we simply free the new
          .                   // table without dropping any elements that may have been copied into
          .                   // it.
          .                   //
          .                   // This guard is also used to free the old table on success, see
          .                   // the comment at the bottom of this function.
          .                   Ok(guard(new_table, move |self_| {
    166,629 ( 0.00%)              if !self_.is_empty_singleton() {
          .                           self_.free_buckets(table_layout);
          .                       }
          .                   }))
          .               }
          .           
          .               /// Reserves or rehashes to make room for `additional` more elements.
          .               ///
          .               /// This uses dynamic dispatch to reduce the amount of
-- line 1383 ----------------------------------------
-- line 1388 ----------------------------------------
          .                   &mut self,
          .                   additional: usize,
          .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
          .                   fallibility: Fallibility,
          .                   layout: TableLayout,
          .                   drop: Option<fn(*mut u8)>,
          .               ) -> Result<(), TryReserveError> {
          .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
    333,265 ( 0.00%)          let new_items = match self.items.checked_add(additional) {
          .                       Some(new_items) => new_items,
          .                       None => return Err(fallibility.capacity_overflow()),
          .                   };
    333,262 ( 0.00%)          let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
    711,399 ( 0.00%)          if new_items <= full_capacity / 2 {
          .                       // Rehash in-place without re-allocating if we have plenty of spare
          .                       // capacity that is locked up due to DELETED entries.
          .                       self.rehash_in_place(hasher, layout.size, drop);
          4 ( 0.00%)              Ok(())
          .                   } else {
          .                       // Otherwise, conservatively resize to at least the next size up
          .                       // to avoid churning deletes into frequent rehashes.
          .                       self.resize_inner(
    166,629 ( 0.00%)                  usize::max(new_items, full_capacity + 1),
          .                           hasher,
          .                           fallibility,
          .                           layout,
          .                       )
          .                   }
          .               }
          .           
          .               /// Allocates a new table of a different size and moves the contents of the
-- line 1418 ----------------------------------------
-- line 1424 ----------------------------------------
          .               #[inline(always)]
          .               unsafe fn resize_inner(
          .                   &mut self,
          .                   capacity: usize,
          .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
          .                   fallibility: Fallibility,
          .                   layout: TableLayout,
          .               ) -> Result<(), TryReserveError> {
     38,930 ( 0.00%)          let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
          .           
          .                   // Copy all elements to the new table.
          .                   for i in 0..self.buckets() {
  1,956,849 ( 0.01%)              if !is_full(*self.ctrl(i)) {
          .                           continue;
          .                       }
          .           
          .                       // This may panic.
          .                       let hash = hasher(self, i);
          .           
          .                       // We can use a simpler version of insert() here since:
          .                       // - there are no DELETED entries.
-- line 1444 ----------------------------------------
-- line 1454 ----------------------------------------
          .                   }
          .           
          .                   // We successfully copied all elements without panicking. Now replace
          .                   // self with the new table. The old table will have its memory freed but
          .                   // the items will not be dropped (since they have been moved into the
          .                   // new table).
          .                   mem::swap(self, &mut new_table);
          .           
    166,629 ( 0.00%)          Ok(())
          .               }
          .           
          .               /// Rehashes the contents of the table in place (i.e. without changing the
          .               /// allocation).
          .               ///
          .               /// If `hasher` panics then some the table's contents may be lost.
          .               ///
          .               /// This uses dynamic dispatch to reduce the amount of
-- line 1470 ----------------------------------------
-- line 1496 ----------------------------------------
          .                       }
          .                       self_.growth_left = bucket_mask_to_capacity(self_.bucket_mask) - self_.items;
          .                   });
          .           
          .                   // At this point, DELETED elements are elements that we haven't
          .                   // rehashed yet. Find them and re-insert them at their ideal
          .                   // position.
          .                   'outer: for i in 0..guard.buckets() {
        128 ( 0.00%)              if *guard.ctrl(i) != DELETED {
          .                           continue;
          .                       }
          .           
          .                       let i_p = guard.bucket_ptr(i, size_of);
          .           
          .                       'inner: loop {
          .                           // Hash the current item
          .                           let hash = hasher(*guard, i);
-- line 1512 ----------------------------------------
-- line 1515 ----------------------------------------
          .                           let new_i = guard.find_insert_slot(hash);
          .                           let new_i_p = guard.bucket_ptr(new_i, size_of);
          .           
          .                           // Probing works by scanning through all of the control
          .                           // bytes in groups, which may not be aligned to the group
          .                           // size. If both the new and old position fall within the
          .                           // same unaligned group, then there is no benefit in moving
          .                           // it and we can just continue to the next item.
         16 ( 0.00%)                  if likely(guard.is_in_same_group(i, new_i, hash)) {
          .                               guard.set_ctrl_h2(i, hash);
          .                               continue 'outer;
          .                           }
          .           
          .                           // We are moving the current item to a new position. Write
          .                           // our H2 to the control byte of the new position.
          .                           let prev_ctrl = guard.replace_ctrl_h2(new_i, hash);
          .                           if prev_ctrl == EMPTY {
-- line 1531 ----------------------------------------
-- line 1541 ----------------------------------------
          .                               // swapped into the old slot.
          .                               debug_assert_eq!(prev_ctrl, DELETED);
          .                               ptr::swap_nonoverlapping(i_p, new_i_p, size_of);
          .                               continue 'inner;
          .                           }
          .                       }
          .                   }
          .           
          6 ( 0.00%)          guard.growth_left = bucket_mask_to_capacity(guard.bucket_mask) - guard.items;
          .           
          .                   mem::forget(guard);
          .               }
          .           
          .               #[inline]
          .               unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
          .                   // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
          .                   let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
          .                       Some(lco) => lco,
          .                       None => hint::unreachable_unchecked(),
          .                   };
          .                   self.alloc.deallocate(
    120,233 ( 0.00%)              NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
          .                       layout,
          .                   );
          .               }
          .           
          .               /// Marks all table buckets as empty without dropping their contents.
          .               #[inline]
          .               fn clear_no_drop(&mut self) {
     45,622 ( 0.00%)          if !self.is_empty_singleton() {
          .                       unsafe {
          .                           self.ctrl(0).write_bytes(EMPTY, self.num_ctrl_bytes());
          .                       }
          .                   }
     53,011 ( 0.00%)          self.items = 0;
     45,657 ( 0.00%)          self.growth_left = bucket_mask_to_capacity(self.bucket_mask);
          .               }
          .           
          .               #[inline]
          .               unsafe fn erase(&mut self, index: usize) {
          .                   debug_assert!(is_full(*self.ctrl(index)));
    274,671 ( 0.00%)          let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;
          .                   let empty_before = Group::load(self.ctrl(index_before)).match_empty();
          .                   let empty_after = Group::load(self.ctrl(index)).match_empty();
          .           
          .                   // If we are inside a continuous block of Group::WIDTH full or deleted
          .                   // cells then a probe window may have seen a full block when trying to
          .                   // insert. We therefore need to keep that block non-empty so that
          .                   // lookups will continue searching to the next probe window.
          .                   //
          .                   // Note that in this context `leading_zeros` refers to the bytes at the
          .                   // end of a group, while `trailing_zeros` refers to the bytes at the
          .                   // beginning of a group.
  1,098,684 ( 0.00%)          let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {
          .                       DELETED
          .                   } else {
  1,336,525 ( 0.00%)              self.growth_left += 1;
          .                       EMPTY
          .                   };
          .                   self.set_ctrl(index, ctrl);
  1,098,684 ( 0.00%)          self.items -= 1;
          .               }
          .           }
          .           
          .           impl<T: Clone, A: Allocator + Clone> Clone for RawTable<T, A> {
     11,616 ( 0.00%)      fn clone(&self) -> Self {
      1,533 ( 0.00%)          if self.table.is_empty_singleton() {
          .                       Self::new_in(self.table.alloc.clone())
          .                   } else {
          .                       unsafe {
          .                           let mut new_table = ManuallyDrop::new(
          .                               // Avoid `Result::ok_or_else` because it bloats LLVM IR.
          .                               match Self::new_uninitialized(
          .                                   self.table.alloc.clone(),
          .                                   self.table.buckets(),
-- line 1615 ----------------------------------------
-- line 1624 ----------------------------------------
          .                               // We need to free the memory allocated for the new table.
          .                               new_table.free_buckets();
          .                           });
          .           
          .                           // Return the newly created table.
          .                           ManuallyDrop::into_inner(new_table)
          .                       }
          .                   }
     13,068 ( 0.00%)      }
          .           
          .               fn clone_from(&mut self, source: &Self) {
          .                   if source.table.is_empty_singleton() {
          .                       *self = Self::new_in(self.table.alloc.clone());
          .                   } else {
          .                       unsafe {
          .                           // First, drop all our elements without clearing the control bytes.
          .                           self.drop_elements();
-- line 1640 ----------------------------------------
-- line 1687 ----------------------------------------
          .                       .table
          .                       .ctrl(0)
          .                       .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());
          .                   source
          .                       .data_start()
          .                       .copy_to_nonoverlapping(self.data_start(), self.table.buckets());
          .           
          .                   self.table.items = source.table.items;
         94 ( 0.00%)          self.table.growth_left = source.table.growth_left;
          .               }
          .           }
          .           
          .           impl<T: Clone, A: Allocator + Clone> RawTable<T, A> {
          .               /// Common code for clone and clone_from. Assumes `self.buckets() == source.buckets()`.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               unsafe fn clone_from_impl(&mut self, source: &Self, mut on_panic: impl FnMut(&mut Self)) {
          .                   // Copy the control bytes unchanged. We do this in a single pass
-- line 1703 ----------------------------------------
-- line 1790 ----------------------------------------
          .               fn default() -> Self {
          .                   Self::new_in(Default::default())
          .               }
          .           }
          .           
          .           #[cfg(feature = "nightly")]
          .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawTable<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
  1,728,515 ( 0.01%)      fn drop(&mut self) {
  1,593,817 ( 0.01%)          if !self.table.is_empty_singleton() {
          .                       unsafe {
          .                           self.drop_elements();
          .                           self.free_buckets();
          .                       }
          .                   }
  1,858,592 ( 0.01%)      }
          .           }
          .           #[cfg(not(feature = "nightly"))]
          .           impl<T, A: Allocator + Clone> Drop for RawTable<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn drop(&mut self) {
          .                   if !self.table.is_empty_singleton() {
          .                       unsafe {
          .                           self.drop_elements();
-- line 1813 ----------------------------------------
-- line 1817 ----------------------------------------
          .               }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> IntoIterator for RawTable<T, A> {
          .               type Item = T;
          .               type IntoIter = RawIntoIter<T, A>;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
     17,820 ( 0.00%)      fn into_iter(self) -> RawIntoIter<T, A> {
          .                   unsafe {
          .                       let iter = self.iter();
          .                       self.into_iter_from(iter)
          .                   }
     22,275 ( 0.00%)      }
          .           }
          .           
          .           /// Iterator over a sub-range of a table. Unlike `RawIter` this iterator does
          .           /// not track an item count.
          .           pub(crate) struct RawIterRange<T> {
          .               // Mask of full buckets in the current group. Bits are cleared from this
          .               // mask as each element is processed.
          .               current_group: BitMask,
-- line 1838 ----------------------------------------
-- line 1934 ----------------------------------------
          .           
          .           impl<T> Iterator for RawIterRange<T> {
          .               type Item = Bucket<T>;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn next(&mut self) -> Option<Bucket<T>> {
          .                   unsafe {
          .                       loop {
    868,572 ( 0.00%)                  if let Some(index) = self.current_group.lowest_set_bit() {
    128,742 ( 0.00%)                      self.current_group = self.current_group.remove_lowest_bit();
    211,330 ( 0.00%)                      return Some(self.data.next_n(index));
          .                           }
          .           
    888,113 ( 0.00%)                  if self.next_ctrl >= self.end {
          .                               return None;
          .                           }
          .           
          .                           // We might read past self.end up to the next group boundary,
          .                           // but this is fine because it only occurs on tables smaller
          .                           // than the group size where the trailing control bytes are all
          .                           // EMPTY. On larger tables self.end is guaranteed to be aligned
          .                           // to the group size (since tables are power-of-two sized).
     18,288 ( 0.00%)                  self.current_group = Group::load_aligned(self.next_ctrl).match_full();
     20,331 ( 0.00%)                  self.data = self.data.next_n(Group::WIDTH);
     31,918 ( 0.00%)                  self.next_ctrl = self.next_ctrl.add(Group::WIDTH);
          .                       }
          .                   }
          .               }
          .           
          .               #[inline]
          .               fn size_hint(&self) -> (usize, Option<usize>) {
          .                   // We don't have an item count, so just guess based on the range size.
          .                   (
-- line 1966 ----------------------------------------
-- line 2102 ----------------------------------------
          .                           }
          .                       } else {
          .                           // We must have already iterated past the removed item.
          .                       }
          .                   }
          .               }
          .           
          .               unsafe fn drop_elements(&mut self) {
      4,139 ( 0.00%)          if mem::needs_drop::<T>() && self.len() != 0 {
          .                       for item in self {
          .                           item.drop();
          .                       }
          .                   }
          .               }
          .           }
          .           
          .           impl<T> Clone for RawIter<T> {
-- line 2118 ----------------------------------------
-- line 2124 ----------------------------------------
          .                   }
          .               }
          .           }
          .           
          .           impl<T> Iterator for RawIter<T> {
          .               type Item = Bucket<T>;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
    139,109 ( 0.00%)      fn next(&mut self) -> Option<Bucket<T>> {
    312,018 ( 0.00%)          if let Some(b) = self.iter.next() {
  2,194,745 ( 0.01%)              self.items -= 1;
          .                       Some(b)
          .                   } else {
          .                       // We don't check against items == 0 here to allow the
          .                       // compiler to optimize away the item count entirely if the
          .                       // iterator length is never queried.
          .                       debug_assert_eq!(self.items, 0);
          .                       None
          .                   }
    278,218 ( 0.00%)      }
          .           
          .               #[inline]
          .               fn size_hint(&self) -> (usize, Option<usize>) {
          .                   (self.items, Some(self.items))
          .               }
          .           }
          .           
          .           impl<T> ExactSizeIterator for RawIter<T> {}
-- line 2151 ----------------------------------------
-- line 2177 ----------------------------------------
          .               T: Sync,
          .               A: Sync,
          .           {
          .           }
          .           
          .           #[cfg(feature = "nightly")]
          .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
      6,742 ( 0.00%)      fn drop(&mut self) {
          .                   unsafe {
          .                       // Drop all remaining elements
          .                       self.iter.drop_elements();
          .           
          .                       // Free the table
     38,870 ( 0.00%)              if let Some((ptr, layout)) = self.allocation {
          .                           self.alloc.deallocate(ptr, layout);
          .                       }
          .                   }
      1,846 ( 0.00%)      }
          .           }
          .           #[cfg(not(feature = "nightly"))]
          .           impl<T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn drop(&mut self) {
          .                   unsafe {
          .                       // Drop all remaining elements
          .                       self.iter.drop_elements();
-- line 2203 ----------------------------------------
-- line 2209 ----------------------------------------
          .                   }
          .               }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> Iterator for RawIntoIter<T, A> {
          .               type Item = T;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
      8,826 ( 0.00%)      fn next(&mut self) -> Option<T> {
      5,850 ( 0.00%)          unsafe { Some(self.iter.next()?.read()) }
     21,792 ( 0.00%)      }
          .           
          .               #[inline]
          .               fn size_hint(&self) -> (usize, Option<usize>) {
          4 ( 0.00%)          self.iter.size_hint()
          .               }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> ExactSizeIterator for RawIntoIter<T, A> {}
          .           impl<T, A: Allocator + Clone> FusedIterator for RawIntoIter<T, A> {}
          .           
          .           /// Iterator which consumes elements without freeing the table storage.
          .           pub struct RawDrain<'a, T, A: Allocator + Clone = Global> {
-- line 2231 ----------------------------------------
-- line 2259 ----------------------------------------
          .           where
          .               T: Sync,
          .               A: Sync,
          .           {
          .           }
          .           
          .           impl<T, A: Allocator + Clone> Drop for RawDrain<'_, T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
      4,112 ( 0.00%)      fn drop(&mut self) {
          .                   unsafe {
          .                       // Drop all remaining elements. Note that this may panic.
          .                       self.iter.drop_elements();
          .           
          .                       // Reset the contents of the table now that all elements have been
          .                       // dropped.
          .                       self.table.clear_no_drop();
          .           
          .                       // Move the now empty table back to its original location.
        514 ( 0.00%)              self.orig_table
          .                           .as_ptr()
          .                           .copy_from_nonoverlapping(&*self.table, 1);
          .                   }
      4,112 ( 0.00%)      }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> Iterator for RawDrain<'_, T, A> {
          .               type Item = T;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn next(&mut self) -> Option<T> {
          .                   unsafe {
-- line 2289 ----------------------------------------

 36,776,961 ( 0.12%)  <counts for unidentified lines in /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_trait_selection/src/traits/fulfill.rs
--------------------------------------------------------------------------------
Ir                  

-- line 33 ----------------------------------------
         .           
         .           impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {
         .               /// Note that we include both the `ParamEnv` and the `Predicate`,
         .               /// as the `ParamEnv` can influence whether fulfillment succeeds
         .               /// or fails.
         .               type CacheKey = ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>;
         .           
         .               fn as_cache_key(&self) -> Self::CacheKey {
   581,349 ( 0.00%)          self.obligation.param_env.and(self.obligation.predicate)
         .               }
         .           }
         .           
         .           /// The fulfillment context is used to drive trait resolution. It
         .           /// consists of a list of obligations that must be (eventually)
         .           /// satisfied. The job is to track which are satisfied, which yielded
         .           /// errors, and which are still pending. At any point, users can call
         .           /// `select_where_possible`, and the fulfillment context will try to do
-- line 49 ----------------------------------------
-- line 79 ----------------------------------------
         .               // outside of any snapshot, so any use of it inside a snapshot
         .               // will lead to trouble and therefore is checked against, but
         .               // other fulfillment contexts sometimes do live inside of
         .               // a snapshot (they don't *straddle* a snapshot, so there
         .               // is no trouble there).
         .               usable_in_snapshot: bool,
         .           }
         .           
        10 ( 0.00%)  #[derive(Clone, Debug)]
         .           pub struct PendingPredicateObligation<'tcx> {
         .               pub obligation: PredicateObligation<'tcx>,
         .               // This is far more often read than modified, meaning that we
         .               // should mostly optimize for reading speed, while modifying is not as relevant.
         .               //
         .               // For whatever reason using a boxed slice is slower than using a `Vec` here.
         .               pub stalled_on: Vec<TyOrConstInferVar<'tcx>>,
         .           }
         .           
         .           // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.
         .           #[cfg(all(target_arch = "x86_64", target_pointer_width = "64"))]
         .           static_assert_size!(PendingPredicateObligation<'_>, 72);
         .           
         .           impl<'a, 'tcx> FulfillmentContext<'tcx> {
         .               /// Creates a new fulfillment context.
     8,689 ( 0.00%)      pub fn new() -> FulfillmentContext<'tcx> {
   116,806 ( 0.00%)          FulfillmentContext {
    17,197 ( 0.00%)              predicates: ObligationForest::new(),
         .                       relationships: FxHashMap::default(),
         .                       register_region_obligations: true,
         .                       usable_in_snapshot: false,
         .                   }
     8,689 ( 0.00%)      }
         .           
         .               pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {
       315 ( 0.00%)          FulfillmentContext {
       105 ( 0.00%)              predicates: ObligationForest::new(),
         .                       relationships: FxHashMap::default(),
         .                       register_region_obligations: true,
         .                       usable_in_snapshot: true,
         .                   }
         .               }
         .           
         .               pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {
    29,052 ( 0.00%)          FulfillmentContext {
     7,263 ( 0.00%)              predicates: ObligationForest::new(),
         .                       relationships: FxHashMap::default(),
         .                       register_region_obligations: false,
         .                       usable_in_snapshot: false,
         .                   }
         .               }
         .           
         .               /// Attempts to select obligations using `selcx`.
         .               fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>) -> Vec<FulfillmentError<'tcx>> {
   135,290 ( 0.00%)          let span = debug_span!("select", obligation_forest_size = ?self.predicates.len());
         .                   let _enter = span.enter();
         .           
         .                   let mut errors = Vec::new();
         .           
         .                   loop {
         .                       debug!("select: starting another iteration");
         .           
         .                       // Process pending obligations.
         .                       let outcome: Outcome<_, _> =
   596,736 ( 0.00%)                  self.predicates.process_obligations(&mut FulfillProcessor {
         .                               selcx,
    85,248 ( 0.00%)                      register_region_obligations: self.register_region_obligations,
         .                           });
         .                       debug!("select: outcome={:#?}", outcome);
         .           
         .                       // FIXME: if we kept the original cache key, we could mark projection
         .                       // obligations as complete for the projection cache here.
         .           
         .                       errors.extend(outcome.errors.into_iter().map(to_fulfillment_error));
         .           
         .                       // If nothing new was added, no need to keep looping.
   170,496 ( 0.00%)              if outcome.stalled {
         .                           break;
         .                       }
         .                   }
         .           
         .                   debug!(
         .                       "select({} predicates remaining, {} errors) done",
         .                       self.predicates.len(),
         .                       errors.len()
-- line 162 ----------------------------------------
-- line 169 ----------------------------------------
         .           impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {
         .               /// "Normalize" a projection type `<SomeType as SomeTrait>::X` by
         .               /// creating a fresh type variable `$0` as well as a projection
         .               /// predicate `<SomeType as SomeTrait>::X == $0`. When the
         .               /// inference engine runs, it will attempt to find an impl of
         .               /// `SomeTrait` or a where-clause that lets us unify `$0` with
         .               /// something concrete. If this fails, we'll unify `$0` with
         .               /// `projection_ty` again.
     2,310 ( 0.00%)      #[tracing::instrument(level = "debug", skip(self, infcx, param_env, cause))]
         .               fn normalize_projection_type(
         .                   &mut self,
         .                   infcx: &InferCtxt<'_, 'tcx>,
         .                   param_env: ty::ParamEnv<'tcx>,
         .                   projection_ty: ty::ProjectionTy<'tcx>,
         .                   cause: ObligationCause<'tcx>,
         .               ) -> Ty<'tcx> {
         .                   debug_assert!(!projection_ty.has_escaping_bound_vars());
         .           
         .                   // FIXME(#20304) -- cache
         .           
         .                   let mut selcx = SelectionContext::new(infcx);
         .                   let mut obligations = vec![];
       945 ( 0.00%)          let normalized_ty = project::normalize_projection_type(
         .                       &mut selcx,
         .                       param_env,
         .                       projection_ty,
       525 ( 0.00%)              cause,
         .                       0,
         .                       &mut obligations,
         .                   );
         .                   self.register_predicate_obligations(infcx, obligations);
         .           
         .                   debug!(?normalized_ty);
         .           
         .                   normalized_ty
         .               }
         .           
   382,776 ( 0.00%)      fn register_predicate_obligation(
         .                   &mut self,
         .                   infcx: &InferCtxt<'_, 'tcx>,
         .                   obligation: PredicateObligation<'tcx>,
         .               ) {
         .                   // this helps to reduce duplicate errors, as well as making
         .                   // debug output much nicer to read and so on.
   191,388 ( 0.00%)          let obligation = infcx.resolve_vars_if_possible(obligation);
         .           
         .                   debug!(?obligation, "register_predicate_obligation");
         .           
   382,776 ( 0.00%)          assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);
         .           
   191,388 ( 0.00%)          super::relationships::update(self, infcx, &obligation);
         .           
         .                   self.predicates
         .                       .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });
   318,980 ( 0.00%)      }
         .           
   267,152 ( 0.00%)      fn select_all_or_error(&mut self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<FulfillmentError<'tcx>> {
         .                   {
    33,394 ( 0.00%)              let errors = self.select_where_possible(infcx);
    33,394 ( 0.00%)              if !errors.is_empty() {
         5 ( 0.00%)                  return errors;
         .                       }
         .                   }
         .           
   166,965 ( 0.00%)          self.predicates.to_errors(CodeAmbiguity).into_iter().map(to_fulfillment_error).collect()
   233,758 ( 0.00%)      }
         .           
   676,450 ( 0.00%)      fn select_where_possible(
         .                   &mut self,
         .                   infcx: &InferCtxt<'_, 'tcx>,
         .               ) -> Vec<FulfillmentError<'tcx>> {
         .                   let mut selcx = SelectionContext::new(infcx);
         .                   self.select(&mut selcx)
   608,805 ( 0.00%)      }
         .           
       429 ( 0.00%)      fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {
         .                   self.predicates.map_pending_obligations(|o| o.obligation.clone())
       572 ( 0.00%)      }
         .           
         .               fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {
        81 ( 0.00%)          &mut self.relationships
        81 ( 0.00%)      }
         .           }
         .           
         .           struct FulfillProcessor<'a, 'b, 'tcx> {
         .               selcx: &'a mut SelectionContext<'b, 'tcx>,
         .               register_region_obligations: bool,
         .           }
         .           
         .           fn mk_pending(os: Vec<PredicateObligation<'_>>) -> Vec<PendingPredicateObligation<'_>> {
-- line 258 ----------------------------------------
-- line 275 ----------------------------------------
         .               #[inline(always)]
         .               fn process_obligation(
         .                   &mut self,
         .                   pending_obligation: &mut Self::Obligation,
         .               ) -> ProcessResult<Self::Obligation, Self::Error> {
         .                   // If we were stalled on some unresolved variables, first check whether
         .                   // any of them have been resolved; if not, don't bother doing more work
         .                   // yet.
14,673,102 ( 0.05%)          let change = match pending_obligation.stalled_on.len() {
         .                       // Match arms are in order of frequency, which matters because this
         .                       // code is so hot. 1 and 0 dominate; 2+ is fairly rare.
         .                       1 => {
 7,186,656 ( 0.02%)                  let infer_var = pending_obligation.stalled_on[0];
 2,395,552 ( 0.01%)                  self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)
         .                       }
         .                       0 => {
         .                           // In this case we haven't changed, but wish to make a change.
         .                           true
         .                       }
         .                       _ => {
         .                           // This `for` loop was once a call to `all()`, but this lower-level
         .                           // form was a perf win. See #64545 for details.
    44,712 ( 0.00%)                  (|| {
    87,384 ( 0.00%)                      for &infer_var in &pending_obligation.stalled_on {
     1,084 ( 0.00%)                          if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {
         .                                       return true;
         .                                   }
         .                               }
         .                               false
         .                           })()
         .                       }
         .                   };
         .           
     1,062 ( 0.00%)          if !change {
         .                       debug!(
         .                           "process_predicate: pending obligation {:?} still stalled on {:?}",
         .                           self.selcx.infcx().resolve_vars_if_possible(pending_obligation.obligation.clone()),
         .                           pending_obligation.stalled_on
         .                       );
         .                       return ProcessResult::Unchanged;
         .                   }
         .           
   261,750 ( 0.00%)          self.progress_changed_obligations(pending_obligation)
         .               }
         .           
         .               fn process_backedge<'c, I>(
         .                   &mut self,
         .                   cycle: I,
         .                   _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>,
         .               ) where
         .                   I: Clone + Iterator<Item = &'c PendingPredicateObligation<'tcx>>,
-- line 325 ----------------------------------------
-- line 333 ----------------------------------------
         .               }
         .           }
         .           
         .           impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {
         .               // The code calling this method is extremely hot and only rarely
         .               // actually uses this, so move this part of the code
         .               // out of that loop.
         .               #[inline(never)]
   872,500 ( 0.00%)      fn progress_changed_obligations(
         .                   &mut self,
         .                   pending_obligation: &mut PendingPredicateObligation<'tcx>,
         .               ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {
         .                   pending_obligation.stalled_on.truncate(0);
         .           
         .                   let obligation = &mut pending_obligation.obligation;
         .           
   261,750 ( 0.00%)          if obligation.predicate.has_infer_types_or_consts() {
    44,956 ( 0.00%)              obligation.predicate =
   134,868 ( 0.00%)                  self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);
         .                   }
         .           
         .                   debug!(?obligation, ?obligation.cause, "process_obligation");
         .           
         .                   let infcx = self.selcx.infcx();
         .           
    84,588 ( 0.00%)          let binder = obligation.predicate.kind();
   610,750 ( 0.00%)          match binder.no_bound_vars() {
       638 ( 0.00%)              None => match binder.skip_binder() {
         .                           // Evaluation will discard candidates using the leak check.
         .                           // This means we need to pass it the bound version of our
         .                           // predicate.
         .                           ty::PredicateKind::Trait(trait_ref) => {
         .                               let trait_obligation = obligation.with(binder.rebind(trait_ref));
         .           
       116 ( 0.00%)                      self.process_trait_obligation(
         .                                   obligation,
       348 ( 0.00%)                          trait_obligation,
         .                                   &mut pending_obligation.stalled_on,
         .                               )
         .                           }
         .                           ty::PredicateKind::Projection(data) => {
         .                               let project_obligation = obligation.with(binder.rebind(data));
         .           
       116 ( 0.00%)                      self.process_projection_obligation(
         .                                   obligation,
       348 ( 0.00%)                          project_obligation,
         .                                   &mut pending_obligation.stalled_on,
         .                               )
         .                           }
         .                           ty::PredicateKind::RegionOutlives(_)
         .                           | ty::PredicateKind::TypeOutlives(_)
         .                           | ty::PredicateKind::WellFormed(_)
         .                           | ty::PredicateKind::ObjectSafe(_)
         .                           | ty::PredicateKind::ClosureKind(..)
-- line 386 ----------------------------------------
-- line 397 ----------------------------------------
         .                           ty::PredicateKind::TypeWellFormedFromEnv(..) => {
         .                               bug!("TypeWellFormedFromEnv is only used for Chalk")
         .                           }
         .                       },
         .                       Some(pred) => match pred {
         .                           ty::PredicateKind::Trait(data) => {
         .                               let trait_obligation = obligation.with(Binder::dummy(data));
         .           
   225,210 ( 0.00%)                      self.process_trait_obligation(
         .                                   obligation,
   990,924 ( 0.00%)                          trait_obligation,
         .                                   &mut pending_obligation.stalled_on,
         .                               )
         .                           }
         .           
         .                           ty::PredicateKind::RegionOutlives(data) => {
    25,962 ( 0.00%)                      match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {
    17,308 ( 0.00%)                          Ok(()) => ProcessResult::Changed(vec![]),
         .                                   Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),
         .                               }
         .                           }
         .           
         .                           ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {
    14,592 ( 0.00%)                      if self.register_region_obligations {
    36,470 ( 0.00%)                          self.selcx.infcx().register_region_obligation_with_cause(
         .                                       t_a,
         .                                       r_b,
         .                                       &obligation.cause,
         .                                   );
         .                               }
         .                               ProcessResult::Changed(vec![])
         .                           }
         .           
         .                           ty::PredicateKind::Projection(ref data) => {
         .                               let project_obligation = obligation.with(Binder::dummy(*data));
         .           
    24,455 ( 0.00%)                      self.process_projection_obligation(
         .                                   obligation,
    73,365 ( 0.00%)                          project_obligation,
         .                                   &mut pending_obligation.stalled_on,
         .                               )
         .                           }
         .           
         .                           ty::PredicateKind::ObjectSafe(trait_def_id) => {
       264 ( 0.00%)                      if !self.selcx.tcx().is_object_safe(trait_def_id) {
         .                                   ProcessResult::Error(CodeSelectionError(Unimplemented))
         .                               } else {
         .                                   ProcessResult::Changed(vec![])
         .                               }
         .                           }
         .           
         .                           ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {
     1,089 ( 0.00%)                      match self.selcx.infcx().closure_kind(closure_substs) {
         .                                   Some(closure_kind) => {
     1,614 ( 0.00%)                              if closure_kind.extends(kind) {
         .                                           ProcessResult::Changed(vec![])
         .                                       } else {
         .                                           ProcessResult::Error(CodeSelectionError(Unimplemented))
         .                                       }
         .                                   }
         .                                   None => ProcessResult::Unchanged,
         .                               }
         .                           }
         .           
         .                           ty::PredicateKind::WellFormed(arg) => {
   163,912 ( 0.00%)                      match wf::obligations(
         .                                   self.selcx.infcx(),
    46,832 ( 0.00%)                          obligation.param_env,
    46,832 ( 0.00%)                          obligation.cause.body_id,
    70,248 ( 0.00%)                          obligation.recursion_depth + 1,
         .                                   arg,
         .                                   obligation.cause.span,
         .                               ) {
         .                                   None => {
    18,548 ( 0.00%)                              pending_obligation.stalled_on =
    32,459 ( 0.00%)                                  vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];
     9,274 ( 0.00%)                              ProcessResult::Unchanged
         .                                   }
    56,337 ( 0.00%)                          Some(os) => ProcessResult::Changed(mk_pending(os)),
         .                               }
         .                           }
         .           
         .                           ty::PredicateKind::Subtype(subtype) => {
    14,168 ( 0.00%)                      match self.selcx.infcx().subtype_predicate(
         .                                   &obligation.cause,
         .                                   obligation.param_env,
         .                                   Binder::dummy(subtype),
         .                               ) {
         .                                   None => {
         .                                       // None means that both are unresolved.
     8,130 ( 0.00%)                              pending_obligation.stalled_on = vec![
     1,626 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),
     3,252 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),
         .                                       ];
         .                                       ProcessResult::Unchanged
         .                                   }
         .                                   Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),
         .                                   Some(Err(err)) => {
         .                                       let expected_found =
         .                                           ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);
         .                                       ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(
-- line 497 ----------------------------------------
-- line 498 ----------------------------------------
         .                                           expected_found,
         .                                           err,
         .                                       ))
         .                                   }
         .                               }
         .                           }
         .           
         .                           ty::PredicateKind::Coerce(coerce) => {
       128 ( 0.00%)                      match self.selcx.infcx().coerce_predicate(
         .                                   &obligation.cause,
         .                                   obligation.param_env,
         .                                   Binder::dummy(coerce),
         .                               ) {
         .                                   None => {
         .                                       // None means that both are unresolved.
        35 ( 0.00%)                              pending_obligation.stalled_on = vec![
         7 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(coerce.a).unwrap(),
        14 ( 0.00%)                                  TyOrConstInferVar::maybe_from_ty(coerce.b).unwrap(),
         .                                       ];
         .                                       ProcessResult::Unchanged
         .                                   }
         .                                   Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),
         .                                   Some(Err(err)) => {
         .                                       let expected_found = ExpectedFound::new(false, coerce.a, coerce.b);
         .                                       ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(
         .                                           expected_found,
         .                                           err,
         .                                       ))
         .                                   }
         .                               }
         .                           }
         .           
         .                           ty::PredicateKind::ConstEvaluatable(uv) => {
        24 ( 0.00%)                      match const_evaluatable::is_const_evaluatable(
         .                                   self.selcx.infcx(),
        48 ( 0.00%)                          uv,
         8 ( 0.00%)                          obligation.param_env,
         4 ( 0.00%)                          obligation.cause.span,
         .                               ) {
         .                                   Ok(()) => ProcessResult::Changed(vec![]),
         .                                   Err(NotConstEvaluatable::MentionsInfer) => {
         .                                       pending_obligation.stalled_on.clear();
         .                                       pending_obligation.stalled_on.extend(
         .                                           uv.substs
         .                                               .iter()
         .                                               .filter_map(TyOrConstInferVar::maybe_from_generic_arg),
-- line 543 ----------------------------------------
-- line 639 ----------------------------------------
         .                                   }
         .                               }
         .                           }
         .                           ty::PredicateKind::TypeWellFormedFromEnv(..) => {
         .                               bug!("TypeWellFormedFromEnv is only used for Chalk")
         .                           }
         .                       },
         .                   }
   785,250 ( 0.00%)      }
         .           
   856,349 ( 0.00%)      #[instrument(level = "debug", skip(self, obligation, stalled_on))]
         .               fn process_trait_obligation(
         .                   &mut self,
         .                   obligation: &PredicateObligation<'tcx>,
         .                   trait_obligation: TraitObligation<'tcx>,
         .                   stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,
         .               ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {
    45,071 ( 0.00%)          let infcx = self.selcx.infcx();
   135,213 ( 0.00%)          if obligation.predicate.is_global() {
         .                       // no type variables present, can use evaluation for better caching.
         .                       // FIXME: consider caching errors too.
    43,936 ( 0.00%)              if infcx.predicate_must_hold_considering_regions(obligation) {
         .                           debug!(
         .                               "selecting trait at depth {} evaluated to holds",
         .                               obligation.recursion_depth
         .                           );
    43,500 ( 0.00%)                  return ProcessResult::Changed(vec![]);
         .                       }
         .                   }
         .           
   163,245 ( 0.00%)          match self.selcx.select(&trait_obligation) {
         .                       Ok(Some(impl_source)) => {
         .                           debug!("selecting trait at depth {} yielded Ok(Some)", obligation.recursion_depth);
   237,582 ( 0.00%)                  ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))
         .                       }
         .                       Ok(None) => {
         .                           debug!("selecting trait at depth {} yielded Ok(None)", obligation.recursion_depth);
         .           
         .                           // This is a bit subtle: for the most part, the
         .                           // only reason we can fail to make progress on
         .                           // trait selection is because we don't have enough
         .                           // information about the types in the trait.
         .                           stalled_on.clear();
         .                           stalled_on.extend(substs_infer_vars(
         .                               self.selcx,
    10,121 ( 0.00%)                      trait_obligation.predicate.map_bound(|pred| pred.trait_ref.substs),
         .                           ));
         .           
         .                           debug!(
         .                               "process_predicate: pending obligation {:?} now stalled on {:?}",
         .                               infcx.resolve_vars_if_possible(obligation.clone()),
         .                               stalled_on
         .                           );
         .           
    10,121 ( 0.00%)                  ProcessResult::Unchanged
         .                       }
         .                       Err(selection_err) => {
         .                           debug!("selecting trait at depth {} yielded Err", obligation.recursion_depth);
         .           
        14 ( 0.00%)                  ProcessResult::Error(CodeSelectionError(selection_err))
         .                       }
         .                   }
         .               }
         .           
    54,120 ( 0.00%)      fn process_projection_obligation(
         .                   &mut self,
         .                   obligation: &PredicateObligation<'tcx>,
         .                   project_obligation: PolyProjectionObligation<'tcx>,
         .                   stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,
         .               ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {
     4,920 ( 0.00%)          let tcx = self.selcx.tcx();
         .           
    14,760 ( 0.00%)          if obligation.predicate.is_global() {
         .                       // no type variables present, can use evaluation for better caching.
         .                       // FIXME: consider caching errors too.
       520 ( 0.00%)              if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {
     1,548 ( 0.00%)                  if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(
         .                               &mut self.selcx,
     1,806 ( 0.00%)                      project_obligation.predicate,
         .                           ) {
         .                               // If `predicate_must_hold_considering_regions` succeeds, then we've
         .                               // evaluated all sub-obligations. We can therefore mark the 'root'
         .                               // obligation as complete, and skip evaluating sub-obligations.
     1,548 ( 0.00%)                      self.selcx
         .                                   .infcx()
         .                                   .inner
         .                                   .borrow_mut()
         .                                   .projection_cache()
         .                                   .complete(key, EvaluationResult::EvaluatedToOk);
         .                           }
       516 ( 0.00%)                  return ProcessResult::Changed(vec![]);
         .                       } else {
         .                           tracing::debug!("Does NOT hold: {:?}", obligation);
         .                       }
         .                   }
         .           
    32,634 ( 0.00%)          match project::poly_project_and_unify_type(self.selcx, &project_obligation) {
         .                       Ok(Ok(Some(os))) => ProcessResult::Changed(mk_pending(os)),
         .                       Ok(Ok(None)) => {
         .                           stalled_on.clear();
         .                           stalled_on.extend(substs_infer_vars(
         .                               self.selcx,
     2,247 ( 0.00%)                      project_obligation.predicate.map_bound(|pred| pred.projection_ty.substs),
         .                           ));
     2,247 ( 0.00%)                  ProcessResult::Unchanged
         .                       }
         .                       // Let the caller handle the recursion
         .                       Ok(Err(project::InProgress)) => ProcessResult::Changed(mk_pending(vec![
         .                           project_obligation.with(project_obligation.predicate.to_predicate(tcx)),
         .                       ])),
         .                       Err(e) => ProcessResult::Error(CodeProjectionError(e)),
         .                   }
    39,360 ( 0.00%)      }
         .           }
         .           
         .           /// Returns the set of inference variables contained in `substs`.
         .           fn substs_infer_vars<'a, 'tcx>(
         .               selcx: &mut SelectionContext<'a, 'tcx>,
         .               substs: ty::Binder<'tcx, SubstsRef<'tcx>>,
         .           ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {
         .               selcx
         .                   .infcx()
         .                   .resolve_vars_if_possible(substs)
         .                   .skip_binder() // ok because this check doesn't care about regions
         .                   .iter()
         .                   .filter(|arg| arg.has_infer_types_or_consts())
         .                   .flat_map(|arg| {
    68,335 ( 0.00%)              let mut walker = arg.walk();
   123,153 ( 0.00%)              while let Some(c) = walker.next() {
    13,701 ( 0.00%)                  if !c.has_infer_types_or_consts() {
         .                               walker.visited.remove(&c);
        30 ( 0.00%)                      walker.skip_current_subtree();
         .                           }
         .                       }
         .                       walker.visited.into_iter()
         .                   })
         .                   .filter_map(TyOrConstInferVar::maybe_from_generic_arg)
         .           }
         .           
         .           fn to_fulfillment_error<'tcx>(
         .               error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>,
         .           ) -> FulfillmentError<'tcx> {
         .               let mut iter = error.backtrace.into_iter();
         1 ( 0.00%)      let obligation = iter.next().unwrap().obligation;
         .               // The root obligation is the last item in the backtrace - if there's only
         .               // one item, then it's the same as the main obligation
         .               let root_obligation = iter.next_back().map_or_else(|| obligation.clone(), |e| e.obligation);
        30 ( 0.00%)      FulfillmentError::new(obligation, error.error, root_obligation)
         .           }

10,611,173 ( 0.03%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_trait_selection/src/traits/fulfill.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./malloc/malloc.c
  ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S
  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
387,169,689 ( 1.27%)  events annotated

