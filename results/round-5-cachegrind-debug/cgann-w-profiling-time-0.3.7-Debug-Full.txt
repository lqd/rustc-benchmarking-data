--------------------------------------------------------------------------------
I1 cache:         65536 B, 64 B, 4-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         67108864 B, 64 B, 64-way associative
Command:          /usr/home/liquid/.rustup/toolchains/w-profiling/bin/rustc --crate-name time --edition=2018 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=0 --cfg feature="alloc" --cfg feature="default" --cfg feature="std" -C metadata=5f5bdbf8493b9421 -C extra-filename=-5f5bdbf8493b9421 --out-dir /usr/home/liquid/tmp/.tmp4dG5y5/target/debug/deps -L dependency=/usr/home/liquid/tmp/.tmp4dG5y5/target/debug/deps --extern libc=/usr/home/liquid/tmp/.tmp4dG5y5/target/debug/deps/liblibc-7ab9b4c54067a078.rmeta --extern num_threads=/usr/home/liquid/tmp/.tmp4dG5y5/target/debug/deps/libnum_threads-5779adf31814e8d6.rmeta -Adeprecated -Aunknown-lints -Zincremental-verify-ich
Data file:        results/cgout-w-profiling-time-0.3.7-Debug-Full
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       0.1
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     
--------------------------------------------------------------------------------
2,616,777,146 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                    file:function
--------------------------------------------------------------------------------
102,411,317 ( 3.91%)  ???:llvm::FPPassManager::runOnFunction(llvm::Function&)
 88,946,528 ( 3.40%)  ???:llvm::SelectionDAG::Combine(llvm::CombineLevel, llvm::AAResults*, llvm::CodeGenOpt::Level)
 76,433,034 ( 2.92%)  ./malloc/malloc.c:_int_free
 72,435,024 ( 2.77%)  ./malloc/malloc.c:_int_malloc
 44,243,052 ( 1.69%)  ./malloc/malloc.c:malloc
 29,184,131 ( 1.12%)  ???:(anonymous namespace)::RegAllocFast::allocateBasicBlock(llvm::MachineBasicBlock&)
 28,562,954 ( 1.09%)  ???:llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode*, unsigned char const*, unsigned int)
 24,474,222 ( 0.94%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
 22,267,115 ( 0.85%)  ./malloc/malloc.c:free
 21,578,373 ( 0.82%)  ???:llvm::MachineInstr::addOperand(llvm::MachineFunction&, llvm::MachineOperand const&)
 19,951,444 ( 0.76%)  ???:(anonymous namespace)::Verifier::visitInstruction(llvm::Instruction&)
 19,191,579 ( 0.73%)  ???:llvm::PMDataManager::verifyPreservedAnalysis(llvm::Pass*)
 16,914,040 ( 0.65%)  ???:llvm::ScheduleDAGSDNodes::BuildSchedUnits()
 16,211,834 ( 0.62%)  ???:llvm::AttributeList::addAttributes(llvm::LLVMContext&, unsigned int, llvm::AttrBuilder const&) const
 15,261,930 ( 0.58%)  ???:llvm::TargetLoweringBase::getTypeConversion(llvm::LLVMContext&, llvm::EVT) const
 14,379,245 ( 0.55%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_erms
 11,073,351 ( 0.42%)  ./malloc/malloc.c:malloc_consolidate
 10,995,013 ( 0.42%)  ???:llvm::InstrEmitter::EmitMachineNode(llvm::SDNode*, bool, bool, llvm::DenseMap<llvm::SDValue, llvm::Register, llvm::DenseMapInfo<llvm::SDValue>, llvm::detail::DenseMapPair<llvm::SDValue, llvm::Register> >&)
 10,978,747 ( 0.42%)  ???:llvm::SelectionDAG::MorphNodeTo(llvm::SDNode*, unsigned int, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>)
 10,876,467 ( 0.42%)  ???:llvm::raw_svector_ostream::write_impl(char const*, unsigned long)
 10,313,048 ( 0.39%)  ???:(anonymous namespace)::SelectionDAGLegalize::LegalizeOp(llvm::SDNode*) [clone .llvm.8386621111310650999]
 10,309,062 ( 0.39%)  ./elf/dl-lookup.c:_dl_lookup_symbol_x
 10,203,908 ( 0.39%)  ???:llvm::DAGTypeLegalizer::run()
  9,517,591 ( 0.36%)  ???:llvm::SelectionDAG::getConstant(llvm::ConstantInt const&, llvm::SDLoc const&, llvm::EVT, bool, bool)
  9,431,910 ( 0.36%)  ???:(anonymous namespace)::DAGCombiner::combine(llvm::SDNode*)
  9,349,382 ( 0.36%)  ???:llvm::SelectionDAG::Legalize()
  8,619,075 ( 0.33%)  ???:(anonymous namespace)::TwoAddressInstructionPass::runOnMachineFunction(llvm::MachineFunction&)
  8,363,130 ( 0.32%)  ???:llvm::TargetRegisterInfo::checkAllSuperRegsMarked(llvm::BitVector const&, llvm::ArrayRef<unsigned short>) const
  8,359,343 ( 0.32%)  ???:llvm::coro::declaresIntrinsics(llvm::Module const&, std::initializer_list<llvm::StringRef>)
  8,163,977 ( 0.31%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe
  8,039,552 ( 0.31%)  ???:(anonymous namespace)::X86MCCodeEmitter::emitPrefixImpl(unsigned int&, llvm::MCInst const&, llvm::MCSubtargetInfo const&, llvm::raw_ostream&) const
  7,891,842 ( 0.30%)  ./malloc/malloc.c:unlink_chunk.constprop.0
  7,632,047 ( 0.29%)  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2
  7,394,569 ( 0.28%)  /usr/home/liquid/rust/worktree-benchmarking/library/core/src/num/uint_macros.rs:<rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<u64>
  7,101,942 ( 0.27%)  ???:(anonymous namespace)::Verifier::visitCallBase(llvm::CallBase&)
  7,047,839 ( 0.27%)  ???:(anonymous namespace)::ScheduleDAGRRList::Schedule() [clone .llvm.6953762222372402862]
  6,612,845 ( 0.25%)  ./malloc/malloc.c:realloc
  6,408,496 ( 0.24%)  ???:multikeySort(llvm::MutableArrayRef<std::pair<llvm::CachedHashStringRef, unsigned long>*>, int)
  6,363,396 ( 0.24%)  ???:llvm::FoldingSetBase::FindNodeOrInsertPos(llvm::FoldingSetNodeID const&, void*&, llvm::FoldingSetBase::FoldingSetInfo const&)
  6,039,618 ( 0.23%)  ???:llvm::TargetRegisterInfo::shouldRealignStack(llvm::MachineFunction const&) const
  5,994,189 ( 0.23%)  ???:(anonymous namespace)::Verifier::verifyFunctionAttrs(llvm::FunctionType*, llvm::AttributeList, llvm::Value const*, bool)
  5,840,311 ( 0.22%)  ???:llvm::ScheduleDAGSDNodes::AddSchedEdges()
  5,705,286 ( 0.22%)  ???:llvm::MCExpr::evaluateAsRelocatableImpl(llvm::MCValue&, llvm::MCAssembler const*, llvm::MCAsmLayout const*, llvm::MCFixup const*, llvm::DenseMap<llvm::MCSection const*, unsigned long, llvm::DenseMapInfo<llvm::MCSection const*>, llvm::detail::DenseMapPair<llvm::MCSection const*, unsigned long> > const*, bool) const
  5,529,726 ( 0.21%)  ???:(anonymous namespace)::PEI::runOnMachineFunction(llvm::MachineFunction&)
  5,440,946 ( 0.21%)  ???:(anonymous namespace)::Verifier::verify(llvm::Function const&) [clone .llvm.4153962086227604281]
  5,423,184 ( 0.21%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::BatchUpdateInfo*)
  5,382,178 ( 0.21%)  ???:llvm::TargetLowering::SimplifyDemandedBits(llvm::SDValue, llvm::APInt const&, llvm::APInt const&, llvm::KnownBits&, llvm::TargetLowering::TargetLoweringOpt&, unsigned int, bool) const
  5,366,392 ( 0.21%)  ./malloc/malloc.c:calloc
  5,281,647 ( 0.20%)  ???:llvm::SelectionDAG::getRegister(unsigned int, llvm::EVT)
  5,276,784 ( 0.20%)  ???:llvm::SelectionDAG::AssignTopologicalOrder()
  5,268,507 ( 0.20%)  ???:llvm::MCContext::getOrCreateSymbol(llvm::Twine const&)
  5,224,899 ( 0.20%)  ???:llvm::FoldingSet<llvm::SDNode>::NodeEquals(llvm::FoldingSetBase const*, llvm::FoldingSetBase::Node*, llvm::FoldingSetNodeID const&, unsigned int, llvm::FoldingSetNodeID&)
  5,224,399 ( 0.20%)  ???:(anonymous namespace)::X86MCInstLower::Lower(llvm::MachineInstr const*, llvm::MCInst&) const
  5,150,308 ( 0.20%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilderMut<rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_hash::<hashbrown::map::equivalent<rustc_middle::ty::sty::TyKind, rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>>::{closure#0}>
  4,960,332 ( 0.19%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/sip128.rs:<rustc_data_structures::sip128::SipHasher128>::short_write_process_buffer::<u64>
  4,857,126 ( 0.19%)  ???:llvm::SelectionDAG::computeKnownBits(llvm::SDValue, llvm::APInt const&, unsigned int) const
  4,845,537 ( 0.19%)  ./elf/dl-lookup.c:do_lookup_x
  4,793,939 ( 0.18%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilder<rustc_span::def_id::LocalDefId, (&rustc_middle::ty::context::TypeckResults, rustc_query_system::dep_graph::graph::DepNodeIndex), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_key_hashed_nocheck::<rustc_span::def_id::LocalDefId>
  4,783,493 ( 0.18%)  ???:llvm::DataLayout::getAlignment(llvm::Type*, bool) const
  4,758,679 ( 0.18%)  ???:(anonymous namespace)::X86MCCodeEmitter::encodeInstruction(llvm::MCInst const&, llvm::raw_ostream&, llvm::SmallVectorImpl<llvm::MCFixup>&, llvm::MCSubtargetInfo const&) const
  4,747,575 ( 0.18%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_sse2_unaligned_erms
  4,614,740 ( 0.18%)  ./malloc/malloc.c:_int_realloc
  4,565,158 ( 0.17%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/caching_source_map_view.rs:<rustc_span::caching_source_map_view::CachingSourceMapView>::span_data_to_lines_and_cols
  4,557,689 ( 0.17%)  ???:llvm::SelectionDAG::getNode(unsigned int, llvm::SDLoc const&, llvm::EVT, llvm::SDValue, llvm::SDValue, llvm::SDNodeFlags)
  4,383,310 ( 0.17%)  /usr/home/liquid/rust/worktree-benchmarking/library/std/src/sys/unix/alloc.rs:__rdl_alloc
  4,251,008 ( 0.16%)  ???:llvm::PassRegistry::enumerateWith(llvm::PassRegistrationListener*)
  4,194,995 ( 0.16%)  ???:(anonymous namespace)::RegAllocFast::markRegUsedInInstr(unsigned short)
  4,141,271 ( 0.16%)  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
  4,070,654 ( 0.16%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_infer/src/infer/mod.rs:<rustc_infer::infer::InferCtxt>::shallow_resolve_ty
  3,990,620 ( 0.15%)  ???:(anonymous namespace)::VectorLegalizer::LegalizeOp(llvm::SDValue) [clone .llvm.3993696295502019106]
  3,966,986 ( 0.15%)  ???:llvm::PMDataManager::removeNotPreservedAnalysis(llvm::Pass*)
  3,964,301 ( 0.15%)  ???:llvm::MCAsmLayout::getSymbolOffset(llvm::MCSymbol const&) const
  3,954,499 ( 0.15%)  ???:llvm::FunctionLoweringInfo::set(llvm::Function const&, llvm::MachineFunction&, llvm::SelectionDAG*)
  3,849,745 ( 0.15%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_mir_dataflow/src/drop_flag_effects.rs:rustc_mir_dataflow::drop_flag_effects::on_all_children_bits::is_terminal_path
  3,718,896 ( 0.14%)  ???:llvm::ScheduleDAGSDNodes::EmitSchedule(llvm::MachineInstrBundleIterator<llvm::MachineInstr, false>&)
  3,718,797 ( 0.14%)  ???:llvm::InstrEmitter::EmitCopyFromReg(llvm::SDNode*, unsigned int, bool, bool, llvm::Register, llvm::DenseMap<llvm::SDValue, llvm::Register, llvm::DenseMapInfo<llvm::SDValue>, llvm::detail::DenseMapPair<llvm::SDValue, llvm::Register> >&)
  3,648,972 ( 0.14%)  ???:llvm::AttributeSetNode::get(llvm::LLVMContext&, llvm::AttrBuilder const&)
  3,568,496 ( 0.14%)  ???:llvm::X86TargetLowering::X86TargetLowering(llvm::X86TargetMachine const&, llvm::X86Subtarget const&)
  3,527,987 ( 0.13%)  ???:llvm::X86TargetMachine::getTargetTransformInfo(llvm::Function const&)
  3,439,553 ( 0.13%)  ???:llvm::SmallPtrSetImplBase::insert_imp_big(void const*)
  3,411,891 ( 0.13%)  ???:(anonymous namespace)::CFIInstrInserter::runOnMachineFunction(llvm::MachineFunction&)
  3,404,024 ( 0.13%)  ???:llvm::StringMapImpl::LookupBucketFor(llvm::StringRef)
  3,393,488 ( 0.13%)  ???:llvm::SelectionDAGISel::SelectAllBasicBlocks(llvm::Function const&)
  3,391,807 ( 0.13%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/lib.rs:<rustc_span::span_encoding::Span as rustc_data_structures::stable_hasher::HashStable<rustc_query_system::ich::hcx::StableHashingContext>>::hash_stable
  3,386,281 ( 0.13%)  ???:llvm::SelectionDAG::getNode(unsigned int, llvm::SDLoc const&, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>)
  3,383,819 ( 0.13%)  ???:llvm::MCAsmLayout::getFragmentOffset(llvm::MCFragment const*) const
  3,299,956 ( 0.13%)  ???:llvm::MachineFunction::CreateMachineInstr(llvm::MCInstrDesc const&, llvm::DebugLoc const&, bool)
  3,297,619 ( 0.13%)  ???:llvm::SelectionDAG::RemoveDeadNodes()
  3,279,448 ( 0.13%)  ???:llvm::DAGTypeLegalizer::AnalyzeNewNode(llvm::SDNode*)
  3,274,985 ( 0.13%)  ???:llvm::MCELFStreamer::emitInstToData(llvm::MCInst const&, llvm::MCSubtargetInfo const&)
  3,217,317 ( 0.12%)  ???:(anonymous namespace)::X86MCCodeEmitter::emitMemModRMByte(llvm::MCInst const&, unsigned int, unsigned int, unsigned long, bool, unsigned long, llvm::raw_ostream&, llvm::SmallVectorImpl<llvm::MCFixup>&, llvm::MCSubtargetInfo const&, bool) const
  3,197,214 ( 0.12%)  ???:llvm::AsmPrinter::emitFunctionBody()
  3,106,212 ( 0.12%)  ???:llvm::MachineFunctionPass::runOnFunction(llvm::Function&)
  3,060,200 ( 0.12%)  ???:llvm::X86FrameLowering::hasFP(llvm::MachineFunction const&) const
  3,055,224 ( 0.12%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
  3,052,960 ( 0.12%)  ???:llvm::TargetLoweringBase::computeRegisterProperties(llvm::TargetRegisterInfo const*)
  3,021,552 ( 0.12%)  ???:llvm::SelectionDAG::clear()
  3,011,967 ( 0.12%)  ???:(anonymous namespace)::RegAllocFast::setPhysReg(llvm::MachineInstr&, llvm::MachineOperand&, unsigned short)
  3,002,043 ( 0.11%)  ???:llvm::X86RegisterInfo::eliminateFrameIndex(llvm::MachineInstrBundleIterator<llvm::MachineInstr, false>, int, unsigned int, llvm::RegScavenger*) const
  2,946,372 ( 0.11%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::raw::RawTable<(rustc_span::def_id::DefId, rustc_query_system::query::plumbing::QueryResult<rustc_middle::dep_graph::dep_node::DepKind>)>>::remove_entry::<hashbrown::map::equivalent_key<rustc_span::def_id::DefId, rustc_span::def_id::DefId, rustc_query_system::query::plumbing::QueryResult<rustc_middle::dep_graph::dep_node::DepKind>>::{closure#0}>
  2,910,809 ( 0.11%)  ???:SetImpliedBits(llvm::FeatureBitset&, llvm::FeatureBitset const&, llvm::ArrayRef<llvm::SubtargetFeatureKV>)
  2,800,137 ( 0.11%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_serialize/src/opaque.rs:<rustc_span::SourceFile as rustc_serialize::serialize::Decodable<rustc_metadata::rmeta::decoder::DecodeContext>>::decode
  2,794,393 ( 0.11%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_borrowck/src/lib.rs:<rustc_borrowck::MirBorrowckCtxt>::access_place
  2,783,550 ( 0.11%)  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long)
  2,756,225 ( 0.11%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilderMut<rustc_middle::ty::context::Interned<rustc_middle::ty::PredicateInner>, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_hash::<hashbrown::map::equivalent<rustc_middle::ty::sty::Binder<rustc_middle::ty::PredicateKind>, rustc_middle::ty::context::Interned<rustc_middle::ty::PredicateInner>>::{closure#0}>
  2,667,371 ( 0.10%)  ???:llvm::MCObjectStreamer::emitInstruction(llvm::MCInst const&, llvm::MCSubtargetInfo const&)
  2,649,103 ( 0.10%)  ???:llvm::FoldingSet<llvm::AttributeImpl>::NodeEquals(llvm::FoldingSetBase const*, llvm::FoldingSetBase::Node*, llvm::FoldingSetNodeID const&, unsigned int, llvm::FoldingSetNodeID&)
  2,632,256 ( 0.10%)  ???:llvm::SmallDenseMap<llvm::SDNode*, llvm::detail::DenseSetEmpty, 32u, llvm::DenseMapInfo<llvm::SDNode*>, llvm::detail::DenseSetPair<llvm::SDNode*> >::grow(unsigned int)
  2,631,065 ( 0.10%)  ???:(anonymous namespace)::RegAllocFast::allocVirtReg(llvm::MachineInstr&, (anonymous namespace)::RegAllocFast::LiveReg&, llvm::Register, bool)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/sip128.rs
--------------------------------------------------------------------------------
Ir                 

-- line 91 ----------------------------------------
        .           // maximum of number bytes needed to fill an 8-byte-sized element on which
        .           // SipHash operates. Note that for variable-sized copies which are known to be
        .           // less than 8 bytes, this function will perform more work than necessary unless
        .           // the compiler is able to optimize the extra work away.
        .           #[inline]
        .           unsafe fn copy_nonoverlapping_small(src: *const u8, dst: *mut u8, count: usize) {
        .               debug_assert!(count <= 8);
        .           
   39,642 ( 0.00%)      if count == 8 {
        .                   ptr::copy_nonoverlapping(src, dst, 8);
        .                   return;
        .               }
        .           
        .               let mut i = 0;
   47,408 ( 0.00%)      if i + 3 < count {
        .                   ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);
        .                   i += 4;
        .               }
        .           
  103,423 ( 0.00%)      if i + 1 < count {
        .                   ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);
   12,266 ( 0.00%)          i += 2
        .               }
        .           
   47,408 ( 0.00%)      if i < count {
   26,946 ( 0.00%)          *dst.add(i) = *src.add(i);
        .                   i += 1;
        .               }
        .           
        .               debug_assert_eq!(i, count);
        .           }
        .           
        .           // # Implementation
        .           //
-- line 124 ----------------------------------------
-- line 201 ----------------------------------------
        .           
        .                   hasher
        .               }
        .           
        .               // A specialized write function for values with size <= 8.
        .               #[inline]
        .               fn short_write<T>(&mut self, x: T) {
        .                   let size = mem::size_of::<T>();
  529,906 ( 0.02%)          let nbuf = self.nbuf;
        .                   debug_assert!(size <= 8);
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .                   debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);
        .           
3,570,206 ( 0.14%)          if nbuf + size < BUFFER_SIZE {
        .                       unsafe {
        .                           // The memcpy call is optimized away because the size is known.
        .                           let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .                           ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);
        .                       }
        .           
1,108,353 ( 0.04%)              self.nbuf = nbuf + size;
        .           
        .                       return;
        .                   }
        .           
  172,752 ( 0.01%)          unsafe { self.short_write_process_buffer(x) }
        .               }
        .           
        .               // A specialized write function for values with size <= 8 that should only
        .               // be called when the write would cause the buffer to fill.
        .               //
        .               // SAFETY: the write of `x` into `self.buf` starting at byte offset
        .               // `self.nbuf` must cause `self.buf` to become fully initialized (and not
        .               // overflow) if it wasn't already.
        .               #[inline(never)]
   53,839 ( 0.00%)      unsafe fn short_write_process_buffer<T>(&mut self, x: T) {
        .                   let size = mem::size_of::<T>();
   53,839 ( 0.00%)          let nbuf = self.nbuf;
        .                   debug_assert!(size <= 8);
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .                   debug_assert!(nbuf + size >= BUFFER_SIZE);
        .                   debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);
        .           
        .                   // Copy first part of input into end of buffer, possibly into spill
        .                   // element. The memcpy call is optimized away because the size is known.
        .                   let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .                   ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);
        .           
        .                   // Process buffer.
        .                   for i in 0..BUFFER_CAPACITY {
  538,390 ( 0.02%)              let elem = self.buf.get_unchecked(i).assume_init().to_le();
  430,712 ( 0.02%)              self.state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut self.state);
  484,551 ( 0.02%)              self.state.v0 ^= elem;
        .                   }
        .           
        .                   // Copy remaining input into start of buffer by copying size - 1
        .                   // elements from spill (at most size - 1 bytes could have overflowed
        .                   // into the spill). The memcpy call is optimized away because the size
        .                   // is known. And the whole copy is optimized away for size == 1.
        .                   let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;
        .                   ptr::copy_nonoverlapping(src, self.buf.as_mut_ptr() as *mut u8, size - 1);
        .           
        .                   // This function should only be called when the write fills the buffer.
        .                   // Therefore, when size == 1, the new `self.nbuf` must be zero. The size
        .                   // is statically known, so the branch is optimized away.
  252,855 ( 0.01%)          self.nbuf = if size == 1 { 0 } else { nbuf + size - BUFFER_SIZE };
  215,356 ( 0.01%)          self.processed += BUFFER_SIZE;
  107,678 ( 0.00%)      }
        .           
        .               // A write function for byte slices.
        .               #[inline]
        .               fn slice_write(&mut self, msg: &[u8]) {
        .                   let length = msg.len();
   10,474 ( 0.00%)          let nbuf = self.nbuf;
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .           
  141,917 ( 0.01%)          if nbuf + length < BUFFER_SIZE {
        .                       unsafe {
        .                           let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .           
   49,334 ( 0.00%)                  if length <= 8 {
        .                               copy_nonoverlapping_small(msg.as_ptr(), dst, length);
        .                           } else {
        .                               // This memcpy is *not* optimized away.
        .                               ptr::copy_nonoverlapping(msg.as_ptr(), dst, length);
        .                           }
        .                       }
        .           
   26,148 ( 0.00%)              self.nbuf = nbuf + length;
        .           
        .                       return;
        .                   }
        .           
   20,846 ( 0.00%)          unsafe { self.slice_write_process_buffer(msg) }
        .               }
        .           
        .               // A write function for byte slices that should only be called when the
        .               // write would cause the buffer to fill.
        .               //
        .               // SAFETY: `self.buf` must be initialized up to the byte offset `self.nbuf`,
        .               // and `msg` must contain enough bytes to initialize the rest of the element
        .               // containing the byte offset `self.nbuf`.
        .               #[inline(never)]
   13,690 ( 0.00%)      unsafe fn slice_write_process_buffer(&mut self, msg: &[u8]) {
        .                   let length = msg.len();
    2,738 ( 0.00%)          let nbuf = self.nbuf;
        .                   debug_assert!(nbuf < BUFFER_SIZE);
        .                   debug_assert!(nbuf + length >= BUFFER_SIZE);
        .           
        .                   // Always copy first part of input into current element of buffer.
        .                   // This function should only be called when the write fills the buffer,
        .                   // so we know that there is enough input to fill the current element.
    8,214 ( 0.00%)          let valid_in_elem = nbuf % ELEM_SIZE;
    2,738 ( 0.00%)          let needed_in_elem = ELEM_SIZE - valid_in_elem;
        .           
        .                   let src = msg.as_ptr();
        .                   let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);
        .                   copy_nonoverlapping_small(src, dst, needed_in_elem);
        .           
        .                   // Process buffer.
        .           
        .                   // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /
        .                   // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.
        .                   // We know that is true, because last step ensured we have a full
        .                   // element in the buffer.
    5,476 ( 0.00%)          let last = nbuf / ELEM_SIZE + 1;
        .           
        .                   for i in 0..last {
   21,247 ( 0.00%)              let elem = self.buf.get_unchecked(i).assume_init().to_le();
   23,985 ( 0.00%)              self.state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut self.state);
   42,494 ( 0.00%)              self.state.v0 ^= elem;
        .                   }
        .           
        .                   // Process the remaining element-sized chunks of input.
        .                   let mut processed = needed_in_elem;
    5,476 ( 0.00%)          let input_left = length - processed;
    2,853 ( 0.00%)          let elems_left = input_left / ELEM_SIZE;
        .                   let extra_bytes_left = input_left % ELEM_SIZE;
        .           
        .                   for _ in 0..elems_left {
    1,270 ( 0.00%)              let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();
    1,270 ( 0.00%)              self.state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut self.state);
    1,270 ( 0.00%)              self.state.v0 ^= elem;
    2,540 ( 0.00%)              processed += ELEM_SIZE;
        .                   }
        .           
        .                   // Copy remaining input into start of buffer.
        .                   let src = msg.as_ptr().add(processed);
        .                   let dst = self.buf.as_mut_ptr() as *mut u8;
        .                   copy_nonoverlapping_small(src, dst, extra_bytes_left);
        .           
    2,738 ( 0.00%)          self.nbuf = extra_bytes_left;
   13,690 ( 0.00%)          self.processed += nbuf + processed;
   16,428 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn finish128(mut self) -> (u64, u64) {
        .                   debug_assert!(self.nbuf < BUFFER_SIZE);
        .           
        .                   // Process full elements in buffer.
   27,657 ( 0.00%)          let last = self.nbuf / ELEM_SIZE;
        .           
        .                   // Since we're consuming self, avoid updating members for a potential
        .                   // performance gain.
   36,876 ( 0.00%)          let mut state = self.state;
        .           
        .                   for i in 0..last {
   23,175 ( 0.00%)              let elem = unsafe { self.buf.get_unchecked(i).assume_init().to_le() };
   23,175 ( 0.00%)              state.v3 ^= elem;
        .                       Sip24Rounds::c_rounds(&mut state);
   23,175 ( 0.00%)              state.v0 ^= elem;
        .                   }
        .           
        .                   // Get remaining partial element.
   18,438 ( 0.00%)          let elem = if self.nbuf % ELEM_SIZE != 0 {
        .                       unsafe {
        .                           // Ensure element is initialized by writing zero bytes. At most
        .                           // `ELEM_SIZE - 1` are required given the above check. It's safe
        .                           // to write this many because we have the spill and we maintain
        .                           // `self.nbuf` such that this write will start before the spill.
        .                           let dst = (self.buf.as_mut_ptr() as *mut u8).add(self.nbuf);
        .                           ptr::write_bytes(dst, 0, ELEM_SIZE - 1);
    8,161 ( 0.00%)                  self.buf.get_unchecked(last).assume_init().to_le()
        .                       }
        .                   } else {
        .                       0
        .                   };
        .           
        .                   // Finalize the hash.
   25,965 ( 0.00%)          let length = self.processed + self.nbuf;
   17,160 ( 0.00%)          let b: u64 = ((length as u64 & 0xff) << 56) | elem;
        .           
    8,580 ( 0.00%)          state.v3 ^= b;
        .                   Sip24Rounds::c_rounds(&mut state);
    8,580 ( 0.00%)          state.v0 ^= b;
        .           
    8,580 ( 0.00%)          state.v2 ^= 0xee;
        .                   Sip24Rounds::d_rounds(&mut state);
   29,328 ( 0.00%)          let _0 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
        .           
   12,160 ( 0.00%)          state.v1 ^= 0xdd;
        .                   Sip24Rounds::d_rounds(&mut state);
   12,160 ( 0.00%)          let _1 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;
        .           
        .                   (_0, _1)
        .               }
        .           }
        .           
        .           impl Hasher for SipHasher128 {
        .               #[inline]
        .               fn write_u8(&mut self, i: u8) {
-- line 414 ----------------------------------------
-- line 471 ----------------------------------------
        .           }
        .           
        .           #[derive(Debug, Clone, Default)]
        .           struct Sip24Rounds;
        .           
        .           impl Sip24Rounds {
        .               #[inline]
        .               fn c_rounds(state: &mut State) {
2,001,989 ( 0.08%)          compress!(state);
2,165,194 ( 0.08%)          compress!(state);
        .               }
        .           
        .               #[inline]
        .               fn d_rounds(state: &mut State) {
   58,640 ( 0.00%)          compress!(state);
   58,640 ( 0.00%)          compress!(state);
   58,640 ( 0.00%)          compress!(state);
   50,064 ( 0.00%)          compress!(state);
        .               }
        .           }

  408,272 ( 0.02%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_data_structures/src/sip128.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_borrowck/src/lib.rs
--------------------------------------------------------------------------------
Ir               

-- line 97 ----------------------------------------
      .           
      .               /// If true, the capture is behind a reference.
      .               by_ref: bool,
      .           }
      .           
      .           const DEREF_PROJECTION: &[PlaceElem<'_>; 1] = &[ProjectionElem::Deref];
      .           
      .           pub fn provide(providers: &mut Providers) {
      4 ( 0.00%)      *providers = Providers {
      .                   mir_borrowck: |tcx, did| {
    523 ( 0.00%)              if let Some(def) = ty::WithOptConstParam::try_lookup(did, tcx) {
      .                           tcx.mir_borrowck_const_arg(def)
      .                       } else {
  2,092 ( 0.00%)                  mir_borrowck(tcx, ty::WithOptConstParam::unknown(did))
      .                       }
      .                   },
      .                   mir_borrowck_const_arg: |tcx, (did, param_did)| {
      .                       mir_borrowck(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })
      .                   },
      .                   ..*providers
      .               };
      1 ( 0.00%)  }
      .           
  5,230 ( 0.00%)  fn mir_borrowck<'tcx>(
      .               tcx: TyCtxt<'tcx>,
      .               def: ty::WithOptConstParam<LocalDefId>,
      .           ) -> &'tcx BorrowCheckResult<'tcx> {
      .               let (input_body, promoted) = tcx.mir_promoted(def);
      .               debug!("run query mir_borrowck: {}", tcx.def_path_str(def.did.to_def_id()));
      .           
  6,799 ( 0.00%)      let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {
      .                   let input_body: &Body<'_> = &input_body.borrow();
      .                   let promoted: &IndexVec<_, _> = &promoted.borrow();
  7,322 ( 0.00%)          do_mir_borrowck(&infcx, input_body, promoted, false).0
  2,092 ( 0.00%)      });
      .               debug!("mir_borrowck done");
      .           
    523 ( 0.00%)      tcx.arena.alloc(opt_closure_req)
  4,184 ( 0.00%)  }
      .           
      .           /// Perform the actual borrow checking.
      .           ///
      .           /// If `return_body_with_facts` is true, then return the body with non-erased
      .           /// region ids on which the borrow checking was performed together with Polonius
      .           /// facts.
 11,506 ( 0.00%)  #[instrument(skip(infcx, input_body, input_promoted), level = "debug")]
      .           fn do_mir_borrowck<'a, 'tcx>(
      .               infcx: &InferCtxt<'a, 'tcx>,
      .               input_body: &Body<'tcx>,
      .               input_promoted: &IndexVec<Promoted, Body<'tcx>>,
      .               return_body_with_facts: bool,
      .           ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {
  5,230 ( 0.00%)      let def = input_body.source.with_opt_param().as_local().unwrap();
      .           
      .               debug!(?def);
      .           
  1,046 ( 0.00%)      let tcx = infcx.tcx;
      .               let param_env = tcx.param_env(def.did);
    523 ( 0.00%)      let id = tcx.hir().local_def_id_to_hir_id(def.did);
      .           
  1,046 ( 0.00%)      let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);
      .               for var_debug_info in &input_body.var_debug_info {
  5,250 ( 0.00%)          if let VarDebugInfoContents::Place(place) = var_debug_info.value {
  2,552 ( 0.00%)              if let Some(local) = place.as_local() {
  3,825 ( 0.00%)                  if let Some(prev_name) = local_names[local] {
      .                               if var_debug_info.name != prev_name {
      .                                   span_bug!(
      .                                       var_debug_info.source_info.span,
      .                                       "local {:?} has many names (`{}` vs `{}`)",
      .                                       local,
      .                                       prev_name,
      .                                       var_debug_info.name
      .                                   );
      .                               }
      .                           }
  3,825 ( 0.00%)                  local_names[local] = Some(var_debug_info.name);
      .                       }
      .                   }
      .               }
      .           
      .               // Gather the upvars of a closure, if any.
  2,092 ( 0.00%)      let tables = tcx.typeck_opt_const_arg(def);
  1,046 ( 0.00%)      if let Some(ErrorReported) = tables.tainted_by_errors {
      .                   infcx.set_tainted_by_errors();
      .               }
  2,092 ( 0.00%)      let upvars: Vec<_> = tables
      .                   .closure_min_captures_flattened(def.did.to_def_id())
      .                   .map(|captured_place| {
      .                       let capture = captured_place.info.capture_kind;
      2 ( 0.00%)              let by_ref = match capture {
      .                           ty::UpvarCapture::ByValue => false,
      .                           ty::UpvarCapture::ByRef(..) => true,
      .                       };
      .                       Upvar { place: captured_place.clone(), by_ref }
      .                   })
      .                   .collect();
      .           
      .               // Replace all regions with fresh inference variables. This
      .               // requires first making our own copy of the MIR. This copy will
      .               // be modified (in place) to contain non-lexical lifetimes. It
      .               // will have a lifetime tied to the inference context.
  1,046 ( 0.00%)      let mut body_owned = input_body.clone();
      .               let mut promoted = input_promoted.clone();
      .               let free_regions =
  1,569 ( 0.00%)          nll::replace_regions_in_mir(infcx, param_env, &mut body_owned, &mut promoted);
      .               let body = &body_owned; // no further changes
      .           
    523 ( 0.00%)      let location_table_owned = LocationTable::new(body);
      .               let location_table = &location_table_owned;
      .           
      .               let mut errors_buffer = Vec::new();
  1,569 ( 0.00%)      let (move_data, move_errors): (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>) =
  3,661 ( 0.00%)          match MoveData::gather_moves(&body, tcx, param_env) {
  3,138 ( 0.00%)              Ok(move_data) => (move_data, Vec::new()),
      .                       Err((move_data, move_errors)) => (move_data, move_errors),
      .                   };
      .               let promoted_errors = promoted
      .                   .iter_enumerated()
    130 ( 0.00%)          .map(|(idx, body)| (idx, MoveData::gather_moves(&body, tcx, param_env)));
      .           
  3,138 ( 0.00%)      let mdpe = MoveDataParamEnv { move_data, param_env };
      .           
  4,184 ( 0.00%)      let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)
    523 ( 0.00%)          .into_engine(tcx, &body)
      .                   .pass_name("borrowck")
      .                   .iterate_to_fixpoint()
      .                   .into_results_cursor(&body);
      .           
  6,276 ( 0.00%)      let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();
      .               let borrow_set =
  5,230 ( 0.00%)          Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));
      .           
  2,615 ( 0.00%)      let use_polonius = return_body_with_facts || infcx.tcx.sess.opts.debugging_opts.polonius;
      .           
      .               // Compute non-lexical lifetimes.
      .               let nll::NllOutput {
  1,569 ( 0.00%)          regioncx,
  2,092 ( 0.00%)          opaque_type_values,
  1,046 ( 0.00%)          polonius_input,
  1,569 ( 0.00%)          polonius_output,
  2,092 ( 0.00%)          opt_closure_req,
  5,230 ( 0.00%)          nll_errors,
  9,414 ( 0.00%)      } = nll::compute_regions(
      .                   infcx,
  8,368 ( 0.00%)          free_regions,
      .                   body,
      .                   &promoted,
      .                   location_table,
      .                   param_env,
      .                   &mut flow_inits,
      .                   &mdpe.move_data,
      .                   &borrow_set,
      .                   &upvars,
      .                   use_polonius,
      .               );
      .           
      .               // Dump MIR results into a file, if that is enabled. This let us
      .               // write unit-tests, as well as helping with debugging.
  1,569 ( 0.00%)      nll::dump_mir_results(infcx, &body, &regioncx, &opt_closure_req);
      .           
      .               // We also have a `#[rustc_regions]` annotation that causes us to dump
      .               // information.
  1,046 ( 0.00%)      nll::dump_annotation(
      .                   infcx,
      .                   &body,
      .                   &regioncx,
      .                   &opt_closure_req,
      .                   &opaque_type_values,
      .                   &mut errors_buffer,
      .               );
      .           
      .               // The various `flow_*` structures can be large. We drop `flow_inits` here
      .               // so it doesn't overlap with the others below. This reduces peak memory
      .               // usage significantly on some benchmarks.
  8,368 ( 0.00%)      drop(flow_inits);
      .           
    523 ( 0.00%)      let regioncx = Rc::new(regioncx);
      .           
  3,138 ( 0.00%)      let flow_borrows = Borrows::new(tcx, body, &regioncx, &borrow_set)
    523 ( 0.00%)          .into_engine(tcx, body)
      .                   .pass_name("borrowck")
      .                   .iterate_to_fixpoint();
  3,138 ( 0.00%)      let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)
    523 ( 0.00%)          .into_engine(tcx, body)
      .                   .pass_name("borrowck")
      .                   .iterate_to_fixpoint();
  3,138 ( 0.00%)      let flow_ever_inits = EverInitializedPlaces::new(tcx, body, &mdpe)
    523 ( 0.00%)          .into_engine(tcx, body)
      .                   .pass_name("borrowck")
      .                   .iterate_to_fixpoint();
      .           
  1,066 ( 0.00%)      let movable_generator = !matches!(
  3,158 ( 0.00%)          tcx.hir().get(id),
      .                   Node::Expr(&hir::Expr {
      .                       kind: hir::ExprKind::Closure(.., Some(hir::Movability::Static)),
      .                       ..
      .                   })
      .               );
      .           
     91 ( 0.00%)      for (idx, move_data_results) in promoted_errors {
      .                   let promoted_body = &promoted[idx];
      .           
     26 ( 0.00%)          if let Err((move_data, move_errors)) = move_data_results {
      .                       let mut promoted_mbcx = MirBorrowckCtxt {
      .                           infcx,
      .                           param_env,
      .                           body: promoted_body,
      .                           move_data: &move_data,
      .                           location_table, // no need to create a real one for the promoted, it is not used
      .                           movable_generator,
      .                           fn_self_span_reported: Default::default(),
-- line 307 ----------------------------------------
-- line 325 ----------------------------------------
      .                       };
      .                       promoted_mbcx.report_move_errors(move_errors);
      .                       errors_buffer = promoted_mbcx.errors_buffer;
      .                   };
      .               }
      .           
      .               let dominators = body.dominators();
      .           
 23,535 ( 0.00%)      let mut mbcx = MirBorrowckCtxt {
      .                   infcx,
      .                   param_env,
      .                   body,
      .                   move_data: &mdpe.move_data,
      .                   location_table,
      .                   movable_generator,
      .                   locals_are_invalidated_at_exit,
      .                   fn_self_span_reported: Default::default(),
      .                   access_place_error_reported: Default::default(),
      .                   reservation_error_reported: Default::default(),
      .                   reservation_warnings: Default::default(),
      .                   move_error_reported: BTreeMap::new(),
      .                   uninitialized_error_reported: Default::default(),
  2,092 ( 0.00%)          errors_buffer,
    523 ( 0.00%)          regioncx: Rc::clone(&regioncx),
      .                   used_mut: Default::default(),
      .                   used_mut_upvars: SmallVec::new(),
    523 ( 0.00%)          borrow_set: Rc::clone(&borrow_set),
  3,138 ( 0.00%)          dominators,
  2,092 ( 0.00%)          upvars,
  2,092 ( 0.00%)          local_names,
      .                   region_names: RefCell::default(),
      .                   next_region_name: RefCell::new(1),
      .                   polonius_output,
      .               };
      .           
      .               // Compute and report region errors, if any.
  1,569 ( 0.00%)      mbcx.report_region_errors(nll_errors);
      .           
      .               let results = BorrowckResults {
  3,138 ( 0.00%)          ever_inits: flow_ever_inits,
  4,184 ( 0.00%)          uninits: flow_uninits,
  5,753 ( 0.00%)          borrows: flow_borrows,
      .               };
      .           
  3,138 ( 0.00%)      mbcx.report_move_errors(move_errors);
      .           
    523 ( 0.00%)      rustc_mir_dataflow::visit_results(
      .                   body,
    523 ( 0.00%)          traversal::reverse_postorder(body).map(|(bb, _)| bb),
      .                   &results,
      .                   &mut mbcx,
      .               );
      .           
      .               // Convert any reservation warnings into lints.
      .               let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);
      .               for (_, (place, span, location, bk, borrow)) in reservation_warnings {
      .                   let mut initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);
-- line 381 ----------------------------------------
-- line 406 ----------------------------------------
      .               // For each non-user used mutable variable, check if it's been assigned from
      .               // a user-declared local. If so, then put that local into the used_mut set.
      .               // Note that this set is expected to be small - only upvars from closures
      .               // would have a chance of erroneously adding non-user-defined mutable vars
      .               // to the set.
      .               let temporary_used_locals: FxHashSet<Local> = mbcx
      .                   .used_mut
      .                   .iter()
    523 ( 0.00%)          .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())
      .                   .cloned()
      .                   .collect();
      .               // For the remaining unused locals that are marked as mutable, we avoid linting any that
      .               // were never initialized. These locals may have been removed as unreachable code; or will be
      .               // linted as unused variables.
      .               let unused_mut_locals =
    523 ( 0.00%)          mbcx.body.mut_vars_iter().filter(|local| !mbcx.used_mut.contains(local)).collect();
  2,092 ( 0.00%)      mbcx.gather_used_muts(temporary_used_locals, unused_mut_locals);
      .           
      .               debug!("mbcx.used_mut: {:?}", mbcx.used_mut);
  2,092 ( 0.00%)      let used_mut = mbcx.used_mut;
    523 ( 0.00%)      for local in mbcx.body.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {
      8 ( 0.00%)          let local_decl = &mbcx.body.local_decls[local];
     48 ( 0.00%)          let lint_root = match &mbcx.body.source_scopes[local_decl.source_info.scope].local_data {
      .                       ClearCrossCrate::Set(data) => data.lint_root,
      .                       _ => continue,
      .                   };
      .           
      .                   // Skip over locals that begin with an underscore or have no name
     24 ( 0.00%)          match mbcx.local_names[local] {
      .                       Some(name) => {
      .                           if name.as_str().starts_with('_') {
      .                               continue;
      .                           }
      .                       }
      .                       None => continue,
      .                   }
      .           
-- line 442 ----------------------------------------
-- line 455 ----------------------------------------
      .                               String::new(),
      .                               Applicability::MachineApplicable,
      .                           )
      .                           .emit();
      .                   })
      .               }
      .           
      .               // Buffer any move errors that we collected and de-duplicated.
  4,707 ( 0.00%)      for (_, (_, diag)) in mbcx.move_error_reported {
      .                   diag.buffer(&mut mbcx.errors_buffer);
      .               }
      .           
    523 ( 0.00%)      if !mbcx.errors_buffer.is_empty() {
      .                   mbcx.errors_buffer.sort_by_key(|diag| diag.sort_span);
      .           
      .                   for diag in mbcx.errors_buffer.drain(..) {
      .                       mbcx.infcx.tcx.sess.diagnostic().emit_diagnostic(&diag);
      .                   }
      .               }
      .           
      .               let result = BorrowCheckResult {
  2,092 ( 0.00%)          concrete_opaque_types: opaque_type_values,
  2,615 ( 0.00%)          closure_requirements: opt_closure_req,
  3,138 ( 0.00%)          used_mut_upvars: mbcx.used_mut_upvars,
      .               };
      .           
  1,046 ( 0.00%)      let body_with_facts = if return_body_with_facts {
      .                   let output_facts = mbcx.polonius_output.expect("Polonius output was not computed");
      .                   Some(Box::new(BodyWithBorrowckFacts {
      .                       body: body_owned,
      .                       input_facts: *polonius_input.expect("Polonius input facts were not generated"),
      .                       output_facts,
      .                       location_table: location_table_owned,
      .                   }))
      .               } else {
      .                   None
      .               };
      .           
      .               debug!("do_mir_borrowck: result = {:#?}", result);
      .           
  7,322 ( 0.00%)      (result, body_with_facts)
  6,276 ( 0.00%)  }
      .           
      .           /// A `Body` with information computed by the borrow checker. This struct is
      .           /// intended to be consumed by compiler consumers.
      .           ///
      .           /// We need to include the MIR body here because the region identifiers must
      .           /// match the ones in the Polonius facts.
      .           pub struct BodyWithBorrowckFacts<'tcx> {
      .               /// A mir body that contains region identifiers.
-- line 504 ----------------------------------------
-- line 608 ----------------------------------------
      .           // Check that:
      .           // 1. assignments are always made to mutable locations (FIXME: does that still really go here?)
      .           // 2. loans made in overlapping scopes do not conflict
      .           // 3. assignments do not affect things loaned out as immutable
      .           // 4. moves do not affect things loaned out in any way
      .           impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {
      .               type FlowState = Flows<'cx, 'tcx>;
      .           
151,056 ( 0.01%)      fn visit_statement_before_primary_effect(
      .                   &mut self,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .                   stmt: &'cx Statement<'tcx>,
      .                   location: Location,
      .               ) {
      .                   debug!("MirBorrowckCtxt::process_statement({:?}, {:?}): {:?}", location, stmt, flow_state);
      .                   let span = stmt.source_info.span;
      .           
      .                   self.check_activations(location, span, flow_state);
      .           
 83,920 ( 0.00%)          match &stmt.kind {
 12,284 ( 0.00%)              StatementKind::Assign(box (lhs, ref rhs)) => {
      .                           self.consume_rvalue(location, (rhs, span), flow_state);
      .           
 24,568 ( 0.00%)                  self.mutate_place(location, (*lhs, span), Shallow(None), flow_state);
      .                       }
    378 ( 0.00%)              StatementKind::FakeRead(box (_, ref place)) => {
      .                           // Read for match doesn't access any memory and is used to
      .                           // assert that a place is safe and live. So we don't have to
      .                           // do any checks here.
      .                           //
      .                           // FIXME: Remove check that the place is initialized. This is
      .                           // needed for now because matches don't have never patterns yet.
      .                           // So this is the only place we prevent
      .                           //      let x: !;
      .                           //      match x {};
      .                           // from compiling.
  1,512 ( 0.00%)                  self.check_if_path_or_subpath_is_moved(
      .                               location,
      .                               InitializationRequiringAction::Use,
  3,402 ( 0.00%)                      (place.as_ref(), span),
      .                               flow_state,
      .                           );
      .                       }
      .                       StatementKind::SetDiscriminant { place, variant_index: _ } => {
      .                           self.mutate_place(location, (**place, span), Shallow(None), flow_state);
      .                       }
      .                       StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {
      .                           ..
-- line 655 ----------------------------------------
-- line 663 ----------------------------------------
      .                       | StatementKind::Coverage(..)
      .                       | StatementKind::AscribeUserType(..)
      .                       | StatementKind::Retag { .. }
      .                       | StatementKind::StorageLive(..) => {
      .                           // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant
      .                           // to borrow check.
      .                       }
      .                       StatementKind::StorageDead(local) => {
 31,122 ( 0.00%)                  self.access_place(
      .                               location,
 57,057 ( 0.00%)                      (Place::from(*local), span),
      .                               (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),
      .                               LocalMutationIsAllowed::Yes,
      .                               flow_state,
      .                           );
      .                       }
      .                   }
134,272 ( 0.01%)      }
      .           
 33,856 ( 0.00%)      fn visit_terminator_before_primary_effect(
      .                   &mut self,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .                   term: &'cx Terminator<'tcx>,
      .                   loc: Location,
      .               ) {
      .                   debug!("MirBorrowckCtxt::process_terminator({:?}, {:?}): {:?}", loc, term, flow_state);
      .                   let span = term.source_info.span;
      .           
      .                   self.check_activations(loc, span, flow_state);
      .           
 21,160 ( 0.00%)          match term.kind {
  1,828 ( 0.00%)              TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {
  1,828 ( 0.00%)                  self.consume_operand(loc, (discr, span), flow_state);
      .                       }
     38 ( 0.00%)              TerminatorKind::Drop { place, target: _, unwind: _ } => {
      .                           debug!(
      .                               "visit_terminator_drop \
      .                                loc: {:?} term: {:?} place: {:?} span: {:?}",
      .                               loc, term, place, span
      .                           );
      .           
    114 ( 0.00%)                  self.access_place(
      .                               loc,
    171 ( 0.00%)                      (place, span),
      .                               (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),
      .                               LocalMutationIsAllowed::Yes,
      .                               flow_state,
      .                           );
      .                       }
      .                       TerminatorKind::DropAndReplace {
      .                           place: drop_place,
      .                           value: ref new_value,
      .                           target: _,
      .                           unwind: _,
      .                       } => {
      .                           self.mutate_place(loc, (drop_place, span), Deep, flow_state);
      .                           self.consume_operand(loc, (new_value, span), flow_state);
      .                       }
      .                       TerminatorKind::Call {
  2,796 ( 0.00%)                  ref func,
      .                           ref args,
      .                           ref destination,
      .                           cleanup: _,
      .                           from_hir_call: _,
      .                           fn_span: _,
      .                       } => {
  7,456 ( 0.00%)                  self.consume_operand(loc, (func, span), flow_state);
      .                           for arg in args {
  8,772 ( 0.00%)                      self.consume_operand(loc, (arg, span), flow_state);
      .                           }
  3,716 ( 0.00%)                  if let Some((dest, _ /*bb*/)) = *destination {
 11,040 ( 0.00%)                      self.mutate_place(loc, (dest, span), Deep, flow_state);
      .                           }
      .                       }
  3,636 ( 0.00%)              TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {
    606 ( 0.00%)                  self.consume_operand(loc, (cond, span), flow_state);
      .                           use rustc_middle::mir::AssertKind;
  1,287 ( 0.00%)                  if let AssertKind::BoundsCheck { ref len, ref index } = *msg {
    250 ( 0.00%)                      self.consume_operand(loc, (len, span), flow_state);
      .                               self.consume_operand(loc, (index, span), flow_state);
      .                           }
      .                       }
      .           
      .                       TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {
      .                           self.consume_operand(loc, (value, span), flow_state);
      .                           self.mutate_place(loc, (resume_arg, span), Deep, flow_state);
      .                       }
-- line 749 ----------------------------------------
-- line 790 ----------------------------------------
      .                       | TerminatorKind::Resume
      .                       | TerminatorKind::Return
      .                       | TerminatorKind::GeneratorDrop
      .                       | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }
      .                       | TerminatorKind::FalseUnwind { real_target: _, unwind: _ } => {
      .                           // no data used, thus irrelevant to borrowck
      .                       }
      .                   }
 30,000 ( 0.00%)      }
      .           
 29,624 ( 0.00%)      fn visit_terminator_after_primary_effect(
      .                   &mut self,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .                   term: &'cx Terminator<'tcx>,
      .                   loc: Location,
      .               ) {
  4,232 ( 0.00%)          let span = term.source_info.span;
      .           
 16,928 ( 0.00%)          match term.kind {
      .                       TerminatorKind::Yield { value: _, resume: _, resume_arg: _, drop: _ } => {
      .                           if self.movable_generator {
      .                               // Look for any active borrows to locals
      .                               let borrow_set = self.borrow_set.clone();
      .                               for i in flow_state.borrows.iter() {
      .                                   let borrow = &borrow_set[i];
      .                                   self.check_for_local_borrow(borrow, span);
      .                               }
-- line 816 ----------------------------------------
-- line 817 ----------------------------------------
      .                           }
      .                       }
      .           
      .                       TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {
      .                           // Returning from the function implicitly kills storage for all locals and statics.
      .                           // Often, the storage will already have been killed by an explicit
      .                           // StorageDead, but we don't always emit those (notably on unwind paths),
      .                           // so this "extra check" serves as a kind of backup.
  1,866 ( 0.00%)                  let borrow_set = self.borrow_set.clone();
      .                           for i in flow_state.borrows.iter() {
      .                               let borrow = &borrow_set[i];
      .                               self.check_for_invalidation_at_exit(loc, borrow, span);
      .                           }
      .                       }
      .           
      .                       TerminatorKind::Abort
      .                       | TerminatorKind::Assert { .. }
-- line 833 ----------------------------------------
-- line 836 ----------------------------------------
      .                       | TerminatorKind::DropAndReplace { .. }
      .                       | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }
      .                       | TerminatorKind::FalseUnwind { real_target: _, unwind: _ }
      .                       | TerminatorKind::Goto { .. }
      .                       | TerminatorKind::SwitchInt { .. }
      .                       | TerminatorKind::Unreachable
      .                       | TerminatorKind::InlineAsm { .. } => {}
      .                   }
 33,856 ( 0.00%)      }
      .           }
      .           
      .           use self::AccessDepth::{Deep, Shallow};
      .           use self::ReadOrWrite::{Activation, Read, Reservation, Write};
      .           
      .           #[derive(Copy, Clone, PartialEq, Eq, Debug)]
      .           enum ArtificialField {
      .               ArrayLength,
-- line 852 ----------------------------------------
-- line 913 ----------------------------------------
      .           /// When checking permissions for a place access, this flag is used to indicate that an immutable
      .           /// local place can be mutated.
      .           //
      .           // FIXME: @nikomatsakis suggested that this flag could be removed with the following modifications:
      .           // - Merge `check_access_permissions()` and `check_if_reassignment_to_immutable_state()`.
      .           // - Split `is_mutable()` into `is_assignable()` (can be directly assigned) and
      .           //   `is_declared_mutable()`.
      .           // - Take flow state into consideration in `is_assignable()` for local variables.
  6,152 ( 0.00%)  #[derive(Copy, Clone, PartialEq, Eq, Debug)]
      .           enum LocalMutationIsAllowed {
      .               Yes,
      .               /// We want use of immutable upvars to cause a "write to immutable upvar"
      .               /// error, not an "reassignment" error.
      .               ExceptUpvars,
      .               No,
      .           }
      .           
-- line 929 ----------------------------------------
-- line 970 ----------------------------------------
      .               }
      .           
      .               /// Checks an access to the given place to see if it is allowed. Examines the set of borrows
      .               /// that are in scope, as well as which paths have been initialized, to ensure that (a) the
      .               /// place is initialized and (b) it is not borrowed in some way that would prevent this
      .               /// access.
      .               ///
      .               /// Returns `true` if an error is reported.
311,744 ( 0.01%)      fn access_place(
      .                   &mut self,
      .                   location: Location,
      .                   place_span: (Place<'tcx>, Span),
      .                   kind: (AccessDepth, ReadOrWrite),
      .                   is_local_mutation_allowed: LocalMutationIsAllowed,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
      .                   let (sd, rw) = kind;
      .           
 77,936 ( 0.00%)          if let Activation(_, borrow_index) = rw {
    214 ( 0.00%)              if self.reservation_error_reported.contains(&place_span.0) {
      .                           debug!(
      .                               "skipping access_place for activation of invalid reservation \
      .                                place: {:?} borrow_index: {:?}",
      .                               place_span.0, borrow_index
      .                           );
      .                           return;
      .                       }
      .                   }
      .           
      .                   // Check is_empty() first because it's the common case, and doing that
      .                   // way we avoid the clone() call.
 19,484 ( 0.00%)          if !self.access_place_error_reported.is_empty()
      .                       && self.access_place_error_reported.contains(&(place_span.0, place_span.1))
      .                   {
      .                       debug!(
      .                           "access_place: suppressing error place_span=`{:?}` kind=`{:?}`",
      .                           place_span, kind
      .                       );
      .                       return;
      .                   }
      .           
116,904 ( 0.00%)          let mutability_error = self.check_access_permissions(
 77,936 ( 0.00%)              place_span,
      .                       rw,
      .                       is_local_mutation_allowed,
      .                       flow_state,
      .                       location,
      .                   );
      .                   let conflict_error =
214,324 ( 0.01%)              self.check_access_for_conflict(location, place_span, sd, rw, flow_state);
      .           
 58,452 ( 0.00%)          if let (Activation(_, borrow_idx), true) = (kind.1, conflict_error) {
      .                       // Suppress this warning when there's an error being emitted for the
      .                       // same borrow: fixing the error is likely to fix the warning.
      .                       self.reservation_warnings.remove(&borrow_idx);
      .                   }
      .           
 58,452 ( 0.00%)          if conflict_error || mutability_error {
      .                       debug!("access_place: logging error place_span=`{:?}` kind=`{:?}`", place_span, kind);
      .           
      .                       self.access_place_error_reported.insert((place_span.0, place_span.1));
      .                   }
155,872 ( 0.01%)      }
      .           
      .               fn check_access_for_conflict(
      .                   &mut self,
      .                   location: Location,
      .                   place_span: (Place<'tcx>, Span),
      .                   sd: AccessDepth,
      .                   rw: ReadOrWrite,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) -> bool {
      .                   debug!(
      .                       "check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})",
      .                       location, place_span, sd, rw,
      .                   );
      .           
 19,484 ( 0.00%)          let mut error_reported = false;
 58,452 ( 0.00%)          let tcx = self.infcx.tcx;
      .                   let body = self.body;
 38,968 ( 0.00%)          let borrow_set = self.borrow_set.clone();
      .           
      .                   // Use polonius output if it has been enabled.
 38,968 ( 0.00%)          let polonius_output = self.polonius_output.clone();
      .                   let borrows_in_scope = if let Some(polonius) = &polonius_output {
      .                       let location = self.location_table.start_index(location);
      .                       Either::Left(polonius.errors_at(location).iter().copied())
      .                   } else {
      .                       Either::Right(flow_state.borrows.iter())
      .                   };
      .           
253,292 ( 0.01%)          each_borrow_involving_path(
      .                       self,
      .                       tcx,
      .                       body,
      .                       location,
116,904 ( 0.00%)              (sd, place_span.0),
      .                       &borrow_set,
116,904 ( 0.00%)              borrows_in_scope,
215,715 ( 0.01%)              |this, borrow_index, borrow| match (rw, borrow.kind) {
      .                           // Obviously an activation is compatible with its own
      .                           // reservation (or even prior activating uses of same
      .                           // borrow); so don't check if they interfere.
      .                           //
      .                           // NOTE: *reservations* do conflict with themselves;
      .                           // thus aren't injecting unsoundenss w/ this check.)
    107 ( 0.00%)                  (Activation(_, activating), _) if activating == borrow_index => {
      .                               debug!(
      .                                   "check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \
      .                                    skipping {:?} b/c activation of same borrow_index",
      .                                   place_span,
      .                                   sd,
      .                                   rw,
      .                                   (borrow_index, borrow),
      .                               );
-- line 1084 ----------------------------------------
-- line 1179 ----------------------------------------
      .                                   }
      .                               }
      .                               Control::Break
      .                           }
      .                       },
      .                   );
      .           
      .                   error_reported
 58,452 ( 0.00%)      }
      .           
 70,620 ( 0.00%)      fn mutate_place(
      .                   &mut self,
      .                   location: Location,
      .                   place_span: (Place<'tcx>, Span),
      .                   kind: AccessDepth,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
      .                   // Write of P[i] or *P requires P init'd.
 63,558 ( 0.00%)          self.check_if_assigned_path_is_moved(location, place_span, flow_state);
      .           
      .                   // Special case: you can assign an immutable local variable
      .                   // (e.g., `x = ...`) so long as it has never been initialized
      .                   // before (at this point in the flow).
  7,062 ( 0.00%)          if let Some(local) = place_span.0.as_local() {
 28,068 ( 0.00%)              if let Mutability::Not = self.body.local_decls[local].mutability {
      .                           // check for reassignments to immutable local variables
      .                           self.check_if_reassignment_to_immutable_state(
      .                               location, local, place_span, flow_state,
      .                           );
      .                           return;
      .                       }
      .                   }
      .           
      .                   // Otherwise, use the normal access permission rules.
 72,444 ( 0.00%)          self.access_place(
      .                       location,
 24,148 ( 0.00%)              place_span,
      .                       (kind, Write(WriteKind::Mutate)),
      .                       LocalMutationIsAllowed::No,
      .                       flow_state,
      .                   );
 56,496 ( 0.00%)      }
      .           
      .               fn consume_rvalue(
      .                   &mut self,
      .                   location: Location,
      .                   (rvalue, span): (&'cx Rvalue<'tcx>, Span),
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
 36,852 ( 0.00%)          match *rvalue {
  2,577 ( 0.00%)              Rvalue::Ref(_ /*rgn*/, bk, place) => {
 10,078 ( 0.00%)                  let access_kind = match bk {
      .                               BorrowKind::Shallow => {
      .                                   (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))
      .                               }
      .                               BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),
      .                               BorrowKind::Unique | BorrowKind::Mut { .. } => {
      .                                   let wk = WriteKind::MutableBorrow(bk);
    230 ( 0.00%)                          if allow_two_phase_borrow(bk) {
      .                                       (Deep, Reservation(wk))
      .                                   } else {
      .                                       (Deep, Write(wk))
      .                                   }
      .                               }
      .                           };
      .           
 18,039 ( 0.00%)                  self.access_place(
      .                               location,
  3,436 ( 0.00%)                      (place, span),
      .                               access_kind,
      .                               LocalMutationIsAllowed::No,
      .                               flow_state,
      .                           );
      .           
      .                           let action = if bk == BorrowKind::Shallow {
      .                               InitializationRequiringAction::MatchOn
      .                           } else {
      .                               InitializationRequiringAction::Borrow
      .                           };
      .           
  6,013 ( 0.00%)                  self.check_if_path_or_subpath_is_moved(
      .                               location,
      .                               action,
  6,013 ( 0.00%)                      (place.as_ref(), span),
      .                               flow_state,
      .                           );
      .                       }
      .           
      .                       Rvalue::AddressOf(mutability, place) => {
      .                           let access_kind = match mutability {
      .                               Mutability::Mut => (
      .                                   Deep,
-- line 1270 ----------------------------------------
-- line 1302 ----------------------------------------
      .                       }
      .           
      .                       Rvalue::Len(place) | Rvalue::Discriminant(place) => {
      .                           let af = match *rvalue {
      .                               Rvalue::Len(..) => Some(ArtificialField::ArrayLength),
      .                               Rvalue::Discriminant(..) => None,
      .                               _ => unreachable!(),
      .                           };
  2,144 ( 0.00%)                  self.access_place(
      .                               location,
    536 ( 0.00%)                      (place, span),
      .                               (Shallow(af), Read(ReadKind::Copy)),
      .                               LocalMutationIsAllowed::No,
      .                               flow_state,
      .                           );
    938 ( 0.00%)                  self.check_if_path_or_subpath_is_moved(
      .                               location,
      .                               InitializationRequiringAction::Use,
    938 ( 0.00%)                      (place.as_ref(), span),
      .                               flow_state,
      .                           );
      .                       }
      .           
      .                       Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))
      .                       | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {
 12,020 ( 0.00%)                  self.consume_operand(location, (operand1, span), flow_state);
  8,414 ( 0.00%)                  self.consume_operand(location, (operand2, span), flow_state);
      .                       }
      .           
      .                       Rvalue::NullaryOp(_op, _ty) => {
      .                           // nullary ops take no dynamic input; no borrowck effect.
      .                       }
      .           
      .                       Rvalue::Aggregate(ref aggregate_kind, ref operands) => {
      .                           // We need to report back the list of mutable upvars that were
      .                           // moved into the closure and subsequently used by the closure,
      .                           // in order to populate our used_mut set.
  1,113 ( 0.00%)                  match **aggregate_kind {
      .                               AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {
      .                                   let BorrowCheckResult { used_mut_upvars, .. } =
     20 ( 0.00%)                              self.infcx.tcx.mir_borrowck(def_id.expect_local());
      .                                   debug!("{:?} used_mut_upvars={:?}", def_id, used_mut_upvars);
      .                                   for field in used_mut_upvars {
      .                                       self.propagate_closure_used_mut_upvar(&operands[field.index()]);
      .                                   }
      .                               }
      .                               AggregateKind::Adt(..)
      .                               | AggregateKind::Array(..)
      .                               | AggregateKind::Tuple { .. } => (),
-- line 1350 ----------------------------------------
-- line 1448 ----------------------------------------
      .                               }
      .                               _ => propagate_closure_used_mut_place(self, place),
      .                           }
      .                       }
      .                       Operand::Constant(..) => {}
      .                   }
      .               }
      .           
113,844 ( 0.00%)      fn consume_operand(
      .                   &mut self,
      .                   location: Location,
      .                   (operand, span): (&'cx Operand<'tcx>, Span),
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
 46,143 ( 0.00%)          match *operand {
  7,860 ( 0.00%)              Operand::Copy(place) => {
      .                           // copy of place: check if this is "copy of frozen path"
      .                           // (FIXME: see check_loans.rs)
 15,720 ( 0.00%)                  self.access_place(
      .                               location,
 13,100 ( 0.00%)                      (place, span),
      .                               (Deep, Read(ReadKind::Copy)),
      .                               LocalMutationIsAllowed::No,
      .                               flow_state,
      .                           );
      .           
      .                           // Finally, check if path was already moved.
      .                           self.check_if_path_or_subpath_is_moved(
      .                               location,
      .                               InitializationRequiringAction::Use,
      .                               (place.as_ref(), span),
      .                               flow_state,
      .                           );
      .                       }
 13,563 ( 0.00%)              Operand::Move(place) => {
      .                           // move of place: check if this is move of already borrowed path
 33,939 ( 0.00%)                  self.access_place(
      .                               location,
 22,605 ( 0.00%)                      (place, span),
      .                               (Deep, Write(WriteKind::Move)),
      .                               LocalMutationIsAllowed::Yes,
      .                               flow_state,
      .                           );
      .           
      .                           // Finally, check if path was already moved.
  3,056 ( 0.00%)                  self.check_if_path_or_subpath_is_moved(
      .                               location,
      .                               InitializationRequiringAction::Use,
  2,292 ( 0.00%)                      (place.as_ref(), span),
      .                               flow_state,
      .                           );
      .                       }
      .                       Operand::Constant(_) => {}
      .                   }
 75,896 ( 0.00%)      }
      .           
      .               /// Checks whether a borrow of this place is invalidated when the function
      .               /// exits
      .               fn check_for_invalidation_at_exit(
      .                   &mut self,
      .                   location: Location,
      .                   borrow: &BorrowData<'tcx>,
      .                   span: Span,
-- line 1510 ----------------------------------------
-- line 1573 ----------------------------------------
      .                       err.buffer(&mut self.errors_buffer);
      .                   }
      .               }
      .           
      .               fn check_activations(&mut self, location: Location, span: Span, flow_state: &Flows<'cx, 'tcx>) {
      .                   // Two-phase borrow support: For each activation that is newly
      .                   // generated at this statement, check if it interferes with
      .                   // another borrow.
 42,032 ( 0.00%)          let borrow_set = self.borrow_set.clone();
 79,939 ( 0.00%)          for &borrow_index in borrow_set.activations_at_location(location) {
      .                       let borrow = &borrow_set[borrow_index];
      .           
      .                       // only mutable borrows should be 2-phase
    535 ( 0.00%)              assert!(match borrow.kind {
      .                           BorrowKind::Shared | BorrowKind::Shallow => false,
      .                           BorrowKind::Unique | BorrowKind::Mut { .. } => true,
      .                       });
      .           
  1,284 ( 0.00%)              self.access_place(
      .                           location,
    642 ( 0.00%)                  (borrow.borrowed_place, span),
    963 ( 0.00%)                  (Deep, Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index)),
      .                           LocalMutationIsAllowed::No,
      .                           flow_state,
      .                       );
      .                       // We do not need to call `check_if_path_or_subpath_is_moved`
      .                       // again, as we already called it when we made the
      .                       // initial reservation.
      .                   }
      .               }
-- line 1602 ----------------------------------------
-- line 1606 ----------------------------------------
      .                   location: Location,
      .                   local: Local,
      .                   place_span: (Place<'tcx>, Span),
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
      .                   debug!("check_if_reassignment_to_immutable_state({:?})", local);
      .           
      .                   // Check if any of the initializiations of `local` have happened yet:
  6,150 ( 0.00%)          if let Some(init_index) = self.is_local_ever_initialized(local, flow_state) {
      .                       // And, if so, report an error.
      .                       let init = &self.move_data.inits[init_index];
      .                       let span = init.span(&self.body);
      .                       self.report_illegal_reassignment(location, place_span, span, place_span.0);
      .                   }
      .               }
      .           
111,241 ( 0.00%)      fn check_if_full_path_is_moved(
      .                   &mut self,
      .                   location: Location,
      .                   desired_action: InitializationRequiringAction,
      .                   place_span: (PlaceRef<'tcx>, Span),
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
      .                   let maybe_uninits = &flow_state.uninits;
      .           
-- line 1630 ----------------------------------------
-- line 1660 ----------------------------------------
      .                   // Therefore, if we seek out the *closest* prefix for which we
      .                   // have a MovePath, that should capture the initialization
      .                   // state for the place scenario.
      .                   //
      .                   // This code covers scenarios 1, 2, and 3.
      .           
      .                   debug!("check_if_full_path_is_moved place: {:?}", place_span.0);
      .                   let (prefix, mpi) = self.move_path_closest_to(place_span.0);
  8,557 ( 0.00%)          if maybe_uninits.contains(mpi) {
      .                       self.report_use_of_moved_or_uninitialized(
      .                           location,
      .                           desired_action,
      .                           (prefix, place_span.0, place_span.1),
      .                           mpi,
      .                       );
      .                   } // Only query longest prefix with a MovePath, not further
      .                   // ancestors; dataflow recurs on children when parents
      .                   // move (to support partial (re)inits).
      .                   //
      .                   // (I.e., querying parents breaks scenario 7; but may want
      .                   // to do such a query based on partial-init feature-gate.)
 68,456 ( 0.00%)      }
      .           
      .               /// Subslices correspond to multiple move paths, so we iterate through the
      .               /// elements of the base array. For each element we check
      .               ///
      .               /// * Does this element overlap with our slice.
      .               /// * Is any part of it uninitialized.
      .               fn check_if_subslice_element_is_moved(
      .                   &mut self,
-- line 1689 ----------------------------------------
-- line 1719 ----------------------------------------
      .                                       return; // don't bother finding other problems.
      .                                   }
      .                               }
      .                           }
      .                       }
      .                   }
      .               }
      .           
 93,632 ( 0.00%)      fn check_if_path_or_subpath_is_moved(
      .                   &mut self,
      .                   location: Location,
      .                   desired_action: InitializationRequiringAction,
      .                   place_span: (PlaceRef<'tcx>, Span),
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
 17,024 ( 0.00%)          let maybe_uninits = &flow_state.uninits;
      .           
      .                   // Bad scenarios:
      .                   //
      .                   // 1. Move of `a.b.c`, use of `a` or `a.b`
      .                   //    partial initialization support, one might have `a.x`
      .                   //    initialized but not `a.b`.
      .                   // 2. All bad scenarios from `check_if_full_path_is_moved`
      .                   //
-- line 1742 ----------------------------------------
-- line 1743 ----------------------------------------
      .                   // OK scenarios:
      .                   //
      .                   // 3. Move of `a.b.c`, use of `a.b.d`
      .                   // 4. Uninitialized `a.x`, initialized `a.b`, use of `a.b`
      .                   // 5. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`
      .                   //    must have been initialized for the use to be sound.
      .                   // 6. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`
      .           
 59,584 ( 0.00%)          self.check_if_full_path_is_moved(location, desired_action, place_span, flow_state);
      .           
  8,764 ( 0.00%)          if let Some((place_base, ProjectionElem::Subslice { from, to, from_end: false })) =
  8,512 ( 0.00%)              place_span.0.last_projection()
      .                   {
      .                       let place_ty = place_base.ty(self.body(), self.infcx.tcx);
      .                       if let ty::Array(..) = place_ty.ty.kind() {
      .                           self.check_if_subslice_element_is_moved(
      .                               location,
      .                               desired_action,
      .                               (place_base, place_span.1),
      .                               maybe_uninits,
-- line 1762 ----------------------------------------
-- line 1772 ----------------------------------------
      .                   //
      .                   // (Distinct from handling of scenarios 1+2+4 above because
      .                   // `place` does not interfere with suffixes of its prefixes,
      .                   // e.g., `a.b.c` does not interfere with `a.b.d`)
      .                   //
      .                   // This code covers scenario 1.
      .           
      .                   debug!("check_if_path_or_subpath_is_moved place: {:?}", place_span.0);
 34,048 ( 0.00%)          if let Some(mpi) = self.move_path_for_place(place_span.0) {
 28,416 ( 0.00%)              let uninit_mpi = self
      .                           .move_data
      .                           .find_in_move_path_or_its_descendants(mpi, |mpi| maybe_uninits.contains(mpi));
      .           
 14,208 ( 0.00%)              if let Some(uninit_mpi) = uninit_mpi {
      .                           self.report_use_of_moved_or_uninitialized(
      .                               location,
      .                               desired_action,
      .                               (place_span.0, place_span.0, place_span.1),
      .                               uninit_mpi,
      .                           );
      .                           return; // don't bother finding other problems.
      .                       }
      .                   }
 68,096 ( 0.00%)      }
      .           
      .               /// Currently MoveData does not store entries for all places in
      .               /// the input MIR. For example it will currently filter out
      .               /// places that are Copy; thus we do not track places of shared
      .               /// reference type. This routine will walk up a place along its
      .               /// prefixes, searching for a foundational place that *is*
      .               /// tracked in the MoveData.
      .               ///
      .               /// An Err result includes a tag indicated why the search failed.
      .               /// Currently this can only occur if the place is built off of a
      .               /// static variable, as we do not track those in the MoveData.
      .               fn move_path_closest_to(&mut self, place: PlaceRef<'tcx>) -> (PlaceRef<'tcx>, MovePathIndex) {
111,241 ( 0.00%)          match self.move_data.rev_lookup.find(place) {
      .                       LookupResult::Parent(Some(mpi)) | LookupResult::Exact(mpi) => {
      .                           (self.move_data.move_paths[mpi].place.as_ref(), mpi)
      .                       }
      .                       LookupResult::Parent(None) => panic!("should have move path for every Local"),
      .                   }
      .               }
      .           
      .               fn move_path_for_place(&mut self, place: PlaceRef<'tcx>) -> Option<MovePathIndex> {
      .                   // If returns None, then there is no move path corresponding
      .                   // to a direct owner of `place` (which means there is nothing
      .                   // that borrowck tracks for its analysis).
      .           
 76,608 ( 0.00%)          match self.move_data.rev_lookup.find(place) {
      .                       LookupResult::Parent(_) => None,
      .                       LookupResult::Exact(mpi) => Some(mpi),
      .                   }
      .               }
      .           
      .               fn check_if_assigned_path_is_moved(
      .                   &mut self,
      .                   location: Location,
      .                   (place, span): (Place<'tcx>, Span),
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) {
      .                   debug!("check_if_assigned_path_is_moved place: {:?}", place);
      .           
      .                   // None case => assigning to `x` does not require `x` be initialized.
     45 ( 0.00%)          for (place_base, elem) in place.iter_projections().rev() {
    180 ( 0.00%)              match elem {
      .                           ProjectionElem::Index(_/*operand*/) |
      .                           ProjectionElem::ConstantIndex { .. } |
      .                           // assigning to P[i] requires P to be valid.
      .                           ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>
      .                           // assigning to (P->variant) is okay if assigning to `P` is okay
      .                           //
      .                           // FIXME: is this true even if P is an adt with a dtor?
      .                           { }
      .           
      .                           // assigning to (*P) requires P to be initialized
      .                           ProjectionElem::Deref => {
    315 ( 0.00%)                      self.check_if_full_path_is_moved(
      .                                   location, InitializationRequiringAction::Use,
    270 ( 0.00%)                          (place_base, span), flow_state);
      .                               // (base initialized; no need to
      .                               // recur further)
      .                               break;
      .                           }
      .           
      .                           ProjectionElem::Subslice { .. } => {
      .                               panic!("we don't allow assignments to subslices, location: {:?}",
      .                                      location);
-- line 1859 ----------------------------------------
-- line 1979 ----------------------------------------
      .                   }
      .               }
      .           
      .               /// Checks the permissions for the given place and read or write kind
      .               ///
      .               /// Returns `true` if an error is reported.
      .               fn check_access_permissions(
      .                   &mut self,
 38,968 ( 0.00%)          (place, span): (Place<'tcx>, Span),
      .                   kind: ReadOrWrite,
      .                   is_local_mutation_allowed: LocalMutationIsAllowed,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .                   location: Location,
      .               ) -> bool {
      .                   debug!(
      .                       "check_access_permissions({:?}, {:?}, is_local_mutation_allowed: {:?})",
      .                       place, kind, is_local_mutation_allowed
      .                   );
      .           
      .                   let error_access;
      .                   let the_place_err;
      .           
295,638 ( 0.01%)          match kind {
      .                       Reservation(WriteKind::MutableBorrow(
      .                           borrow_kind @ (BorrowKind::Unique | BorrowKind::Mut { .. }),
      .                       ))
      .                       | Write(WriteKind::MutableBorrow(
      .                           borrow_kind @ (BorrowKind::Unique | BorrowKind::Mut { .. }),
      .                       )) => {
  1,150 ( 0.00%)                  let is_local_mutation_allowed = match borrow_kind {
      .                               BorrowKind::Unique => LocalMutationIsAllowed::Yes,
      .                               BorrowKind::Mut { .. } => is_local_mutation_allowed,
      .                               BorrowKind::Shared | BorrowKind::Shallow => unreachable!(),
      .                           };
    805 ( 0.00%)                  match self.is_mutable(place.as_ref(), is_local_mutation_allowed) {
      .                               Ok(root_place) => {
      .                                   self.add_used_mut(root_place, flow_state);
      .                                   return false;
      .                               }
      .                               Err(place_err) => {
      .                                   error_access = AccessKind::MutableBorrow;
      .                                   the_place_err = place_err;
      .                               }
      .                           }
      .                       }
      .                       Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {
 42,259 ( 0.00%)                  match self.is_mutable(place.as_ref(), is_local_mutation_allowed) {
      .                               Ok(root_place) => {
      .                                   self.add_used_mut(root_place, flow_state);
      .                                   return false;
      .                               }
      .                               Err(place_err) => {
      .                                   error_access = AccessKind::Mutate;
      .                                   the_place_err = place_err;
      .                               }
-- line 2033 ----------------------------------------
-- line 2041 ----------------------------------------
      .                           | WriteKind::MutableBorrow(BorrowKind::Shallow),
      .                       )
      .                       | Write(
      .                           WriteKind::Move
      .                           | WriteKind::StorageDeadOrDrop
      .                           | WriteKind::MutableBorrow(BorrowKind::Shared)
      .                           | WriteKind::MutableBorrow(BorrowKind::Shallow),
      .                       ) => {
 19,454 ( 0.00%)                  if let (Err(_), true) = (
 68,089 ( 0.00%)                      self.is_mutable(place.as_ref(), is_local_mutation_allowed),
      .                               self.errors_buffer.is_empty(),
      .                           ) {
      .                               // rust-lang/rust#46908: In pure NLL mode this code path should be
      .                               // unreachable, but we use `delay_span_bug` because we can hit this when
      .                               // dereferencing a non-Copy raw pointer *and* have `-Ztreat-err-as-bug`
      .                               // enabled. We don't want to ICE for that case, as other errors will have
      .                               // been emitted (#52262).
      .                               self.infcx.tcx.sess.delay_span_bug(
-- line 2058 ----------------------------------------
-- line 2094 ----------------------------------------
      .                   if previously_initialized {
      .                       self.report_mutability_error(place, span, the_place_err, error_access, location);
      .                       true
      .                   } else {
      .                       false
      .                   }
      .               }
      .           
 35,140 ( 0.00%)      fn is_local_ever_initialized(
      .                   &self,
      .                   local: Local,
      .                   flow_state: &Flows<'cx, 'tcx>,
      .               ) -> Option<InitIndex> {
 21,084 ( 0.00%)          let mpi = self.move_data.rev_lookup.find_local(local);
  7,028 ( 0.00%)          let ii = &self.move_data.init_path_map[mpi];
 30,628 ( 0.00%)          for &index in ii {
 19,088 ( 0.00%)              if flow_state.ever_inits.contains(index) {
      .                           return Some(index);
      .                       }
      .                   }
      .                   None
 28,112 ( 0.00%)      }
      .           
      .               /// Adds the place into the used mutable variables set
 24,608 ( 0.00%)      fn add_used_mut(&mut self, root_place: RootPlace<'tcx>, flow_state: &Flows<'cx, 'tcx>) {
      .                   match root_place {
 18,456 ( 0.00%)              RootPlace { place_local: local, place_projection: [], is_local_mutation_allowed } => {
      .                           // If the local may have been initialized, and it is now currently being
      .                           // mutated, then it is justified to be annotated with the `mut`
      .                           // keyword, since the mutation may be a possible reassignment.
 12,155 ( 0.00%)                  if is_local_mutation_allowed != LocalMutationIsAllowed::Yes
 18,009 ( 0.00%)                      && self.is_local_ever_initialized(local, flow_state).is_some()
      .                           {
      .                               self.used_mut.insert(local);
      .                           }
      .                       }
      .                       RootPlace {
      .                           place_local: _,
      .                           place_projection: _,
      .                           is_local_mutation_allowed: LocalMutationIsAllowed::Yes,
-- line 2133 ----------------------------------------
-- line 2140 ----------------------------------------
      .                           if let Some(field) = self.is_upvar_field_projection(PlaceRef {
      .                               local: place_local,
      .                               projection: place_projection,
      .                           }) {
      .                               self.used_mut_upvars.push(field);
      .                           }
      .                       }
      .                   }
 23,836 ( 0.00%)      }
      .           
      .               /// Whether this value can be written or borrowed mutably.
      .               /// Returns the root place if the place passed in is a projection.
184,932 ( 0.01%)      fn is_mutable(
      .                   &self,
      .                   place: PlaceRef<'tcx>,
      .                   is_local_mutation_allowed: LocalMutationIsAllowed,
      .               ) -> Result<RootPlace<'tcx>, PlaceRef<'tcx>> {
      .                   debug!("is_mutable: place={:?}, is_local...={:?}", place, is_local_mutation_allowed);
 52,302 ( 0.00%)          match place.last_projection() {
      .                       None => {
 15,879 ( 0.00%)                  let local = &self.body.local_decls[place.local];
 47,637 ( 0.00%)                  match local.mutability {
  2,450 ( 0.00%)                      Mutability::Not => match is_local_mutation_allowed {
  7,350 ( 0.00%)                          LocalMutationIsAllowed::Yes => Ok(RootPlace {
      .                                       place_local: place.local,
      .                                       place_projection: place.projection,
      .                                       is_local_mutation_allowed: LocalMutationIsAllowed::Yes,
      .                                   }),
      .                                   LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {
      .                                       place_local: place.local,
      .                                       place_projection: place.projection,
      .                                       is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,
      .                                   }),
      .                                   LocalMutationIsAllowed::No => Err(place),
      .                               },
 29,308 ( 0.00%)                      Mutability::Mut => Ok(RootPlace {
      .                                   place_local: place.local,
      .                                   place_projection: place.projection,
      .                                   is_local_mutation_allowed,
      .                               }),
      .                           }
      .                       }
      .                       Some((place_base, elem)) => {
  2,799 ( 0.00%)                  match elem {
      .                               ProjectionElem::Deref => {
    298 ( 0.00%)                          let base_ty = place_base.ty(self.body(), self.infcx.tcx).ty;
      .           
      .                                   // Check the kind of deref to decide
    894 ( 0.00%)                          match base_ty.kind() {
      .                                       ty::Ref(_, _, mutbl) => {
    298 ( 0.00%)                                  match mutbl {
      .                                               // Shared borrowed data is never mutable
      .                                               hir::Mutability::Not => Err(place),
      .                                               // Mutably borrowed data is mutable, but only if we have a
      .                                               // unique path to the `&mut`
      .                                               hir::Mutability::Mut => {
    298 ( 0.00%)                                          let mode = match self.is_upvar_field_projection(place) {
      .                                                       Some(field) if self.upvars[field.index()].by_ref => {
      .                                                           is_local_mutation_allowed
      .                                                       }
      .                                                       _ => LocalMutationIsAllowed::Yes,
      .                                                   };
      .           
    894 ( 0.00%)                                          self.is_mutable(place_base, mode)
      .                                               }
      .                                           }
      .                                       }
      .                                       ty::RawPtr(tnm) => {
      .                                           match tnm.mutbl {
      .                                               // `*const` raw pointers are not mutable
      .                                               hir::Mutability::Not => Err(place),
      .                                               // `*mut` raw pointers are always mutable, regardless of
-- line 2211 ----------------------------------------
-- line 2228 ----------------------------------------
      .                               // All other projections are owned by their base path, so mutable if
      .                               // base path is mutable
      .                               ProjectionElem::Field(..)
      .                               | ProjectionElem::Index(..)
      .                               | ProjectionElem::ConstantIndex { .. }
      .                               | ProjectionElem::Subslice { .. }
      .                               | ProjectionElem::Downcast(..) => {
      .                                   let upvar_field_projection = self.is_upvar_field_projection(place);
  1,568 ( 0.00%)                          if let Some(field) = upvar_field_projection {
      .                                       let upvar = &self.upvars[field.index()];
      .                                       debug!(
      .                                           "is_mutable: upvar.mutability={:?} local_mutation_is_allowed={:?} \
      .                                            place={:?}, place_base={:?}",
      .                                           upvar, is_local_mutation_allowed, place, place_base
      .                                       );
      .                                       match (upvar.place.mutability, is_local_mutation_allowed) {
      .                                           (
-- line 2244 ----------------------------------------
-- line 2285 ----------------------------------------
      .                                       }
      .                                   } else {
      .                                       self.is_mutable(place_base, is_local_mutation_allowed)
      .                                   }
      .                               }
      .                           }
      .                       }
      .                   }
134,496 ( 0.01%)      }
      .           
      .               /// If `place` is a field projection, and the field is being projected from a closure type,
      .               /// then returns the index of the field being projected. Note that this closure will always
      .               /// be `self` in the current MIR, because that is the only time we directly access the fields
      .               /// of a closure type.
      .               fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {
  8,397 ( 0.00%)          path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())
      .               }
      .           }
      .           
      .           /// The degree of overlap between 2 places for borrow-checking.
      .           enum Overlap {
      .               /// The places might partially overlap - in this case, we give
      .               /// up and say that they might conflict. This occurs when
      .               /// different fields of a union are borrowed. For example,
-- line 2308 ----------------------------------------

695,685 ( 0.03%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_borrowck/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_mir_dataflow/src/drop_flag_effects.rs
--------------------------------------------------------------------------------
Ir                 

-- line 48 ----------------------------------------
        .           //
        .           // FIXME: we have to do something for moving slice patterns.
        .           fn place_contents_drop_state_cannot_differ<'tcx>(
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               place: mir::Place<'tcx>,
        .           ) -> bool {
        .               let ty = place.ty(body, tcx).ty;
  722,436 ( 0.03%)      match ty.kind() {
        .                   ty::Array(..) => {
        .                       debug!(
        .                           "place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false",
        .                           place, ty
        .                       );
        .                       false
        .                   }
        .                   ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {
        .                       debug!(
        .                           "place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true",
        .                           place, ty
        .                       );
        .                       true
        .                   }
  236,889 ( 0.01%)          ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {
        .                       debug!(
        .                           "place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true",
        .                           place, ty
        .                       );
        .                       true
        .                   }
        .                   _ => false,
        .               }
-- line 79 ----------------------------------------
-- line 83 ----------------------------------------
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               move_data: &MoveData<'tcx>,
        .               lookup_result: LookupResult,
        .               each_child: F,
        .           ) where
        .               F: FnMut(MovePathIndex),
        .           {
   20,108 ( 0.00%)      match lookup_result {
        .                   LookupResult::Parent(..) => {
        .                       // access to untracked value - do not touch children
        .                   }
        .                   LookupResult::Exact(e) => on_all_children_bits(tcx, body, move_data, e, each_child),
        .               }
        .           }
        .           
        .           pub fn on_all_children_bits<'tcx, F>(
-- line 99 ----------------------------------------
-- line 100 ----------------------------------------
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               move_data: &MoveData<'tcx>,
        .               move_path_index: MovePathIndex,
        .               mut each_child: F,
        .           ) where
        .               F: FnMut(MovePathIndex),
        .           {
1,015,256 ( 0.04%)      fn is_terminal_path<'tcx>(
        .                   tcx: TyCtxt<'tcx>,
        .                   body: &Body<'tcx>,
        .                   move_data: &MoveData<'tcx>,
        .                   path: MovePathIndex,
        .               ) -> bool {
  253,814 ( 0.01%)          place_contents_drop_state_cannot_differ(tcx, body, move_data.move_paths[path].place)
1,015,256 ( 0.04%)      }
        .           
1,159,695 ( 0.04%)      fn on_all_children_bits<'tcx, F>(
        .                   tcx: TyCtxt<'tcx>,
        .                   body: &Body<'tcx>,
        .                   move_data: &MoveData<'tcx>,
        .                   move_path_index: MovePathIndex,
        .                   each_child: &mut F,
        .               ) where
        .                   F: FnMut(MovePathIndex),
        .               {
   48,501 ( 0.00%)          each_child(move_path_index);
        .           
  888,368 ( 0.03%)          if is_terminal_path(tcx, body, move_data, move_path_index) {
        .                       return;
        .                   }
        .           
  107,404 ( 0.00%)          let mut next_child_index = move_data.move_paths[move_path_index].first_child;
  231,436 ( 0.01%)          while let Some(child_index) = next_child_index {
   33,096 ( 0.00%)              on_all_children_bits(tcx, body, move_data, child_index, each_child);
    5,516 ( 0.00%)              next_child_index = move_data.move_paths[child_index].next_sibling;
        .                   }
  978,468 ( 0.04%)      }
  723,181 ( 0.03%)      on_all_children_bits(tcx, body, move_data, move_path_index, &mut each_child);
        .           }
        .           
        .           pub fn on_all_drop_children_bits<'tcx, F>(
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               ctxt: &MoveDataParamEnv<'tcx>,
        .               path: MovePathIndex,
        .               mut each_child: F,
        .           ) where
        .               F: FnMut(MovePathIndex),
        .           {
      341 ( 0.00%)      on_all_children_bits(tcx, body, &ctxt.move_data, path, |child| {
      160 ( 0.00%)          let place = &ctxt.move_data.move_paths[path].place;
       40 ( 0.00%)          let ty = place.ty(body, tcx).ty;
        .                   debug!("on_all_drop_children_bits({:?}, {:?} : {:?})", path, place, ty);
        .           
        .                   let erased_ty = tcx.erase_regions(ty);
      242 ( 0.00%)          if erased_ty.needs_drop(tcx, ctxt.param_env) {
       40 ( 0.00%)              each_child(child);
        .                   } else {
        .                       debug!("on_all_drop_children_bits - skipping")
        .                   }
        .               })
        .           }
        .           
   35,626 ( 0.00%)  pub fn drop_flag_effects_for_function_entry<'tcx, F>(
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               ctxt: &MoveDataParamEnv<'tcx>,
        .               mut callback: F,
        .           ) where
        .               F: FnMut(MovePathIndex, DropFlagState),
        .           {
        .               let move_data = &ctxt.move_data;
    3,190 ( 0.00%)      for arg in body.args_iter() {
    9,084 ( 0.00%)          let place = mir::Place::from(arg);
   13,626 ( 0.00%)          let lookup_result = move_data.rev_lookup.find(place.as_ref());
        .                   on_lookup_result_bits(tcx, body, move_data, lookup_result, |mpi| {
    4,542 ( 0.00%)              callback(mpi, DropFlagState::Present)
        .                   });
        .               }
   25,520 ( 0.00%)  }
        .           
1,471,221 ( 0.06%)  pub fn drop_flag_effects_for_location<'tcx, F>(
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               ctxt: &MoveDataParamEnv<'tcx>,
        .               loc: Location,
        .               mut callback: F,
        .           ) where
        .               F: FnMut(MovePathIndex, DropFlagState),
        .           {
        .               let move_data = &ctxt.move_data;
        .               debug!("drop_flag_effects_for_location({:?})", loc);
        .           
        .               // first, move out of the RHS
   63,048 ( 0.00%)      for mi in &move_data.loc_map[loc] {
  263,130 ( 0.01%)          let path = mi.move_path_index(move_data);
        .                   debug!("moving out of path {:?}", move_data.move_paths[path]);
        .           
   68,247 ( 0.00%)          on_all_children_bits(tcx, body, move_data, path, |mpi| callback(mpi, DropFlagState::Absent))
        .               }
        .           
        .               debug!("drop_flag_effects: assignment for location({:?})", loc);
        .           
   48,501 ( 0.00%)      for_location_inits(tcx, body, move_data, loc, |mpi| callback(mpi, DropFlagState::Present));
1,139,624 ( 0.04%)  }
        .           
        .           pub fn for_location_inits<'tcx, F>(
        .               tcx: TyCtxt<'tcx>,
        .               body: &Body<'tcx>,
        .               move_data: &MoveData<'tcx>,
        .               loc: Location,
        .               mut callback: F,
        .           ) where
        .               F: FnMut(MovePathIndex),
        .           {
   63,048 ( 0.00%)      for ii in &move_data.init_loc_map[loc] {
  197,892 ( 0.01%)          let init = move_data.inits[*ii];
  111,810 ( 0.00%)          match init.kind {
        .                       InitKind::Deep => {
        .                           let path = init.path;
        .           
        .                           on_all_children_bits(tcx, body, move_data, path, &mut callback)
        .                       }
        .                       InitKind::Shallow => {
        .                           let mpi = init.path;
        .                           callback(mpi);
-- line 226 ----------------------------------------
-- line 230 ----------------------------------------
        .               }
        .           }
        .           
        .           /// Calls `handle_inactive_variant` for each descendant move path of `enum_place` that contains a
        .           /// `Downcast` to a variant besides the `active_variant`.
        .           ///
        .           /// NOTE: If there are no move paths corresponding to an inactive variant,
        .           /// `handle_inactive_variant` will not be called for that variant.
   11,664 ( 0.00%)  pub(crate) fn on_all_inactive_variants<'tcx>(
        .               tcx: TyCtxt<'tcx>,
        .               body: &mir::Body<'tcx>,
        .               move_data: &MoveData<'tcx>,
        .               enum_place: mir::Place<'tcx>,
        .               active_variant: VariantIdx,
        .               mut handle_inactive_variant: impl FnMut(MovePathIndex),
        .           ) {
    4,860 ( 0.00%)      let enum_mpi = match move_data.rev_lookup.find(enum_place.as_ref()) {
        .                   LookupResult::Exact(mpi) => mpi,
        .                   LookupResult::Parent(_) => return,
        .               };
        .           
        .               let enum_path = &move_data.move_paths[enum_mpi];
    2,204 ( 0.00%)      for (variant_mpi, variant_path) in enum_path.children(&move_data.move_paths) {
        .                   // Because of the way we build the `MoveData` tree, each child should have exactly one more
        .                   // projection than `enum_place`. This additional projection must be a downcast since the
        .                   // base is an enum.
        8 ( 0.00%)          let (downcast, base_proj) = variant_path.place.projection.split_last().unwrap();
       32 ( 0.00%)          assert_eq!(enum_place.projection.len(), base_proj.len());
        .           
       24 ( 0.00%)          let variant_idx = match *downcast {
        .                       mir::ProjectionElem::Downcast(_, idx) => idx,
        .                       _ => unreachable!(),
        .                   };
        .           
        8 ( 0.00%)          if variant_idx != active_variant {
        .                       on_all_children_bits(tcx, body, move_data, variant_mpi, |mpi| {
        8 ( 0.00%)                  handle_inactive_variant(mpi)
        .                       });
        .                   }
        .               }
    7,776 ( 0.00%)  }

  821,877 ( 0.03%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_mir_dataflow/src/drop_flag_effects.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/caching_source_map_view.rs
--------------------------------------------------------------------------------
Ir               

-- line 27 ----------------------------------------
      .           impl CacheEntry {
      .               #[inline]
      .               fn update(
      .                   &mut self,
      .                   new_file_and_idx: Option<(Lrc<SourceFile>, usize)>,
      .                   pos: BytePos,
      .                   time_stamp: usize,
      .               ) {
 12,672 ( 0.00%)          if let Some((file, file_idx)) = new_file_and_idx {
  5,835 ( 0.00%)              self.file = file;
  8,454 ( 0.00%)              self.file_index = file_idx;
      .                   }
      .           
  5,309 ( 0.00%)          let line_index = self.file.lookup_line(pos).unwrap();
      .                   let line_bounds = self.file.line_bounds(line_index);
 20,144 ( 0.00%)          self.line_number = line_index + 1;
 29,452 ( 0.00%)          self.line = line_bounds;
      .                   self.touch(time_stamp);
      .               }
      .           
      .               #[inline]
      .               fn touch(&mut self, time_stamp: usize) {
115,512 ( 0.00%)          self.time_stamp = time_stamp;
      .               }
      .           }
      .           
      .           #[derive(Clone)]
      .           pub struct CachingSourceMapView<'sm> {
      .               source_map: &'sm SourceMap,
      .               line_cache: [CacheEntry; 3],
      .               time_stamp: usize,
      .           }
      .           
      .           impl<'sm> CachingSourceMapView<'sm> {
  3,738 ( 0.00%)      pub fn new(source_map: &'sm SourceMap) -> CachingSourceMapView<'sm> {
      .                   let files = source_map.files();
  1,869 ( 0.00%)          let first_file = files[0].clone();
      .                   let entry = CacheEntry {
      .                       time_stamp: 0,
      .                       line_number: 0,
      .                       line: BytePos(0)..BytePos(0),
      .                       file: first_file,
      .                       file_index: 0,
      .                   };
      .           
  9,345 ( 0.00%)          CachingSourceMapView {
      .                       source_map,
 13,083 ( 0.00%)              line_cache: [entry.clone(), entry.clone(), entry],
      .                       time_stamp: 0,
      .                   }
  7,476 ( 0.00%)      }
      .           
      .               pub fn byte_pos_to_line_and_col(
      .                   &mut self,
      .                   pos: BytePos,
      .               ) -> Option<(Lrc<SourceFile>, usize, BytePos)> {
      .                   self.time_stamp += 1;
      .           
      .                   // Check if the position is in one of the cached lines
-- line 85 ----------------------------------------
-- line 106 ----------------------------------------
      .                   };
      .           
      .                   let cache_entry = &mut self.line_cache[oldest];
      .                   cache_entry.update(new_file_and_idx, pos, self.time_stamp);
      .           
      .                   Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))
      .               }
      .           
435,792 ( 0.02%)      pub fn span_data_to_lines_and_cols(
      .                   &mut self,
      .                   span_data: &SpanData,
      .               ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {
249,024 ( 0.01%)          self.time_stamp += 1;
      .           
      .                   // Check if lo and hi are in the cached lines.
 62,256 ( 0.00%)          let lo_cache_idx = self.cache_entry_index(span_data.lo);
 62,256 ( 0.00%)          let hi_cache_idx = self.cache_entry_index(span_data.hi);
      .           
106,836 ( 0.00%)          if lo_cache_idx != -1 && hi_cache_idx != -1 {
      .                       // Cache hit for span lo and hi. Check if they belong to the same file.
      .                       let result = {
106,512 ( 0.00%)                  let lo = &self.line_cache[lo_cache_idx as usize];
      .                           let hi = &self.line_cache[hi_cache_idx as usize];
      .           
319,536 ( 0.01%)                  if lo.file_index != hi.file_index {
      .                               return None;
      .                           }
      .           
      .                           (
106,512 ( 0.00%)                      lo.file.clone(),
      .                               lo.line_number,
      .                               span_data.lo - lo.line.start,
 53,256 ( 0.00%)                      hi.line_number,
      .                               span_data.hi - hi.line.start,
      .                           )
      .                       };
      .           
 53,256 ( 0.00%)              self.line_cache[lo_cache_idx as usize].touch(self.time_stamp);
 53,256 ( 0.00%)              self.line_cache[hi_cache_idx as usize].touch(self.time_stamp);
      .           
213,024 ( 0.01%)              return Some(result);
      .                   }
      .           
      .                   // No cache hit or cache hit for only one of span lo and hi.
 17,676 ( 0.00%)          let oldest = if lo_cache_idx != -1 || hi_cache_idx != -1 {
      .                       let avoid_idx = if lo_cache_idx != -1 { lo_cache_idx } else { hi_cache_idx };
      .                       self.oldest_cache_entry_index_avoid(avoid_idx as usize)
      .                   } else {
      .                       self.oldest_cache_entry_index()
      .                   };
      .           
      .                   // If the entry doesn't point to the correct file, get the new file and index.
      .                   // Return early if the file containing beginning of span doesn't contain end of span.
 71,004 ( 0.00%)          let new_file_and_idx = if !file_contains(&self.line_cache[oldest].file, span_data.lo) {
 18,455 ( 0.00%)              let new_file_and_idx = self.file_for_position(span_data.lo)?;
 22,146 ( 0.00%)              if !file_contains(&new_file_and_idx.0, span_data.hi) {
      .                           return None;
      .                       }
      .           
 14,764 ( 0.00%)              Some(new_file_and_idx)
      .                   } else {
      .                       let file = &self.line_cache[oldest].file;
 15,927 ( 0.00%)              if !file_contains(&file, span_data.hi) {
      .                           return None;
      .                       }
      .           
 15,927 ( 0.00%)              None
      .                   };
      .           
      .                   // Update the cache entries.
 45,000 ( 0.00%)          let (lo_idx, hi_idx) = match (lo_cache_idx, hi_cache_idx) {
      .                       // Oldest cache entry is for span_data.lo line.
      .                       (-1, -1) => {
      .                           let lo = &mut self.line_cache[oldest];
      .                           lo.update(new_file_and_idx, span_data.lo, self.time_stamp);
      .           
 21,006 ( 0.00%)                  if !lo.line.contains(&span_data.hi) {
      .                               let new_file_and_idx = Some((lo.file.clone(), lo.file_index));
      .                               let next_oldest = self.oldest_cache_entry_index_avoid(oldest);
      .                               let hi = &mut self.line_cache[next_oldest];
      .                               hi.update(new_file_and_idx, span_data.hi, self.time_stamp);
      .                               (oldest, next_oldest)
      .                           } else {
      .                               (oldest, oldest)
      .                           }
      .                       }
      .                       // Oldest cache entry is for span_data.lo line.
      .                       (-1, _) => {
      .                           let lo = &mut self.line_cache[oldest];
      .                           lo.update(new_file_and_idx, span_data.lo, self.time_stamp);
    324 ( 0.00%)                  let hi = &mut self.line_cache[hi_cache_idx as usize];
    486 ( 0.00%)                  hi.touch(self.time_stamp);
      .                           (oldest, hi_cache_idx as usize)
      .                       }
      .                       // Oldest cache entry is for span_data.hi line.
      .                       (_, -1) => {
      .                           let hi = &mut self.line_cache[oldest];
  1,836 ( 0.00%)                  hi.update(new_file_and_idx, span_data.hi, self.time_stamp);
  3,672 ( 0.00%)                  let lo = &mut self.line_cache[lo_cache_idx as usize];
  7,344 ( 0.00%)                  lo.touch(self.time_stamp);
      .                           (lo_cache_idx as usize, oldest)
      .                       }
      .                       _ => {
      .                           panic!();
      .                       }
      .                   };
      .           
      .                   let lo = &self.line_cache[lo_idx];
      .                   let hi = &self.line_cache[hi_idx];
      .           
      .                   // Span lo and hi may equal line end when last line doesn't
      .                   // end in newline, hence the inclusive upper bounds below.
 18,000 ( 0.00%)          assert!(span_data.lo >= lo.line.start);
  9,000 ( 0.00%)          assert!(span_data.lo <= lo.line.end);
 18,000 ( 0.00%)          assert!(span_data.hi >= hi.line.start);
  9,000 ( 0.00%)          assert!(span_data.hi <= hi.line.end);
 45,000 ( 0.00%)          assert!(lo.file.contains(span_data.lo));
 27,000 ( 0.00%)          assert!(lo.file.contains(span_data.hi));
 27,000 ( 0.00%)          assert_eq!(lo.file_index, hi.file_index);
      .           
 27,000 ( 0.00%)          Some((
  9,000 ( 0.00%)              lo.file.clone(),
      .                       lo.line_number,
      .                       span_data.lo - lo.line.start,
  9,000 ( 0.00%)              hi.line_number,
      .                       span_data.hi - hi.line.start,
      .                   ))
560,304 ( 0.02%)      }
      .           
      .               fn cache_entry_index(&self, pos: BytePos) -> isize {
      .                   for (idx, cache_entry) in self.line_cache.iter().enumerate() {
641,309 ( 0.02%)              if cache_entry.line.contains(&pos) {
      .                           return idx as isize;
      .                       }
      .                   }
      .           
      .                   -1
      .               }
      .           
      .               fn oldest_cache_entry_index(&self) -> usize {
      .                   let mut oldest = 0;
      .           
      .                   for idx in 1..self.line_cache.len() {
 42,012 ( 0.00%)              if self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp {
      .                           oldest = idx;
      .                       }
      .                   }
      .           
      .                   oldest
      .               }
      .           
      .               fn oldest_cache_entry_index_avoid(&self, avoid_idx: usize) -> usize {
      .                   let mut oldest = if avoid_idx != 0 { 0 } else { 1 };
      .           
      .                   for idx in 0..self.line_cache.len() {
 18,192 ( 0.00%)              if idx != avoid_idx
  9,109 ( 0.00%)                  && self.line_cache[idx].time_stamp < self.line_cache[oldest].time_stamp
      .                       {
      .                           oldest = idx;
      .                       }
      .                   }
      .           
      .                   oldest
      .               }
      .           
 18,455 ( 0.00%)      fn file_for_position(&self, pos: BytePos) -> Option<(Lrc<SourceFile>, usize)> {
  3,691 ( 0.00%)          if !self.source_map.files().is_empty() {
  7,382 ( 0.00%)              let file_idx = self.source_map.lookup_source_file_idx(pos);
      .                       let file = &self.source_map.files()[file_idx];
      .           
 29,528 ( 0.00%)              if file_contains(file, pos) {
      .                           return Some((file.clone(), file_idx));
      .                       }
      .                   }
      .           
      .                   None
 18,455 ( 0.00%)      }
      .           }
      .           
      .           #[inline]
      .           fn file_contains(file: &SourceFile, pos: BytePos) -> bool {
      .               // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position
      .               // one past the end of a file to belong to it. Normally, that's what we want. But for the
      .               // purposes of converting a byte position to a line and column number, we can't come up with a
      .               // line and column number if the file is empty, because an empty file doesn't contain any
-- line 290 ----------------------------------------

829,153 ( 0.03%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/caching_source_map_view.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/library/std/src/sys/unix/alloc.rs
--------------------------------------------------------------------------------
Ir                 

-- line 5 ----------------------------------------
        .           #[stable(feature = "alloc_system_type", since = "1.28.0")]
        .           unsafe impl GlobalAlloc for System {
        .               #[inline]
        .               unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        .                   // jemalloc provides alignment less than MIN_ALIGN for small allocations.
        .                   // So only rely on MIN_ALIGN if size >= align.
        .                   // Also see <https://github.com/rust-lang/rust/issues/45955> and
        .                   // <https://github.com/rust-lang/rust/issues/62251#issuecomment-507580914>.
2,504,746 ( 0.10%)          if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {
1,878,558 ( 0.07%)              libc::malloc(layout.size()) as *mut u8
        .                   } else {
        .                       #[cfg(target_os = "macos")]
        .                       {
        .                           if layout.align() > (1 << 31) {
        .                               return ptr::null_mut();
        .                           }
        .                       }
        .                       aligned_malloc(&layout)
        .                   }
        .               }
        .           
        .               #[inline]
        .               unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        .                   // See the comment above in `alloc` for why this check looks the way it does.
  192,488 ( 0.01%)          if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {
  288,732 ( 0.01%)              libc::calloc(layout.size(), 1) as *mut u8
        .                   } else {
        .                       let ptr = self.alloc(layout);
        .                       if !ptr.is_null() {
        .                           ptr::write_bytes(ptr, 0, layout.size());
        .                       }
        .                       ptr
        .                   }
        .               }
        .           
        .               #[inline]
        .               unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {
  674,298 ( 0.03%)          libc::free(ptr as *mut libc::c_void)
        .               }
        .           
        .               #[inline]
        .               unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
  267,756 ( 0.01%)          if layout.align() <= MIN_ALIGN && layout.align() <= new_size {
  535,512 ( 0.02%)              libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8
        .                   } else {
        .                       realloc_fallback(self, ptr, layout, new_size)
        .                   }
        .               }
        .           }
        .           
        .           cfg_if::cfg_if! {
        .               if #[cfg(any(
-- line 56 ----------------------------------------
-- line 84 ----------------------------------------
        .               } else if #[cfg(target_os = "wasi")] {
        .                   #[inline]
        .                   unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
        .                       libc::aligned_alloc(layout.align(), layout.size()) as *mut u8
        .                   }
        .               } else {
        .                   #[inline]
        .                   unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
        1 ( 0.00%)              let mut out = ptr::null_mut();
        .                       // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.
        .                       // Since these are all powers of 2, we can just use max.
        .                       let align = layout.align().max(crate::mem::size_of::<usize>());
        2 ( 0.00%)              let ret = libc::posix_memalign(&mut out, align, layout.size());
        2 ( 0.00%)              if ret != 0 { ptr::null_mut() } else { out as *mut u8 }
        .                   }
        .               }
        .           }

        1 ( 0.00%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/library/std/src/sys/unix/alloc.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_serialize/src/opaque.rs
--------------------------------------------------------------------------------
Ir                 

-- line 14 ----------------------------------------
        .           
        .           pub type EncodeResult = Result<(), !>;
        .           
        .           pub struct Encoder {
        .               pub data: Vec<u8>,
        .           }
        .           
        .           impl Encoder {
        1 ( 0.00%)      pub fn new(data: Vec<u8>) -> Encoder {
        4 ( 0.00%)          Encoder { data }
        1 ( 0.00%)      }
        .           
        1 ( 0.00%)      pub fn into_inner(self) -> Vec<u8> {
        4 ( 0.00%)          self.data
        1 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn position(&self) -> usize {
   35,690 ( 0.00%)          self.data.len()
        .               }
        .           }
        .           
        .           macro_rules! write_leb128 {
        .               ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{
        .                   const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);
        .                   let old_len = $enc.data.len();
        .           
-- line 40 ----------------------------------------
-- line 67 ----------------------------------------
        .           
        .               #[inline]
        .               fn emit_unit(&mut self) -> EncodeResult {
        .                   Ok(())
        .               }
        .           
        .               #[inline]
        .               fn emit_usize(&mut self, v: usize) -> EncodeResult {
1,079,973 ( 0.04%)          write_leb128!(self, v, usize, write_usize_leb128)
        .               }
        .           
        .               #[inline]
        .               fn emit_u128(&mut self, v: u128) -> EncodeResult {
   19,642 ( 0.00%)          write_leb128!(self, v, u128, write_u128_leb128)
        .               }
        .           
        .               #[inline]
        .               fn emit_u64(&mut self, v: u64) -> EncodeResult {
    1,029 ( 0.00%)          write_leb128!(self, v, u64, write_u64_leb128)
        .               }
        .           
        .               #[inline]
        .               fn emit_u32(&mut self, v: u32) -> EncodeResult {
1,095,757 ( 0.04%)          write_leb128!(self, v, u32, write_u32_leb128)
        .               }
        .           
        .               #[inline]
        .               fn emit_u16(&mut self, v: u16) -> EncodeResult {
        .                   self.data.extend_from_slice(&v.to_le_bytes());
        .                   Ok(())
        .               }
        .           
-- line 98 ----------------------------------------
-- line 131 ----------------------------------------
        .               #[inline]
        .               fn emit_i8(&mut self, v: i8) -> EncodeResult {
        .                   let as_u8: u8 = unsafe { std::mem::transmute(v) };
        .                   self.emit_u8(as_u8)
        .               }
        .           
        .               #[inline]
        .               fn emit_bool(&mut self, v: bool) -> EncodeResult {
   14,358 ( 0.00%)          self.emit_u8(if v { 1 } else { 0 })
        .               }
        .           
        .               #[inline]
        .               fn emit_f64(&mut self, v: f64) -> EncodeResult {
        .                   let as_u64: u64 = v.to_bits();
        .                   self.emit_u64(as_u64)
        .               }
        .           
-- line 147 ----------------------------------------
-- line 549 ----------------------------------------
        .               #[inline]
        .               pub fn advance(&mut self, bytes: usize) {
        .                   self.position += bytes;
        .               }
        .           
        .               #[inline]
        .               pub fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {
        .                   let start = self.position;
       19 ( 0.00%)          self.position += bytes;
       19 ( 0.00%)          &self.data[start..self.position]
        .               }
        .           }
        .           
        .           macro_rules! read_leb128 {
        .               ($dec:expr, $fun:ident) => {{ leb128::$fun($dec.data, &mut $dec.position) }};
        .           }
        .           
        .           impl<'a> serialize::Decoder for Decoder<'a> {
        .               #[inline]
        .               fn read_unit(&mut self) -> () {
        .                   ()
        .               }
        .           
        .               #[inline]
        .               fn read_u128(&mut self) -> u128 {
      855 ( 0.00%)          read_leb128!(self, read_u128_leb128)
        .               }
        .           
        .               #[inline]
        .               fn read_u64(&mut self) -> u64 {
    3,219 ( 0.00%)          read_leb128!(self, read_u64_leb128)
        .               }
        .           
        .               #[inline]
   46,955 ( 0.00%)      fn read_u32(&mut self) -> u32 {
  219,556 ( 0.01%)          read_leb128!(self, read_u32_leb128)
   93,910 ( 0.00%)      }
        .           
        .               #[inline]
        .               fn read_u16(&mut self) -> u16 {
  561,386 ( 0.02%)          let bytes = [self.data[self.position], self.data[self.position + 1]];
   80,198 ( 0.00%)          let value = u16::from_le_bytes(bytes);
  160,396 ( 0.01%)          self.position += 2;
        .                   value
        .               }
        .           
        .               #[inline]
        .               fn read_u8(&mut self) -> u8 {
1,923,837 ( 0.07%)          let value = self.data[self.position];
  383,474 ( 0.01%)          self.position += 1;
        .                   value
        .               }
        .           
        .               #[inline]
  326,496 ( 0.01%)      fn read_usize(&mut self) -> usize {
  326,628 ( 0.01%)          read_leb128!(self, read_usize_leb128)
  652,992 ( 0.02%)      }
        .           
        .               #[inline]
        .               fn read_i128(&mut self) -> i128 {
        .                   read_leb128!(self, read_i128_leb128)
        .               }
        .           
        .               #[inline]
        .               fn read_i64(&mut self) -> i64 {
-- line 613 ----------------------------------------
-- line 637 ----------------------------------------
        .               #[inline]
        .               fn read_isize(&mut self) -> isize {
        .                   read_leb128!(self, read_isize_leb128)
        .               }
        .           
        .               #[inline]
        .               fn read_bool(&mut self) -> bool {
        .                   let value = self.read_u8();
   22,791 ( 0.00%)          value != 0
        .               }
        .           
        .               #[inline]
        .               fn read_f64(&mut self) -> f64 {
        .                   let bits = self.read_u64();
        .                   f64::from_bits(bits)
        .               }
        .           
-- line 653 ----------------------------------------
-- line 660 ----------------------------------------
        .               #[inline]
        .               fn read_char(&mut self) -> char {
        .                   let bits = self.read_u32();
        .                   std::char::from_u32(bits).unwrap()
        .               }
        .           
        .               #[inline]
        .               fn read_str(&mut self) -> Cow<'_, str> {
   42,216 ( 0.00%)          let len = self.read_usize();
  232,100 ( 0.01%)          let sentinel = self.data[self.position + len];
   58,124 ( 0.00%)          assert!(sentinel == STR_SENTINEL);
        .                   let s = unsafe {
        .                       std::str::from_utf8_unchecked(&self.data[self.position..self.position + len])
        .                   };
  145,310 ( 0.01%)          self.position += len + 1;
   39,228 ( 0.00%)          Cow::Borrowed(s)
        .               }
        .           
        .               #[inline]
        .               fn read_raw_bytes_into(&mut self, s: &mut [u8]) {
      405 ( 0.00%)          let start = self.position;
    3,060 ( 0.00%)          self.position += s.len();
      405 ( 0.00%)          s.copy_from_slice(&self.data[start..self.position]);
        .               }
        .           }
        .           
        .           // Specializations for contiguous byte sequences follow. The default implementations for slices
        .           // encode and decode each element individually. This isn't necessary for `u8` slices when using
        .           // opaque encoders and decoders, because each `u8` is unchanged by encoding and decoding.
        .           // Therefore, we can use more efficient implementations that process the entire sequence at once.
        .           
-- line 690 ----------------------------------------

1,304,053 ( 0.05%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_serialize/src/opaque.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_infer/src/infer/mod.rs
--------------------------------------------------------------------------------
Ir                 

-- line 108 ----------------------------------------
        .                   suppress_errors: bool,
        .               },
        .           }
        .           
        .           impl RegionckMode {
        .               /// Indicates that the MIR borrowck will repeat these region
        .               /// checks, so we should ignore errors if NLL is (unconditionally)
        .               /// enabled.
      518 ( 0.00%)      pub fn for_item_body(tcx: TyCtxt<'_>) -> Self {
        .                   // FIXME(Centril): Once we actually remove `::Migrate` also make
        .                   // this always `true` and then proceed to eliminate the dead code.
      518 ( 0.00%)          match tcx.borrowck_mode() {
        .                       // If we're on Migrate mode, report AST region errors
        .                       BorrowckMode::Migrate => RegionckMode::Erase { suppress_errors: false },
        .           
        .                       // If we're on MIR, don't report AST region errors as they should be reported by NLL
        .                       BorrowckMode::Mir => RegionckMode::Erase { suppress_errors: true },
        .                   }
    1,036 ( 0.00%)      }
        .           }
        .           
        .           /// This type contains all the things within `InferCtxt` that sit within a
        .           /// `RefCell` and are involved with taking/rolling back snapshots. Snapshot
        .           /// operations are hot enough that we want only one call to `borrow_mut` per
        .           /// call to `start_snapshot` and `rollback_to`.
        .           pub struct InferCtxtInner<'tcx> {
        .               /// Cache for projections. This cache is snapshotted along with the infcx.
-- line 134 ----------------------------------------
-- line 202 ----------------------------------------
        .               /// type instantiations (`ty::Infer`) to the actual opaque
        .               /// type (`ty::Opaque`). Used during fallback to map unconstrained
        .               /// opaque type inference variables to their corresponding
        .               /// opaque type.
        .               pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,
        .           }
        .           
        .           impl<'tcx> InferCtxtInner<'tcx> {
   57,565 ( 0.00%)      fn new() -> InferCtxtInner<'tcx> {
  391,442 ( 0.01%)          InferCtxtInner {
        .                       projection_cache: Default::default(),
        .                       type_variable_storage: type_variable::TypeVariableStorage::new(),
        .                       undo_log: InferCtxtUndoLogs::default(),
        .                       const_unification_storage: ut::UnificationTableStorage::new(),
        .                       int_unification_storage: ut::UnificationTableStorage::new(),
        .                       float_unification_storage: ut::UnificationTableStorage::new(),
   34,539 ( 0.00%)              region_constraint_storage: Some(RegionConstraintStorage::new()),
        .                       region_obligations: vec![],
        .                       opaque_types: Default::default(),
        .                       opaque_types_vars: Default::default(),
        .                   }
   69,078 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn region_obligations(&self) -> &[(hir::HirId, RegionObligation<'tcx>)] {
        .                   &self.region_obligations
        .               }
        .           
        .               #[inline]
        .               pub fn projection_cache(&mut self) -> traits::ProjectionCache<'_, 'tcx> {
    4,045 ( 0.00%)          self.projection_cache.with_log(&mut self.undo_log)
        .               }
        .           
        .               #[inline]
        .               fn type_variables(&mut self) -> type_variable::TypeVariableTable<'_, 'tcx> {
  211,772 ( 0.01%)          self.type_variable_storage.with_log(&mut self.undo_log)
        .               }
        .           
        .               #[inline]
        .               fn int_unification_table(
        .                   &mut self,
        .               ) -> ut::UnificationTable<
        .                   ut::InPlace<
        .                       ty::IntVid,
        .                       &mut ut::UnificationStorage<ty::IntVid>,
        .                       &mut InferCtxtUndoLogs<'tcx>,
        .                   >,
        .               > {
   30,313 ( 0.00%)          self.int_unification_storage.with_log(&mut self.undo_log)
        .               }
        .           
        .               #[inline]
        .               fn float_unification_table(
        .                   &mut self,
        .               ) -> ut::UnificationTable<
        .                   ut::InPlace<
        .                       ty::FloatVid,
        .                       &mut ut::UnificationStorage<ty::FloatVid>,
        .                       &mut InferCtxtUndoLogs<'tcx>,
        .                   >,
        .               > {
      538 ( 0.00%)          self.float_unification_storage.with_log(&mut self.undo_log)
        .               }
        .           
        .               #[inline]
        .               fn const_unification_table(
        .                   &mut self,
        .               ) -> ut::UnificationTable<
        .                   ut::InPlace<
        .                       ty::ConstVid<'tcx>,
        .                       &mut ut::UnificationStorage<ty::ConstVid<'tcx>>,
        .                       &mut InferCtxtUndoLogs<'tcx>,
        .                   >,
        .               > {
    1,669 ( 0.00%)          self.const_unification_storage.with_log(&mut self.undo_log)
        .               }
        .           
        .               #[inline]
        .               pub fn unwrap_region_constraints(&mut self) -> RegionConstraintCollector<'_, 'tcx> {
   26,245 ( 0.00%)          self.region_constraint_storage
        .                       .as_mut()
        .                       .expect("region constraints already solved")
   28,993 ( 0.00%)              .with_log(&mut self.undo_log)
        .               }
        .           }
        .           
        .           pub struct InferCtxt<'a, 'tcx> {
        .               pub tcx: TyCtxt<'tcx>,
        .           
        .               /// The `DefId` of the item in whose context we are performing inference or typeck.
        .               /// It is used to check whether an opaque type use is a defining use.
-- line 292 ----------------------------------------
-- line 361 ----------------------------------------
        .               /// item we are type-checking, and just consider those names as
        .               /// part of the root universe. So this would only get incremented
        .               /// when we enter into a higher-ranked (`for<..>`) type or trait
        .               /// bound.
        .               universe: Cell<ty::UniverseIndex>,
        .           }
        .           
        .           /// See the `error_reporting` module for more details.
   37,712 ( 0.00%)  #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable)]
        .           pub enum ValuePairs<'tcx> {
        .               Types(ExpectedFound<Ty<'tcx>>),
        .               Regions(ExpectedFound<ty::Region<'tcx>>),
        .               Consts(ExpectedFound<&'tcx ty::Const<'tcx>>),
        .               TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),
        .               PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),
        .           }
        .           
-- line 377 ----------------------------------------
-- line 383 ----------------------------------------
        .           pub struct TypeTrace<'tcx> {
        .               cause: ObligationCause<'tcx>,
        .               values: ValuePairs<'tcx>,
        .           }
        .           
        .           /// The origin of a `r1 <= r2` constraint.
        .           ///
        .           /// See `error_reporting` module for more details
   33,032 ( 0.00%)  #[derive(Clone, Debug)]
        .           pub enum SubregionOrigin<'tcx> {
        .               /// Arose from a subtyping relation
    1,889 ( 0.00%)      Subtype(Box<TypeTrace<'tcx>>),
        .           
        .               /// When casting `&'a T` to an `&'b Trait` object,
        .               /// relating `'a` to `'b`
        .               RelateObjectBound(Span),
        .           
        .               /// Some type parameter was instantiated with the given type,
        .               /// and that type must outlive some region.
      278 ( 0.00%)      RelateParamBound(Span, Ty<'tcx>, Option<Span>),
        .           
        .               /// The given region parameter was instantiated with a region
        .               /// that must outlive some other region.
        .               RelateRegionParamBound(Span),
        .           
        .               /// Creating a pointer `b` to contents of another reference
        .               Reborrow(Span),
        .           
        .               /// Creating a pointer `b` to contents of an upvar
        .               ReborrowUpvar(Span, ty::UpvarId),
        .           
        .               /// Data with type `Ty<'tcx>` was borrowed
      245 ( 0.00%)      DataBorrowed(Ty<'tcx>, Span),
        .           
        .               /// (&'a &'b T) where a >= b
      237 ( 0.00%)      ReferenceOutlivesReferent(Ty<'tcx>, Span),
        .           
        .               /// Comparing the signature and requirements of an impl method against
        .               /// the containing trait.
        .               CompareImplMethodObligation { span: Span, impl_item_def_id: DefId, trait_item_def_id: DefId },
        .           
        .               /// Comparing the signature and requirements of an impl associated type
        .               /// against the containing trait
        .               CompareImplTypeObligation { span: Span, impl_item_def_id: DefId, trait_item_def_id: DefId },
-- line 426 ----------------------------------------
-- line 554 ----------------------------------------
        .               defining_use_anchor: Option<LocalDefId>,
        .           }
        .           
        .           pub trait TyCtxtInferExt<'tcx> {
        .               fn infer_ctxt(self) -> InferCtxtBuilder<'tcx>;
        .           }
        .           
        .           impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {
   11,513 ( 0.00%)      fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {
   34,539 ( 0.00%)          InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }
   11,513 ( 0.00%)      }
        .           }
        .           
        .           impl<'tcx> InferCtxtBuilder<'tcx> {
        .               /// Used only by `rustc_typeck` during body type-checking/inference,
        .               /// will initialize `in_progress_typeck_results` with fresh `TypeckResults`.
        .               /// Will also change the scope for opaque type defining use checks to the given owner.
   12,897 ( 0.00%)      pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: LocalDefId) -> Self {
   15,763 ( 0.00%)          self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));
    7,165 ( 0.00%)          self.with_opaque_type_inference(table_owner)
   10,031 ( 0.00%)      }
        .           
        .               /// Whenever the `InferCtxt` should be able to handle defining uses of opaque types,
        .               /// you need to call this function. Otherwise the opaque type will be treated opaquely.
        .               ///
        .               /// It is only meant to be called in two places, for typeck
        .               /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used
        .               /// in mir borrowck.
    1,046 ( 0.00%)      pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {
      523 ( 0.00%)          self.defining_use_anchor = Some(defining_use_anchor);
    3,912 ( 0.00%)          self
    1,569 ( 0.00%)      }
        .           
        .               /// Given a canonical value `C` as a starting point, create an
        .               /// inference context that contains each of the bound values
        .               /// within instantiated as a fresh variable. The `f` closure is
        .               /// invoked with the new infcx, along with the instantiated value
        .               /// `V` and a substitution `S`. This substitution `S` maps from
        .               /// the bound values in `C` to their instantiated values in `V`
        .               /// (in other words, `S(C) = V`).
   11,319 ( 0.00%)      pub fn enter_with_canonical<T, R>(
        .                   &mut self,
        .                   span: Span,
        .                   canonical: &Canonical<'tcx, T>,
        .                   f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,
        .               ) -> R
        .               where
        .                   T: TypeFoldable<'tcx>,
        .               {
        .                   self.enter(|infcx| {
   14,582 ( 0.00%)              let (value, subst) =
      680 ( 0.00%)                  infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);
   22,094 ( 0.00%)              f(infcx, value, subst)
        .                   })
   12,377 ( 0.00%)      }
        .           
   77,535 ( 0.00%)      pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {
   31,102 ( 0.00%)          let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;
        .                   let in_progress_typeck_results = fresh_typeck_results.as_ref();
  504,769 ( 0.02%)          f(InferCtxt {
        .                       tcx,
        .                       defining_use_anchor,
        .                       in_progress_typeck_results,
   11,513 ( 0.00%)              inner: RefCell::new(InferCtxtInner::new()),
        .                       lexical_region_resolutions: RefCell::new(None),
        .                       selection_cache: Default::default(),
        .                       evaluation_cache: Default::default(),
        .                       reported_trait_errors: Default::default(),
        .                       reported_closure_mismatch: Default::default(),
        .                       tainted_by_errors_flag: Cell::new(false),
   11,513 ( 0.00%)              err_count_on_creation: tcx.sess.err_count(),
        .                       in_snapshot: Cell::new(false),
        .                       skip_leak_check: Cell::new(false),
        .                       universe: Cell::new(ty::UniverseIndex::ROOT),
        .                   })
   82,734 ( 0.00%)      }
        .           }
        .           
        .           impl<'tcx, T> InferOk<'tcx, T> {
        .               pub fn unit(self) -> InferOk<'tcx, ()> {
        .                   InferOk { value: (), obligations: self.obligations }
        .               }
        .           
        .               /// Extracts `value`, registering any obligations into `fulfill_cx`.
        .               pub fn into_value_registering_obligations(
        .                   self,
        .                   infcx: &InferCtxt<'_, 'tcx>,
        .                   fulfill_cx: &mut dyn TraitEngine<'tcx>,
        .               ) -> T {
      152 ( 0.00%)          let InferOk { value, obligations } = self;
      648 ( 0.00%)          for obligation in obligations {
        .                       fulfill_cx.register_predicate_obligation(infcx, obligation);
        .                   }
        .                   value
        .               }
        .           }
        .           
        .           impl<'tcx> InferOk<'tcx, ()> {
    9,071 ( 0.00%)      pub fn into_obligations(self) -> PredicateObligations<'tcx> {
   36,284 ( 0.00%)          self.obligations
    9,071 ( 0.00%)      }
        .           }
        .           
        .           #[must_use = "once you start a snapshot, you should always consume it"]
        .           pub struct CombinedSnapshot<'a, 'tcx> {
        .               undo_snapshot: Snapshot<'tcx>,
        .               region_constraints_snapshot: RegionSnapshot,
        .               universe: ty::UniverseIndex,
        .               was_in_snapshot: bool,
-- line 662 ----------------------------------------
-- line 674 ----------------------------------------
        .                   let canonical = self.canonicalize_query((a, b), &mut OriginalQueryValues::default());
        .                   debug!("canonical consts: {:?}", &canonical.value);
        .           
        .                   self.tcx.try_unify_abstract_consts(canonical.value)
        .               }
        .           
        .               pub fn is_in_snapshot(&self) -> bool {
        .                   self.in_snapshot.get()
   14,563 ( 0.00%)      }
        .           
   92,872 ( 0.00%)      pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {
  104,481 ( 0.00%)          t.fold_with(&mut self.freshener())
  104,481 ( 0.00%)      }
        .           
        .               /// Returns the origin of the type variable identified by `vid`, or `None`
        .               /// if this is not a type variable.
        .               ///
        .               /// No attempt is made to resolve `ty`.
      202 ( 0.00%)      pub fn type_var_origin(&'a self, ty: Ty<'tcx>) -> Option<TypeVariableOrigin> {
      404 ( 0.00%)          match *ty.kind() {
       99 ( 0.00%)              ty::Infer(ty::TyVar(vid)) => {
      396 ( 0.00%)                  Some(*self.inner.borrow_mut().type_variables().var_origin(vid))
        .                       }
        2 ( 0.00%)              _ => None,
        .                   }
      404 ( 0.00%)      }
        .           
   11,609 ( 0.00%)      pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {
        .                   freshen::TypeFreshener::new(self, false)
   11,609 ( 0.00%)      }
        .           
        .               /// Like `freshener`, but does not replace `'static` regions.
   61,567 ( 0.00%)      pub fn freshener_keep_static<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {
        .                   freshen::TypeFreshener::new(self, true)
   61,567 ( 0.00%)      }
        .           
    2,368 ( 0.00%)      pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {
    1,184 ( 0.00%)          let mut inner = self.inner.borrow_mut();
    1,184 ( 0.00%)          let mut vars: Vec<Ty<'_>> = inner
        .                       .type_variables()
        .                       .unsolved_variables()
        .                       .into_iter()
      198 ( 0.00%)              .map(|t| self.tcx.mk_ty_var(t))
        .                       .collect();
        .                   vars.extend(
        .                       (0..inner.int_unification_table().len())
        .                           .map(|i| ty::IntVid { index: i as u32 })
    1,710 ( 0.00%)                  .filter(|&vid| inner.int_unification_table().probe_value(vid).is_none())
        2 ( 0.00%)                  .map(|v| self.tcx.mk_int_var(v)),
        .                   );
        .                   vars.extend(
        .                       (0..inner.float_unification_table().len())
        .                           .map(|i| ty::FloatVid { index: i as u32 })
       60 ( 0.00%)                  .filter(|&vid| inner.float_unification_table().probe_value(vid).is_none())
        .                           .map(|v| self.tcx.mk_float_var(v)),
        .                   );
        .                   vars
    4,144 ( 0.00%)      }
        .           
   26,971 ( 0.00%)      fn combine_fields(
        .                   &'a self,
        .                   trace: TypeTrace<'tcx>,
        .                   param_env: ty::ParamEnv<'tcx>,
        .               ) -> CombineFields<'a, 'tcx> {
  108,104 ( 0.00%)          CombineFields {
        .                       infcx: self,
  270,260 ( 0.01%)              trace,
        .                       cause: None,
        .                       param_env,
        .                       obligations: PredicateObligations::new(),
        .                   }
   26,971 ( 0.00%)      }
        .           
        .               /// Clear the "currently in a snapshot" flag, invoke the closure,
        .               /// then restore the flag to its original value. This flag is a
        .               /// debugging measure designed to detect cases where we start a
        .               /// snapshot, create type variables, and register obligations
        .               /// which may involve those type variables in the fulfillment cx,
        .               /// potentially leaving "dangling type variables" behind.
        .               /// In such cases, an assertion will fail when attempting to
-- line 753 ----------------------------------------
-- line 760 ----------------------------------------
        .               /// before we return, this is not a problem, as there won't be any
        .               /// escaping obligations in the main cx. In those cases, you can
        .               /// use this function.
        .               pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R
        .               where
        .                   F: FnOnce(&Self) -> R,
        .               {
        .                   let flag = self.in_snapshot.replace(false);
    4,734 ( 0.00%)          let result = func(self);
        .                   self.in_snapshot.set(flag);
        .                   result
        .               }
        .           
  146,758 ( 0.01%)      fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {
        .                   debug!("start_snapshot()");
        .           
        .                   let in_snapshot = self.in_snapshot.replace(true);
        .           
        .                   let mut inner = self.inner.borrow_mut();
        .           
  440,274 ( 0.02%)          CombinedSnapshot {
        .                       undo_snapshot: inner.undo_log.start_snapshot(),
        .                       region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),
        .                       universe: self.universe(),
        .                       was_in_snapshot: in_snapshot,
        .                       // Borrow typeck results "in progress" (i.e., during typeck)
        .                       // to ban writes from within a snapshot to them.
   73,379 ( 0.00%)              _in_progress_typeck_results: self
        .                           .in_progress_typeck_results
        .                           .map(|typeck_results| typeck_results.borrow()),
        .                   }
  293,516 ( 0.01%)      }
        .           
  227,535 ( 0.01%)      #[instrument(skip(self, snapshot), level = "debug")]
        .               fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {
        .                   let CombinedSnapshot {
   20,685 ( 0.00%)              undo_snapshot,
   20,685 ( 0.00%)              region_constraints_snapshot,
   20,685 ( 0.00%)              universe,
   20,685 ( 0.00%)              was_in_snapshot,
   41,370 ( 0.00%)              _in_progress_typeck_results,
        .                   } = snapshot;
        .           
        .                   self.in_snapshot.set(was_in_snapshot);
        .                   self.universe.set(universe);
        .           
        .                   let mut inner = self.inner.borrow_mut();
   20,685 ( 0.00%)          inner.rollback_to(undo_snapshot);
        .                   inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);
        .               }
        .           
  790,410 ( 0.03%)      #[instrument(skip(self, snapshot), level = "debug")]
        .               fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {
        .                   let CombinedSnapshot {
   52,694 ( 0.00%)              undo_snapshot,
        .                       region_constraints_snapshot: _,
        .                       universe: _,
   52,694 ( 0.00%)              was_in_snapshot,
  105,388 ( 0.00%)              _in_progress_typeck_results,
        .                   } = snapshot;
        .           
        .                   self.in_snapshot.set(was_in_snapshot);
        .           
        .                   self.inner.borrow_mut().commit(undo_snapshot);
        .               }
        .           
        .               /// Executes `f` and commit the bindings.
   31,154 ( 0.00%)      #[instrument(skip(self, f), level = "debug")]
   38,203 ( 0.00%)      pub fn commit_unconditionally<R, F>(&self, f: F) -> R
        .               where
        .                   F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,
        .               {
    3,473 ( 0.00%)          let snapshot = self.start_snapshot();
   11,012 ( 0.00%)          let r = f(&snapshot);
   24,311 ( 0.00%)          self.commit_from(snapshot);
   20,657 ( 0.00%)          r
        .               }
        .           
        .               /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.
  303,852 ( 0.01%)      #[instrument(skip(self, f), level = "debug")]
  375,720 ( 0.01%)      pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>
        .               where
        .                   F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,
        .               {
   64,857 ( 0.00%)          let snapshot = self.start_snapshot();
  173,645 ( 0.01%)          let r = f(&snapshot);
        .                   debug!("commit_if_ok() -- r.is_ok() = {}", r.is_ok());
   68,614 ( 0.00%)          match r {
        .                       Ok(_) => {
  348,058 ( 0.01%)                  self.commit_from(snapshot);
        .                       }
        .                       Err(_) => {
   87,550 ( 0.00%)                  self.rollback_to("commit_if_ok -- error", snapshot);
        .                       }
        .                   }
  367,506 ( 0.01%)          r
        .               }
        .           
        .               /// Execute `f` then unroll any bindings it creates.
   78,081 ( 0.00%)      #[instrument(skip(self, f), level = "debug")]
   93,386 ( 0.00%)      pub fn probe<R, F>(&self, f: F) -> R
        .               where
        .                   F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,
        .               {
   22,111 ( 0.00%)          let snapshot = self.start_snapshot();
   38,585 ( 0.00%)          let r = f(&snapshot);
  106,731 ( 0.00%)          self.rollback_to("probe", snapshot);
   19,411 ( 0.00%)          r
        .               }
        .           
        .               /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.
      153 ( 0.00%)      #[instrument(skip(self, f), level = "debug")]
      204 ( 0.00%)      pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R
        .               where
        .                   F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,
        .               {
       34 ( 0.00%)          let snapshot = self.start_snapshot();
       17 ( 0.00%)          let was_skip_leak_check = self.skip_leak_check.get();
       34 ( 0.00%)          if should_skip {
        .                       self.skip_leak_check.set(true);
        .                   }
       68 ( 0.00%)          let r = f(&snapshot);
      153 ( 0.00%)          self.rollback_to("probe", snapshot);
        .                   self.skip_leak_check.set(was_skip_leak_check);
      204 ( 0.00%)          r
        .               }
        .           
        .               /// Scan the constraints produced since `snapshot` began and returns:
        .               ///
        .               /// - `None` -- if none of them involve "region outlives" constraints
        .               /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder
        .               /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders
    5,322 ( 0.00%)      pub fn region_constraints_added_in_snapshot(
        .                   &self,
        .                   snapshot: &CombinedSnapshot<'a, 'tcx>,
        .               ) -> Option<bool> {
   10,644 ( 0.00%)          self.inner
        .                       .borrow_mut()
        .                       .unwrap_region_constraints()
        .                       .region_constraints_added_in_snapshot(&snapshot.undo_snapshot)
    7,983 ( 0.00%)      }
        .           
        .               pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {
        .                   self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);
        .               }
        .           
      540 ( 0.00%)      pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>
        .               where
        .                   T: at::ToTrace<'tcx>,
        .               {
        .                   let origin = &ObligationCause::dummy();
        .                   self.probe(|_| {
        .                       self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {
        .                           // Ignore obligations, since we are unrolling
        .                           // everything anyway.
        .                       })
        .                   })
      405 ( 0.00%)      }
        .           
    7,188 ( 0.00%)      pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>
        .               where
        .                   T: at::ToTrace<'tcx>,
        .               {
        .                   let origin = &ObligationCause::dummy();
        .                   self.probe(|_| {
        .                       self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {
        .                           // Ignore obligations, since we are unrolling
        .                           // everything anyway.
        .                       })
        .                   })
    5,391 ( 0.00%)      }
        .           
   16,120 ( 0.00%)      #[instrument(skip(self), level = "debug")]
        .               pub fn sub_regions(
        .                   &self,
        .                   origin: SubregionOrigin<'tcx>,
        .                   a: ty::Region<'tcx>,
        .                   b: ty::Region<'tcx>,
        .               ) {
   14,508 ( 0.00%)          self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);
        .               }
        .           
        .               /// Require that the region `r` be equal to one of the regions in
        .               /// the set `regions`.
        .               #[instrument(skip(self), level = "debug")]
        .               pub fn member_constraint(
        .                   &self,
        .                   opaque_type_def_id: DefId,
-- line 947 ----------------------------------------
-- line 969 ----------------------------------------
        .               /// to `subtype_predicate` -- that is, "coercing" `a` to `b` winds up
        .               /// actually requiring `a <: b`. This is of course a valid coercion,
        .               /// but it's not as flexible as `FnCtxt::coerce` would be.
        .               ///
        .               /// (We may refactor this in the future, but there are a number of
        .               /// practical obstacles. Among other things, `FnCtxt::coerce` presently
        .               /// records adjustments that are required on the HIR in order to perform
        .               /// the coercion, and we don't currently have a way to manage that.)
       78 ( 0.00%)      pub fn coerce_predicate(
        .                   &self,
        .                   cause: &ObligationCause<'tcx>,
        .                   param_env: ty::ParamEnv<'tcx>,
        .                   predicate: ty::PolyCoercePredicate<'tcx>,
        .               ) -> Option<InferResult<'tcx, ()>> {
       52 ( 0.00%)          let subtype_predicate = predicate.map_bound(|p| ty::SubtypePredicate {
        .                       a_is_expected: false, // when coercing from `a` to `b`, `b` is expected
        .                       a: p.a,
        .                       b: p.b,
        .                   });
      130 ( 0.00%)          self.subtype_predicate(cause, param_env, subtype_predicate)
      104 ( 0.00%)      }
        .           
    1,056 ( 0.00%)      pub fn subtype_predicate(
        .                   &self,
        .                   cause: &ObligationCause<'tcx>,
        .                   param_env: ty::ParamEnv<'tcx>,
        .                   predicate: ty::PolySubtypePredicate<'tcx>,
        .               ) -> Option<InferResult<'tcx, ()>> {
        .                   // Check for two unresolved inference variables, in which case we can
        .                   // make no progress. This is partly a micro-optimization, but it's
        .                   // also an opportunity to "sub-unify" the variables. This isn't
-- line 999 ----------------------------------------
-- line 1002 ----------------------------------------
        .                   // earlier that they are sub-unified).
        .                   //
        .                   // Note that we can just skip the binders here because
        .                   // type variables can't (at present, at
        .                   // least) capture any of the things bound by this binder.
        .                   //
        .                   // Note that this sub here is not just for diagnostics - it has semantic
        .                   // effects as well.
       88 ( 0.00%)          let r_a = self.shallow_resolve(predicate.skip_binder().a);
       88 ( 0.00%)          let r_b = self.shallow_resolve(predicate.skip_binder().b);
      542 ( 0.00%)          match (r_a.kind(), r_b.kind()) {
      100 ( 0.00%)              (&ty::Infer(ty::TyVar(a_vid)), &ty::Infer(ty::TyVar(b_vid))) => {
        .                           self.inner.borrow_mut().type_variables().sub(a_vid, b_vid);
      100 ( 0.00%)                  return None;
        .                       }
        .                       _ => {}
        .                   }
        .           
        .                   Some(self.commit_if_ok(|_snapshot| {
       38 ( 0.00%)              let ty::SubtypePredicate { a_is_expected, a, b } =
        .                           self.replace_bound_vars_with_placeholders(predicate);
        .           
       76 ( 0.00%)              let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;
        .           
        .                       Ok(ok.unit())
        .                   }))
      792 ( 0.00%)      }
        .           
    4,332 ( 0.00%)      pub fn region_outlives_predicate(
        .                   &self,
        .                   cause: &traits::ObligationCause<'tcx>,
        .                   predicate: ty::PolyRegionOutlivesPredicate<'tcx>,
        .               ) -> UnitResult<'tcx> {
        .                   self.commit_if_ok(|_snapshot| {
        .                       let ty::OutlivesPredicate(r_a, r_b) =
        .                           self.replace_bound_vars_with_placeholders(predicate);
        .                       let origin = SubregionOrigin::from_obligation_cause(cause, || {
        .                           RelateRegionParamBound(cause.span)
        .                       });
    3,610 ( 0.00%)              self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`
        .                       Ok(())
        .                   })
    2,888 ( 0.00%)      }
        .           
        .               /// Number of type variables created so far.
       74 ( 0.00%)      pub fn num_ty_vars(&self) -> usize {
        .                   self.inner.borrow_mut().type_variables().num_vars()
      148 ( 0.00%)      }
        .           
   16,584 ( 0.00%)      pub fn next_ty_var_id(&self, origin: TypeVariableOrigin) -> TyVid {
   82,920 ( 0.00%)          self.inner.borrow_mut().type_variables().new_var(self.universe(), origin)
   24,876 ( 0.00%)      }
        .           
   15,220 ( 0.00%)      pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {
   57,362 ( 0.00%)          self.tcx.mk_ty_var(self.next_ty_var_id(origin))
   22,830 ( 0.00%)      }
        .           
      760 ( 0.00%)      pub fn next_ty_var_in_universe(
        .                   &self,
        .                   origin: TypeVariableOrigin,
        .                   universe: ty::UniverseIndex,
        .               ) -> Ty<'tcx> {
    4,180 ( 0.00%)          let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);
      380 ( 0.00%)          self.tcx.mk_ty_var(vid)
    1,140 ( 0.00%)      }
        .           
        .               pub fn next_const_var(
        .                   &self,
        .                   ty: Ty<'tcx>,
        .                   origin: ConstVariableOrigin,
        .               ) -> &'tcx ty::Const<'tcx> {
        .                   self.tcx.mk_const_var(self.next_const_var_id(origin), ty)
        .               }
-- line 1074 ----------------------------------------
-- line 1090 ----------------------------------------
        .               pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {
        .                   self.inner.borrow_mut().const_unification_table().new_key(ConstVarValue {
        .                       origin,
        .                       val: ConstVariableValue::Unknown { universe: self.universe() },
        .                   })
        .               }
        .           
        .               fn next_int_var_id(&self) -> IntVid {
    2,935 ( 0.00%)          self.inner.borrow_mut().int_unification_table().new_key(None)
        .               }
        .           
    1,761 ( 0.00%)      pub fn next_int_var(&self) -> Ty<'tcx> {
        .                   self.tcx.mk_int_var(self.next_int_var_id())
    2,348 ( 0.00%)      }
        .           
        .               fn next_float_var_id(&self) -> FloatVid {
      100 ( 0.00%)          self.inner.borrow_mut().float_unification_table().new_key(None)
        .               }
        .           
       60 ( 0.00%)      pub fn next_float_var(&self) -> Ty<'tcx> {
        .                   self.tcx.mk_float_var(self.next_float_var_id())
       80 ( 0.00%)      }
        .           
        .               /// Creates a fresh region variable with the next available index.
        .               /// The variable will be created in the maximum universe created
        .               /// thus far, allowing it to name any region created thus far.
    3,375 ( 0.00%)      pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {
   69,347 ( 0.00%)          self.next_region_var_in_universe(origin, self.universe())
    6,750 ( 0.00%)      }
        .           
        .               /// Creates a fresh region variable with the next available index
        .               /// in the given universe; typically, you can use
        .               /// `next_region_var` and just use the maximal universe.
   25,522 ( 0.00%)      pub fn next_region_var_in_universe(
        .                   &self,
        .                   origin: RegionVariableOrigin,
        .                   universe: ty::UniverseIndex,
        .               ) -> ty::Region<'tcx> {
        .                   let region_var =
  165,893 ( 0.01%)              self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);
   63,805 ( 0.00%)          self.tcx.mk_region(ty::ReVar(region_var))
   38,283 ( 0.00%)      }
        .           
        .               /// Return the universe that the region `r` was created in.  For
        .               /// most regions (e.g., `'static`, named regions from the user,
        .               /// etc) this is the root universe U0. For inference variables or
        .               /// placeholders, however, it will return the universe which which
        .               /// they are associated.
    2,564 ( 0.00%)      pub fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {
        .                   self.inner.borrow_mut().unwrap_region_constraints().universe(r)
    3,846 ( 0.00%)      }
        .           
        .               /// Number of region variables created so far.
    4,194 ( 0.00%)      pub fn num_region_vars(&self) -> usize {
        .                   self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()
    6,291 ( 0.00%)      }
        .           
        .               /// Just a convenient wrapper of `next_region_var` for using during NLL.
    5,128 ( 0.00%)      pub fn next_nll_region_var(&self, origin: NllRegionVariableOrigin) -> ty::Region<'tcx> {
        .                   self.next_region_var(RegionVariableOrigin::Nll(origin))
   10,256 ( 0.00%)      }
        .           
        .               /// Just a convenient wrapper of `next_region_var` for using during NLL.
       12 ( 0.00%)      pub fn next_nll_region_var_in_universe(
        .                   &self,
        .                   origin: NllRegionVariableOrigin,
        .                   universe: ty::UniverseIndex,
        .               ) -> ty::Region<'tcx> {
       88 ( 0.00%)          self.next_region_var_in_universe(RegionVariableOrigin::Nll(origin), universe)
       24 ( 0.00%)      }
        .           
   47,992 ( 0.00%)      pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> GenericArg<'tcx> {
   24,629 ( 0.00%)          match param.kind {
        .                       GenericParamDefKind::Lifetime => {
        .                           // Create a region inference variable for the given
        .                           // region parameter definition.
    2,683 ( 0.00%)                  self.next_region_var(EarlyBoundRegion(span, param.name)).into()
        .                       }
        .                       GenericParamDefKind::Type { .. } => {
        .                           // Create a type inference variable for the given
        .                           // type parameter definition. The substitutions are
        .                           // for actual parameters that may be referred to by
        .                           // the default of this type parameter, if it exists.
        .                           // e.g., `struct Foo<A, B, C = (A, B)>(...);` when
        .                           // used in a path such as `Foo::<T, U>::new()` will
        .                           // use an inference variable for `C` with `[T, U]`
        .                           // as the substitutions for the default, `(T, U)`.
   12,744 ( 0.00%)                  let ty_var_id = self.inner.borrow_mut().type_variables().new_var(
        .                               self.universe(),
   15,930 ( 0.00%)                      TypeVariableOrigin {
        .                                   kind: TypeVariableOriginKind::TypeParameterDefinition(
    3,186 ( 0.00%)                              param.name,
    3,186 ( 0.00%)                              Some(param.def_id),
        .                                   ),
        .                                   span,
        .                               },
        .                           );
        .           
    3,186 ( 0.00%)                  self.tcx.mk_ty_var(ty_var_id).into()
        .                       }
        .                       GenericParamDefKind::Const { .. } => {
        .                           let origin = ConstVariableOrigin {
        .                               kind: ConstVariableOriginKind::ConstParameterDefinition(
        .                                   param.name,
        .                                   param.def_id,
        .                               ),
        .                               span,
        .                           };
        .                           let const_var_id =
    1,430 ( 0.00%)                      self.inner.borrow_mut().const_unification_table().new_key(ConstVarValue {
        .                                   origin,
        .                                   val: ConstVariableValue::Unknown { universe: self.universe() },
        .                               });
      130 ( 0.00%)                  self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()
        .                       }
        .                   }
    1,040 ( 0.00%)      }
        .           
        .               /// Given a set of generics defined on a type or impl, returns a substitution mapping each
        .               /// type/region parameter to a fresh inference variable.
   20,625 ( 0.00%)      pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> SubstsRef<'tcx> {
   68,550 ( 0.00%)          InternalSubsts::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))
   13,750 ( 0.00%)      }
        .           
        .               /// Returns `true` if errors have been reported since this infcx was
        .               /// created. This is sometimes used as a heuristic to skip
        .               /// reporting errors that often occur as a result of earlier
        .               /// errors, but where it's hard to be 100% sure (e.g., unresolved
        .               /// inference variables, regionck errors).
    1,238 ( 0.00%)      pub fn is_tainted_by_errors(&self) -> bool {
        .                   debug!(
        .                       "is_tainted_by_errors(err_count={}, err_count_on_creation={}, \
        .                        tainted_by_errors_flag={})",
        .                       self.tcx.sess.err_count(),
        .                       self.err_count_on_creation,
        .                       self.tainted_by_errors_flag.get()
        .                   );
        .           
   37,003 ( 0.00%)          if self.tcx.sess.err_count() > self.err_count_on_creation {
        .                       return true; // errors reported since this infcx was made
        .                   }
        .                   self.tainted_by_errors_flag.get()
    1,857 ( 0.00%)      }
        .           
        .               /// Set the "tainted by errors" flag to true. We call this when we
        .               /// observe an error from a prior pass.
        .               pub fn set_tainted_by_errors(&self) {
        .                   debug!("set_tainted_by_errors()");
        .                   self.tainted_by_errors_flag.set(true)
        .               }
        .           
        .               /// Process the region constraints and return any any errors that
        .               /// result. After this, no more unification operations should be
        .               /// done -- or the compiler will panic -- but it is legal to use
        .               /// `resolve_vars_if_possible` as well as `fully_resolve`.
   38,115 ( 0.00%)      pub fn resolve_regions(
        .                   &self,
        .                   region_context: DefId,
        .                   outlives_env: &OutlivesEnvironment<'tcx>,
        .                   mode: RegionckMode,
        .               ) -> Vec<RegionResolutionError<'tcx>> {
  103,455 ( 0.00%)          let (var_infos, data) = {
        .                       let mut inner = self.inner.borrow_mut();
        .                       let inner = &mut *inner;
    5,445 ( 0.00%)              assert!(
   16,335 ( 0.00%)                  self.is_tainted_by_errors() || inner.region_obligations.is_empty(),
        .                           "region_obligations not empty: {:#?}",
        .                           inner.region_obligations
        .                       );
        .                       inner
        .                           .region_constraint_storage
        .                           .take()
        .                           .expect("regions already resolved")
        .                           .with_log(&mut inner.undo_log)
        .                           .into_infos_and_data()
    5,445 ( 0.00%)          };
        .           
        .                   let region_rels =
    5,445 ( 0.00%)              &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());
        .           
   49,005 ( 0.00%)          let (lexical_region_resolutions, errors) =
  130,680 ( 0.00%)              lexical_region_resolve::resolve(region_rels, var_infos, data, mode);
        .           
   21,780 ( 0.00%)          let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));
    5,445 ( 0.00%)          assert!(old_value.is_none());
        .           
        .                   errors
   49,005 ( 0.00%)      }
        .           
        .               /// Process the region constraints and report any errors that
        .               /// result. After this, no more unification operations should be
        .               /// done -- or the compiler will panic -- but it is legal to use
        .               /// `resolve_vars_if_possible` as well as `fully_resolve`.
   54,450 ( 0.00%)      pub fn resolve_regions_and_report_errors(
        .                   &self,
        .                   region_context: DefId,
        .                   outlives_env: &OutlivesEnvironment<'tcx>,
        .                   mode: RegionckMode,
        .               ) {
   10,890 ( 0.00%)          let errors = self.resolve_regions(region_context, outlives_env, mode);
        .           
   16,335 ( 0.00%)          if !self.is_tainted_by_errors() {
        .                       // As a heuristic, just skip reporting region errors
        .                       // altogether if other errors have been reported while
        .                       // this infcx was in use.  This is totally hokey but
        .                       // otherwise we have a hard time separating legit region
        .                       // errors from silly ones.
   10,890 ( 0.00%)              self.report_region_errors(&errors);
        .                   }
   27,225 ( 0.00%)      }
        .           
        .               /// Obtains (and clears) the current set of region
        .               /// constraints. The inference context is still usable: further
        .               /// unifications will simply add new constraints.
        .               ///
        .               /// This method is not meant to be used with normal lexical region
        .               /// resolution. Rather, it is used in the NLL mode as a kind of
        .               /// interim hack: basically we run normal type-check and generate
-- line 1307 ----------------------------------------
-- line 1319 ----------------------------------------
        .               }
        .           
        .               /// Gives temporary access to the region constraint data.
        .               pub fn with_region_constraints<R>(
        .                   &self,
        .                   op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,
        .               ) -> R {
        .                   let mut inner = self.inner.borrow_mut();
    4,148 ( 0.00%)          op(inner.unwrap_region_constraints().data())
        .               }
        .           
        .               pub fn region_var_origin(&self, vid: ty::RegionVid) -> RegionVariableOrigin {
        .                   let mut inner = self.inner.borrow_mut();
        .                   let inner = &mut *inner;
        .                   inner
        .                       .region_constraint_storage
        .                       .as_mut()
-- line 1335 ----------------------------------------
-- line 1338 ----------------------------------------
        .                       .var_origin(vid)
        .               }
        .           
        .               /// Takes ownership of the list of variable regions. This implies
        .               /// that all the region constraints have already been taken, and
        .               /// hence that `resolve_regions_and_report_errors` can never be
        .               /// called. This is used only during NLL processing to "hand off" ownership
        .               /// of the set of region variables into the NLL region context.
    2,615 ( 0.00%)      pub fn take_region_var_origins(&self) -> VarInfos {
        .                   let mut inner = self.inner.borrow_mut();
    9,937 ( 0.00%)          let (var_infos, data) = inner
        .                       .region_constraint_storage
        .                       .take()
        .                       .expect("regions already resolved")
        .                       .with_log(&mut inner.undo_log)
      523 ( 0.00%)              .into_infos_and_data();
      523 ( 0.00%)          assert!(data.is_empty());
        .                   var_infos
    4,184 ( 0.00%)      }
        .           
        .               pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {
        .                   self.resolve_vars_if_possible(t).to_string()
        .               }
        .           
        .               /// If `TyVar(vid)` resolves to a type, return that type. Else, return the
        .               /// universe index of `TyVar(vid)`.
    4,306 ( 0.00%)      pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {
        .                   use self::type_variable::TypeVariableValue;
        .           
   12,918 ( 0.00%)          match self.inner.borrow_mut().type_variables().probe(vid) {
        .                       TypeVariableValue::Known { value } => Ok(value),
        .                       TypeVariableValue::Unknown { universe } => Err(universe),
        .                   }
   15,071 ( 0.00%)      }
        .           
        .               /// Resolve any type variables found in `value` -- but only one
        .               /// level.  So, if the variable `?X` is bound to some type
        .               /// `Foo<?Y>`, then this would return `Foo<?Y>` (but `?Y` may
        .               /// itself be bound to a type).
        .               ///
        .               /// Useful when you only need to inspect the outermost level of
        .               /// the type and don't care about nested types (or perhaps you
        .               /// will be resolving them as well, e.g. in a loop).
        .               pub fn shallow_resolve<T>(&self, value: T) -> T
        .               where
        .                   T: TypeFoldable<'tcx>,
        .               {
  119,343 ( 0.00%)          value.fold_with(&mut ShallowResolver { infcx: self })
        .               }
        .           
    5,982 ( 0.00%)      pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {
        .                   self.inner.borrow_mut().type_variables().root_var(var)
    8,973 ( 0.00%)      }
        .           
        .               /// Where possible, replaces type/const variables in
        .               /// `value` with their final value. Note that region variables
        .               /// are unaffected. If a type/const variable has not been unified, it
        .               /// is left as is. This is an idempotent operation that does
        .               /// not affect inference state in any way and so you can do it
        .               /// at will.
    1,988 ( 0.00%)      pub fn resolve_vars_if_possible<T>(&self, value: T) -> T
        .               where
        .                   T: TypeFoldable<'tcx>,
        .               {
  108,406 ( 0.00%)          if !value.needs_infer() {
  103,259 ( 0.00%)              return value; // Avoid duplicated subst-folding.
        .                   }
   95,892 ( 0.00%)          let mut r = resolve::OpportunisticVarResolver::new(self);
  107,339 ( 0.00%)          value.fold_with(&mut r)
    2,366 ( 0.00%)      }
        .           
        .               /// Returns the first unresolved variable contained in `T`. In the
        .               /// process of visiting `T`, this will resolve (where possible)
        .               /// type variables in `T`, but it never constructs the final,
        .               /// resolved type, so it's more efficient than
        .               /// `resolve_vars_if_possible()`.
        .               pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>
        .               where
-- line 1415 ----------------------------------------
-- line 1490 ----------------------------------------
        .                   expected: &'tcx ty::Const<'tcx>,
        .                   actual: &'tcx ty::Const<'tcx>,
        .                   err: TypeError<'tcx>,
        .               ) -> DiagnosticBuilder<'tcx> {
        .                   let trace = TypeTrace::consts(cause, true, expected, actual);
        .                   self.report_and_explain_type_error(trace, &err)
        .               }
        .           
   13,590 ( 0.00%)      pub fn replace_bound_vars_with_fresh_vars<T>(
        .                   &self,
        .                   span: Span,
        .                   lbrct: LateBoundRegionConversionTime,
        .                   value: ty::Binder<'tcx, T>,
        .               ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)
        .               where
        .                   T: TypeFoldable<'tcx>,
        .               {
        .                   let fld_r =
   39,469 ( 0.00%)              |br: ty::BoundRegion| self.next_region_var(LateBoundRegion(span, br.kind, lbrct));
        .                   let fld_t = |_| {
        .                       self.next_ty_var(TypeVariableOrigin {
        .                           kind: TypeVariableOriginKind::MiscVariable,
        .                           span,
        .                       })
        .                   };
        .                   let fld_c = |_, ty| {
        .                       self.next_const_var(
        .                           ty,
        .                           ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span },
        .                       )
        .                   };
   53,871 ( 0.00%)          self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)
    9,060 ( 0.00%)      }
        .           
        .               /// See the [`region_constraints::RegionConstraintCollector::verify_generic_bound`] method.
      480 ( 0.00%)      pub fn verify_generic_bound(
        .                   &self,
        .                   origin: SubregionOrigin<'tcx>,
        .                   kind: GenericKind<'tcx>,
        .                   a: ty::Region<'tcx>,
        .                   bound: VerifyBound<'tcx>,
        .               ) {
        .                   debug!("verify_generic_bound({:?}, {:?} <: {:?})", kind, a, bound);
        .           
      180 ( 0.00%)          self.inner
        .                       .borrow_mut()
        .                       .unwrap_region_constraints()
    1,020 ( 0.00%)              .verify_generic_bound(origin, kind, a, bound);
      420 ( 0.00%)      }
        .           
        .               /// Obtains the latest type of the given closure; this may be a
        .               /// closure in the current function, in which case its
        .               /// `ClosureKind` may not yet be known.
       86 ( 0.00%)      pub fn closure_kind(&self, closure_substs: SubstsRef<'tcx>) -> Option<ty::ClosureKind> {
      172 ( 0.00%)          let closure_kind_ty = closure_substs.as_closure().kind_ty();
        .                   let closure_kind_ty = self.shallow_resolve(closure_kind_ty);
      129 ( 0.00%)          closure_kind_ty.to_opt_closure_kind()
        .               }
        .           
        .               /// Clears the selection, evaluation, and projection caches. This is useful when
        .               /// repeatedly attempting to select an `Obligation` while changing only
        .               /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.
        .               pub fn clear_caches(&self) {
        .                   self.selection_cache.clear();
        .                   self.evaluation_cache.clear();
        .                   self.inner.borrow_mut().projection_cache().clear();
        .               }
        .           
        .               pub fn universe(&self) -> ty::UniverseIndex {
  187,928 ( 0.01%)          self.universe.get()
   77,026 ( 0.00%)      }
        .           
        .               /// Creates and return a fresh universe that extends all previous
        .               /// universes. Updates `self.universe` to that new universe.
        8 ( 0.00%)      pub fn create_next_universe(&self) -> ty::UniverseIndex {
       98 ( 0.00%)          let u = self.universe.get().next_universe();
        .                   self.universe.set(u);
        .                   u
        8 ( 0.00%)      }
        .           
        .               /// Resolves and evaluates a constant.
        .               ///
        .               /// The constant can be located on a trait like `<A as B>::C`, in which case the given
        .               /// substitutions and environment are used to resolve the constant. Alternatively if the
        .               /// constant has generic parameters in scope the substitutions are used to evaluate the value of
        .               /// the constant. For example in `fn foo<T>() { let _ = [0; bar::<T>()]; }` the repeat count
        .               /// constant `bar::<T>()` requires a substitution for `T`, if the substitution for `T` is still
        .               /// too generic for the constant to be evaluated then `Err(ErrorHandled::TooGeneric)` is
        .               /// returned.
        .               ///
        .               /// This handles inferences variables within both `param_env` and `substs` by
        .               /// performing the operation on their respective canonical forms.
      156 ( 0.00%)      pub fn const_eval_resolve(
        .                   &self,
        .                   param_env: ty::ParamEnv<'tcx>,
        .                   unevaluated: ty::Unevaluated<'tcx>,
        .                   span: Option<Span>,
        .               ) -> EvalToConstValueResult<'tcx> {
       12 ( 0.00%)          let substs = self.resolve_vars_if_possible(unevaluated.substs);
        .           
        .                   // Postpone the evaluation of constants whose substs depend on inference
        .                   // variables
        .                   if substs.has_infer_types_or_consts() {
        .                       return Err(ErrorHandled::TooGeneric);
        .                   }
        .           
       12 ( 0.00%)          let param_env_erased = self.tcx.erase_regions(param_env);
        .                   let substs_erased = self.tcx.erase_regions(substs);
        .           
        .                   let unevaluated = ty::Unevaluated {
        .                       def: unevaluated.def,
        .                       substs: substs_erased,
       24 ( 0.00%)              promoted: unevaluated.promoted,
        .                   };
        .           
        .                   // The return value is the evaluated value which doesn't contain any reference to inference
        .                   // variables, thus we don't need to substitute back the original values.
      144 ( 0.00%)          self.tcx.const_eval_resolve(param_env_erased, unevaluated, span)
      108 ( 0.00%)      }
        .           
        .               /// If `typ` is a type variable of some kind, resolve it one level
        .               /// (but do not resolve types found in the result). If `typ` is
        .               /// not a type variable, just return it unmodified.
        .               // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.
1,088,456 ( 0.04%)      fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {
  621,282 ( 0.02%)          match *typ.kind() {
        .                       ty::Infer(ty::TyVar(v)) => {
        .                           // Not entirely obvious: if `typ` is a type variable,
        .                           // it can be resolved to an int/float variable, which
        .                           // can then be recursively resolved, hence the
        .                           // recursion. Note though that we prevent type
        .                           // variables from unifying to other type variables
        .                           // directly (though they may be embedded
        .                           // structurally), and we prevent cycles in any case,
        .                           // so this recursion should always be of very limited
        .                           // depth.
        .                           //
        .                           // Note: if these two lines are combined into one we get
        .                           // dynamic borrow errors on `self.inner`.
  300,532 ( 0.01%)                  let known = self.inner.borrow_mut().type_variables().probe(v).known();
        .                           known.map_or(typ, |t| self.shallow_resolve_ty(t))
        .                       }
        .           
   41,484 ( 0.00%)              ty::Infer(ty::IntVar(v)) => self
        .                           .inner
        .                           .borrow_mut()
        .                           .int_unification_table()
        .                           .probe_value(v)
   11,814 ( 0.00%)                  .map(|v| v.to_type(self.tcx))
        .                           .unwrap_or(typ),
        .           
    1,144 ( 0.00%)              ty::Infer(ty::FloatVar(v)) => self
        .                           .inner
        .                           .borrow_mut()
        .                           .float_unification_table()
        .                           .probe_value(v)
      560 ( 0.00%)                  .map(|v| v.to_type(self.tcx))
        .                           .unwrap_or(typ),
        .           
        .                       _ => typ,
        .                   }
1,224,513 ( 0.05%)      }
        .           
        .               /// `ty_or_const_infer_var_changed` is equivalent to one of these two:
        .               ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)
        .               ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)
        .               ///
        .               /// However, `ty_or_const_infer_var_changed` is more efficient. It's always
        .               /// inlined, despite being large, because it has only two call sites that
        .               /// are extremely hot (both in `traits::fulfill`'s checking of `stalled_on`
-- line 1659 ----------------------------------------
-- line 1662 ----------------------------------------
        .               #[inline(always)]
        .               pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {
        .                   match infer_var {
        .                       TyOrConstInferVar::Ty(v) => {
        .                           use self::type_variable::TypeVariableValue;
        .           
        .                           // If `inlined_probe` returns a `Known` value, it never equals
        .                           // `ty::Infer(ty::TyVar(v))`.
  218,905 ( 0.01%)                  match self.inner.borrow_mut().type_variables().inlined_probe(v) {
        .                               TypeVariableValue::Unknown { .. } => false,
        .                               TypeVariableValue::Known { .. } => true,
        .                           }
        .                       }
        .           
        .                       TyOrConstInferVar::TyInt(v) => {
        .                           // If `inlined_probe_value` returns a value it's always a
        .                           // `ty::Int(_)` or `ty::UInt(_)`, which never matches a
        .                           // `ty::Infer(_)`.
    7,890 ( 0.00%)                  self.inner.borrow_mut().int_unification_table().inlined_probe_value(v).is_some()
        .                       }
        .           
        .                       TyOrConstInferVar::TyFloat(v) => {
        .                           // If `probe_value` returns a value it's always a
        .                           // `ty::Float(_)`, which never matches a `ty::Infer(_)`.
        .                           //
        .                           // Not `inlined_probe_value(v)` because this call site is colder.
        .                           self.inner.borrow_mut().float_unification_table().probe_value(v).is_some()
-- line 1688 ----------------------------------------
-- line 1716 ----------------------------------------
        .               /// Equivalent to `ty::ConstKind::Infer(ty::InferConst::Var(_))`.
        .               Const(ConstVid<'tcx>),
        .           }
        .           
        .           impl<'tcx> TyOrConstInferVar<'tcx> {
        .               /// Tries to extract an inference variable from a type or a constant, returns `None`
        .               /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`) and
        .               /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).
    5,228 ( 0.00%)      pub fn maybe_from_generic_arg(arg: GenericArg<'tcx>) -> Option<Self> {
        .                   match arg.unpack() {
        .                       GenericArgKind::Type(ty) => Self::maybe_from_ty(ty),
        .                       GenericArgKind::Const(ct) => Self::maybe_from_const(ct),
        .                       GenericArgKind::Lifetime(_) => None,
        .                   }
    5,228 ( 0.00%)      }
        .           
        .               /// Tries to extract an inference variable from a type, returns `None`
        .               /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`).
       98 ( 0.00%)      pub fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {
   46,992 ( 0.00%)          match *ty.kind() {
    9,740 ( 0.00%)              ty::Infer(ty::TyVar(v)) => Some(TyOrConstInferVar::Ty(v)),
      900 ( 0.00%)              ty::Infer(ty::IntVar(v)) => Some(TyOrConstInferVar::TyInt(v)),
        .                       ty::Infer(ty::FloatVar(v)) => Some(TyOrConstInferVar::TyFloat(v)),
        .                       _ => None,
        .                   }
       98 ( 0.00%)      }
        .           
        .               /// Tries to extract an inference variable from a constant, returns `None`
        .               /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).
        .               pub fn maybe_from_const(ct: &'tcx ty::Const<'tcx>) -> Option<Self> {
        .                   match ct.val {
        .                       ty::ConstKind::Infer(InferConst::Var(v)) => Some(TyOrConstInferVar::Const(v)),
        .                       _ => None,
        .                   }
-- line 1749 ----------------------------------------
-- line 1755 ----------------------------------------
        .           }
        .           
        .           impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {
        .               fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {
        .                   self.infcx.tcx
        .               }
        .           
        .               fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {
  204,831 ( 0.01%)          self.infcx.shallow_resolve_ty(ty)
        .               }
        .           
    1,060 ( 0.00%)      fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {
      910 ( 0.00%)          if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {
      950 ( 0.00%)              self.infcx
        .                           .inner
        .                           .borrow_mut()
        .                           .const_unification_table()
      570 ( 0.00%)                  .probe_value(*vid)
        .                           .val
        .                           .known()
        .                           .unwrap_or(ct)
        .                   } else {
        .                       ct
        .                   }
    1,325 ( 0.00%)      }
        .           }
        .           
        .           impl<'tcx> TypeTrace<'tcx> {
        .               pub fn span(&self) -> Span {
       40 ( 0.00%)          self.cause.span
        .               }
        .           
        .               pub fn types(
        .                   cause: &ObligationCause<'tcx>,
        .                   a_is_expected: bool,
        .                   a: Ty<'tcx>,
        .                   b: Ty<'tcx>,
        .               ) -> TypeTrace<'tcx> {
-- line 1792 ----------------------------------------
-- line 1800 ----------------------------------------
        .                   b: &'tcx ty::Const<'tcx>,
        .               ) -> TypeTrace<'tcx> {
        .                   TypeTrace { cause: cause.clone(), values: Consts(ExpectedFound::new(a_is_expected, a, b)) }
        .               }
        .           }
        .           
        .           impl<'tcx> SubregionOrigin<'tcx> {
        .               pub fn span(&self) -> Span {
      100 ( 0.00%)          match *self {
       20 ( 0.00%)              Subtype(ref a) => a.span(),
        .                       RelateObjectBound(a) => a,
        .                       RelateParamBound(a, ..) => a,
        .                       RelateRegionParamBound(a) => a,
        .                       Reborrow(a) => a,
        .                       ReborrowUpvar(a, _) => a,
        .                       DataBorrowed(_, a) => a,
        .                       ReferenceOutlivesReferent(_, a) => a,
        .                       CompareImplMethodObligation { span, .. } => span,
-- line 1817 ----------------------------------------
-- line 1818 ----------------------------------------
        .                       CompareImplTypeObligation { span, .. } => span,
        .                   }
        .               }
        .           
        .               pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self
        .               where
        .                   F: FnOnce() -> Self,
        .               {
    7,826 ( 0.00%)          match *cause.code() {
    1,631 ( 0.00%)              traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {
    8,155 ( 0.00%)                  SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)
        .                       }
        .           
        .                       traits::ObligationCauseCode::CompareImplMethodObligation {
        .                           impl_item_def_id,
        .                           trait_item_def_id,
        .                       } => SubregionOrigin::CompareImplMethodObligation {
        .                           span: cause.span,
        .                           impl_item_def_id,
-- line 1836 ----------------------------------------

1,095,401 ( 0.04%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_infer/src/infer/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/lib.rs
--------------------------------------------------------------------------------
Ir                 

-- line 84 ----------------------------------------
        .           pub struct SessionGlobals {
        .               symbol_interner: symbol::Interner,
        .               span_interner: Lock<span_encoding::SpanInterner>,
        .               hygiene_data: Lock<hygiene::HygieneData>,
        .               source_map: Lock<Option<Lrc<SourceMap>>>,
        .           }
        .           
        .           impl SessionGlobals {
       12 ( 0.00%)      pub fn new(edition: Edition) -> SessionGlobals {
       50 ( 0.00%)          SessionGlobals {
        2 ( 0.00%)              symbol_interner: symbol::Interner::fresh(),
        .                       span_interner: Lock::new(span_encoding::SpanInterner::default()),
        6 ( 0.00%)              hygiene_data: Lock::new(hygiene::HygieneData::new(edition)),
        .                       source_map: Lock::new(None),
        .                   }
       10 ( 0.00%)      }
        .           }
        .           
        .           #[inline]
        .           pub fn create_session_globals_then<R>(edition: Edition, f: impl FnOnce() -> R) -> R {
        1 ( 0.00%)      assert!(
        .                   !SESSION_GLOBALS.is_set(),
        .                   "SESSION_GLOBALS should never be overwritten! \
        .                    Use another thread if you need another SessionGlobals"
        .               );
        3 ( 0.00%)      let session_globals = SessionGlobals::new(edition);
        7 ( 0.00%)      SESSION_GLOBALS.set(&session_globals, f)
        1 ( 0.00%)  }
        .           
        .           #[inline]
        .           pub fn set_session_globals_then<R>(session_globals: &SessionGlobals, f: impl FnOnce() -> R) -> R {
        .               assert!(
        .                   !SESSION_GLOBALS.is_set(),
        .                   "SESSION_GLOBALS should never be overwritten! \
        .                    Use another thread if you need another SessionGlobals"
        .               );
-- line 119 ----------------------------------------
-- line 120 ----------------------------------------
        .               SESSION_GLOBALS.set(session_globals, f)
        .           }
        .           
        .           #[inline]
        .           pub fn create_default_session_if_not_set_then<R, F>(f: F) -> R
        .           where
        .               F: FnOnce(&SessionGlobals) -> R,
        .           {
        4 ( 0.00%)      create_session_if_not_set_then(edition::DEFAULT_EDITION, f)
        .           }
        .           
        .           #[inline]
        .           pub fn create_session_if_not_set_then<R, F>(edition: Edition, f: F) -> R
        .           where
        .               F: FnOnce(&SessionGlobals) -> R,
        .           {
        1 ( 0.00%)      if !SESSION_GLOBALS.is_set() {
        3 ( 0.00%)          let session_globals = SessionGlobals::new(edition);
       11 ( 0.00%)          SESSION_GLOBALS.set(&session_globals, || SESSION_GLOBALS.with(f))
        1 ( 0.00%)      } else {
        .                   SESSION_GLOBALS.with(f)
        .               }
        .           }
        .           
        .           #[inline]
        .           pub fn with_session_globals<R, F>(f: F) -> R
        .           where
        .               F: FnOnce(&SessionGlobals) -> R,
        .           {
  574,667 ( 0.02%)      SESSION_GLOBALS.with(f)
        .           }
        .           
        .           #[inline]
        .           pub fn create_default_session_globals_then<R>(f: impl FnOnce() -> R) -> R {
        .               create_session_globals_then(edition::DEFAULT_EDITION, f)
        .           }
        .           
        .           // If this ever becomes non thread-local, `decode_syntax_context`
        .           // and `decode_expn_id` will need to be updated to handle concurrent
        .           // deserialization.
        .           scoped_tls::scoped_thread_local!(static SESSION_GLOBALS: SessionGlobals);
        .           
        .           // FIXME: We should use this enum or something like it to get rid of the
        .           // use of magic `/rust/1.x/...` paths across the board.
       45 ( 0.00%)  #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd)]
    1,050 ( 0.00%)  #[derive(Decodable)]
        .           pub enum RealFileName {
        .               LocalPath(PathBuf),
        .               /// For remapped paths (namely paths into libstd that have been mapped
        .               /// to the appropriate spot on the local host's file system, and local file
        .               /// system paths that have been remapped with `FilePathMapping`),
        .               Remapped {
        .                   /// `local_path` is the (host-dependent) local path to the file. This is
        .                   /// None if the file was imported from another crate
-- line 173 ----------------------------------------
-- line 179 ----------------------------------------
        .           }
        .           
        .           impl Hash for RealFileName {
        .               fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        .                   // To prevent #70924 from happening again we should only hash the
        .                   // remapped (virtualized) path if that exists. This is because
        .                   // virtualized paths to sysroot crates (/rust/$hash or /rust/$version)
        .                   // remain stable even if the corresponding local_path changes
    2,954 ( 0.00%)          self.remapped_path_if_available().hash(state)
        .               }
        .           }
        .           
        .           // This is functionally identical to #[derive(Encodable)], with the exception of
        .           // an added assert statement
        .           impl<S: Encoder> Encodable<S> for RealFileName {
        .               fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {
       34 ( 0.00%)          encoder.emit_enum(|encoder| match *self {
        .                       RealFileName::LocalPath(ref local_path) => {
      136 ( 0.00%)                  encoder.emit_enum_variant("LocalPath", 0, 1, |encoder| {
        .                               encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;
        .                               Ok(())
        .                           })
        .                       }
        .           
        .                       RealFileName::Remapped { ref local_path, ref virtual_name } => encoder
        .                           .emit_enum_variant("Remapped", 1, 2, |encoder| {
        .                               // For privacy and build reproducibility, we must not embed host-dependant path in artifacts
-- line 205 ----------------------------------------
-- line 224 ----------------------------------------
        .                           p.as_ref().map(PathBuf::as_path)
        .                       }
        .                   }
        .               }
        .           
        .               /// Returns the path suitable for reading from the file system on the local host,
        .               /// if this information exists.
        .               /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.
        2 ( 0.00%)      pub fn into_local_path(self) -> Option<PathBuf> {
        2 ( 0.00%)          match self {
        .                       RealFileName::LocalPath(p) => Some(p),
        .                       RealFileName::Remapped { local_path: p, virtual_name: _ } => p,
        .                   }
        3 ( 0.00%)      }
        .           
        .               /// Returns the path suitable for embedding into build artifacts. This would still
        .               /// be a local path if it has not been remapped. A remapped path will not correspond
        .               /// to a valid file system path: see `local_path_if_available()` for something that
        .               /// is more likely to return paths into the local host file system.
        .               pub fn remapped_path_if_available(&self) -> &Path {
    3,272 ( 0.00%)          match self {
        .                       RealFileName::LocalPath(p)
        .                       | RealFileName::Remapped { local_path: _, virtual_name: p } => &p,
        .                   }
       18 ( 0.00%)      }
        .           
        .               /// Returns the path suitable for reading from the file system on the local host,
        .               /// if this information exists. Otherwise returns the remapped name.
        .               /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.
        .               pub fn local_path_if_available(&self) -> &Path {
       17 ( 0.00%)          match self {
        .                       RealFileName::LocalPath(path)
        .                       | RealFileName::Remapped { local_path: None, virtual_name: path }
        .                       | RealFileName::Remapped { local_path: Some(path), virtual_name: _ } => path,
        .                   }
        .               }
        .           
        .               pub fn to_string_lossy(&self, display_pref: FileNameDisplayPreference) -> Cow<'_, str> {
      499 ( 0.00%)          match display_pref {
        .                       FileNameDisplayPreference::Local => self.local_path_if_available().to_string_lossy(),
        .                       FileNameDisplayPreference::Remapped => {
        .                           self.remapped_path_if_available().to_string_lossy()
        .                       }
        .                   }
        .               }
        .           }
        .           
        .           /// Differentiates between real files and common virtual files.
    6,282 ( 0.00%)  #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]
    6,561 ( 0.00%)  #[derive(Decodable, Encodable)]
        .           pub enum FileName {
        .               Real(RealFileName),
        .               /// Call to `quote!`.
        3 ( 0.00%)      QuoteExpansion(u64),
        .               /// Command line.
        .               Anon(u64),
        .               /// Hack in `src/librustc_ast/parse.rs`.
        .               // FIXME(jseyfried)
        .               MacroExpansion(u64),
        .               ProcMacroSourceCode(u64),
        .               /// Strings provided as `--cfg [cfgspec]` stored in a `crate_cfg`.
        .               CfgSpec(u64),
-- line 285 ----------------------------------------
-- line 288 ----------------------------------------
        .               /// Custom sources for explicit parser calls from plugins and drivers.
        .               Custom(String),
        .               DocTest(PathBuf, isize),
        .               /// Post-substitution inline assembly from LLVM.
        .               InlineAsm(u64),
        .           }
        .           
        .           impl From<PathBuf> for FileName {
      119 ( 0.00%)      fn from(p: PathBuf) -> Self {
       34 ( 0.00%)          assert!(!p.to_string_lossy().ends_with('>'));
      102 ( 0.00%)          FileName::Real(RealFileName::LocalPath(p))
      119 ( 0.00%)      }
        .           }
        .           
       34 ( 0.00%)  #[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]
        .           pub enum FileNameDisplayPreference {
        .               Remapped,
        .               Local,
        .           }
        .           
        .           pub struct FileNameDisplay<'a> {
        .               inner: &'a FileName,
        .               display_pref: FileNameDisplayPreference,
        .           }
        .           
        .           impl fmt::Display for FileNameDisplay<'_> {
      100 ( 0.00%)      fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        .                   use FileName::*;
      150 ( 0.00%)          match *self.inner {
        .                       Real(ref name) => {
      150 ( 0.00%)                  write!(fmt, "{}", name.to_string_lossy(self.display_pref))
        .                       }
        .                       QuoteExpansion(_) => write!(fmt, "<quote expansion>"),
        .                       MacroExpansion(_) => write!(fmt, "<macro expansion>"),
        .                       Anon(_) => write!(fmt, "<anon>"),
        .                       ProcMacroSourceCode(_) => write!(fmt, "<proc-macro source code>"),
        .                       CfgSpec(_) => write!(fmt, "<cfgspec>"),
        .                       CliCrateAttr(_) => write!(fmt, "<crate attribute>"),
        .                       Custom(ref s) => write!(fmt, "<{}>", s),
        .                       DocTest(ref path, _) => write!(fmt, "{}", path.display()),
        .                       InlineAsm(_) => write!(fmt, "<inline asm>"),
        .                   }
      125 ( 0.00%)      }
        .           }
        .           
        .           impl FileNameDisplay<'_> {
    1,896 ( 0.00%)      pub fn to_string_lossy(&self) -> Cow<'_, str> {
    1,422 ( 0.00%)          match self.inner {
      474 ( 0.00%)              FileName::Real(ref inner) => inner.to_string_lossy(self.display_pref),
        .                       _ => Cow::from(format!("{}", self)),
        .                   }
    1,896 ( 0.00%)      }
        .           }
        .           
        .           impl FileName {
        .               pub fn is_real(&self) -> bool {
        .                   use FileName::*;
    1,090 ( 0.00%)          match *self {
        .                       Real(_) => true,
        .                       Anon(_)
        .                       | MacroExpansion(_)
        .                       | ProcMacroSourceCode(_)
        .                       | CfgSpec(_)
        .                       | CliCrateAttr(_)
        .                       | Custom(_)
        .                       | QuoteExpansion(_)
        .                       | DocTest(_, _)
        .                       | InlineAsm(_) => false,
        .                   }
        .               }
        .           
      474 ( 0.00%)      pub fn prefer_remapped(&self) -> FileNameDisplay<'_> {
        .                   FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Remapped }
      948 ( 0.00%)      }
        .           
        .               // This may include transient local filesystem information.
        .               // Must not be embedded in build outputs.
       17 ( 0.00%)      pub fn prefer_local(&self) -> FileNameDisplay<'_> {
        .                   FileNameDisplay { inner: self, display_pref: FileNameDisplayPreference::Local }
       34 ( 0.00%)      }
        .           
        .               pub fn display(&self, display_pref: FileNameDisplayPreference) -> FileNameDisplay<'_> {
        .                   FileNameDisplay { inner: self, display_pref }
        .               }
        .           
        .               pub fn macro_expansion_source_code(src: &str) -> FileName {
        .                   let mut hasher = StableHasher::new();
        .                   src.hash(&mut hasher);
-- line 375 ----------------------------------------
-- line 383 ----------------------------------------
        .               }
        .           
        .               pub fn proc_macro_source_code(src: &str) -> FileName {
        .                   let mut hasher = StableHasher::new();
        .                   src.hash(&mut hasher);
        .                   FileName::ProcMacroSourceCode(hasher.finish())
        .               }
        .           
       15 ( 0.00%)      pub fn cfg_spec_source_code(src: &str) -> FileName {
        .                   let mut hasher = StableHasher::new();
        .                   src.hash(&mut hasher);
        6 ( 0.00%)          FileName::QuoteExpansion(hasher.finish())
       15 ( 0.00%)      }
        .           
        .               pub fn cli_crate_attr_source_code(src: &str) -> FileName {
        .                   let mut hasher = StableHasher::new();
        .                   src.hash(&mut hasher);
        .                   FileName::CliCrateAttr(hasher.finish())
        .               }
        .           
        .               pub fn doc_test_source_code(path: PathBuf, line: isize) -> FileName {
-- line 403 ----------------------------------------
-- line 423 ----------------------------------------
        .           /// that the length of the span is equal to `span.hi - span.lo`; there may be space in the
        .           /// [`BytePos`] range between files.
        .           ///
        .           /// `SpanData` is public because `Span` uses a thread-local interner and can't be
        .           /// sent to other threads, but some pieces of performance infra run in a separate thread.
        .           /// Using `Span` is generally preferred.
        .           #[derive(Clone, Copy, Hash, PartialEq, Eq)]
        .           pub struct SpanData {
        8 ( 0.00%)      pub lo: BytePos,
        8 ( 0.00%)      pub hi: BytePos,
        .               /// Information about where the macro came from, if this piece of
        .               /// code was created by a macro expansion.
       24 ( 0.00%)      pub ctxt: SyntaxContext,
        8 ( 0.00%)      pub parent: Option<LocalDefId>,
        .           }
        .           
        .           // Order spans by position in the file.
        .           impl Ord for SpanData {
        .               fn cmp(&self, other: &Self) -> Ordering {
        .                   let SpanData {
        .                       lo: s_lo,
        .                       hi: s_hi,
-- line 444 ----------------------------------------
-- line 485 ----------------------------------------
        .               }
        .               #[inline]
        .               pub fn with_parent(&self, parent: Option<LocalDefId>) -> Span {
        .                   Span::new(self.lo, self.hi, self.ctxt, parent)
        .               }
        .               /// Returns `true` if this is a dummy span with any hygienic context.
        .               #[inline]
        .               pub fn is_dummy(self) -> bool {
  244,856 ( 0.01%)          self.lo.0 == 0 && self.hi.0 == 0
        .               }
        .               /// Returns `true` if `self` fully encloses `other`.
        .               pub fn contains(self, other: Self) -> bool {
    1,248 ( 0.00%)          self.lo <= other.lo && other.hi <= self.hi
        .               }
        .           }
        .           
        .           // The interner is pointed to by a thread local value which is only set on the main thread
        .           // with parallelization is disabled. So we don't allow `Span` to transfer between threads
        .           // to avoid panics and other errors, even though it would be memory safe to do so.
        .           #[cfg(not(parallel_compiler))]
        .           impl !Send for Span {}
        .           #[cfg(not(parallel_compiler))]
        .           impl !Sync for Span {}
        .           
        .           impl PartialOrd for Span {
   39,488 ( 0.00%)      fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {
   29,616 ( 0.00%)          PartialOrd::partial_cmp(&self.data(), &rhs.data())
   39,488 ( 0.00%)      }
        .           }
        .           impl Ord for Span {
        .               fn cmp(&self, rhs: &Self) -> Ordering {
        .                   Ord::cmp(&self.data(), &rhs.data())
        .               }
        .           }
        .           
        .           /// A collection of `Span`s.
-- line 520 ----------------------------------------
-- line 532 ----------------------------------------
        .           }
        .           
        .           impl Span {
        .               #[inline]
        .               pub fn lo(self) -> BytePos {
        .                   self.data().lo
        .               }
        .               #[inline]
   50,949 ( 0.00%)      pub fn with_lo(self, lo: BytePos) -> Span {
        .                   self.data().with_lo(lo)
   33,966 ( 0.00%)      }
        .               #[inline]
    9,588 ( 0.00%)      pub fn hi(self) -> BytePos {
        .                   self.data().hi
    9,588 ( 0.00%)      }
        .               #[inline]
   30,870 ( 0.00%)      pub fn with_hi(self, hi: BytePos) -> Span {
        .                   self.data().with_hi(hi)
   20,580 ( 0.00%)      }
        .               #[inline]
        .               pub fn ctxt(self) -> SyntaxContext {
        .                   self.data_untracked().ctxt
        .               }
        .               #[inline]
    6,375 ( 0.00%)      pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {
        .                   self.data_untracked().with_ctxt(ctxt)
    3,825 ( 0.00%)      }
        .               #[inline]
        .               pub fn parent(self) -> Option<LocalDefId> {
        .                   self.data().parent
        .               }
        .               #[inline]
        .               pub fn with_parent(self, ctxt: Option<LocalDefId>) -> Span {
        .                   self.data().with_parent(ctxt)
        .               }
-- line 566 ----------------------------------------
-- line 568 ----------------------------------------
        .               /// Returns `true` if this is a dummy span with any hygienic context.
        .               #[inline]
        .               pub fn is_dummy(self) -> bool {
        .                   self.data_untracked().is_dummy()
        .               }
        .           
        .               /// Returns `true` if this span comes from a macro or desugaring.
        .               #[inline]
       18 ( 0.00%)      pub fn from_expansion(self) -> bool {
        .                   self.ctxt() != SyntaxContext::root()
       12 ( 0.00%)      }
        .           
        .               /// Returns `true` if `span` originates in a derive-macro's expansion.
        .               pub fn in_derive_expansion(self) -> bool {
        .                   matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))
        .               }
        .           
        .               /// Gate suggestions that would not be appropriate in a context the user didn't write.
        .               pub fn can_be_used_for_suggestions(self) -> bool {
-- line 586 ----------------------------------------
-- line 600 ----------------------------------------
        .               /// Returns a new span representing an empty span at the beginning of this span.
        .               #[inline]
        .               pub fn shrink_to_lo(self) -> Span {
        .                   let span = self.data_untracked();
        .                   span.with_hi(span.lo)
        .               }
        .               /// Returns a new span representing an empty span at the end of this span.
        .               #[inline]
      306 ( 0.00%)      pub fn shrink_to_hi(self) -> Span {
        .                   let span = self.data_untracked();
        .                   span.with_lo(span.hi)
      204 ( 0.00%)      }
        .           
        .               #[inline]
        .               /// Returns `true` if `hi == lo`.
        .               pub fn is_empty(self) -> bool {
        .                   let span = self.data_untracked();
        .                   span.hi == span.lo
        .               }
        .           
        .               /// Returns `self` if `self` is not the dummy span, and `other` otherwise.
        .               pub fn substitute_dummy(self, other: Span) -> Span {
        .                   if self.is_dummy() { other } else { self }
        .               }
        .           
        .               /// Returns `true` if `self` fully encloses `other`.
    3,744 ( 0.00%)      pub fn contains(self, other: Span) -> bool {
        .                   let span = self.data();
        .                   let other = other.data();
        .                   span.contains(other)
    2,496 ( 0.00%)      }
        .           
        .               /// Returns `true` if `self` touches `other`.
        .               pub fn overlaps(self, other: Span) -> bool {
        .                   let span = self.data();
        .                   let other = other.data();
        .                   span.lo < other.hi && other.lo < span.hi
        .               }
        .           
-- line 638 ----------------------------------------
-- line 663 ----------------------------------------
        .               /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,
        .               /// if any.
        .               pub fn parent_callsite(self) -> Option<Span> {
        .                   let expn_data = self.ctxt().outer_expn_data();
        .                   if !expn_data.is_root() { Some(expn_data.call_site) } else { None }
        .               }
        .           
        .               /// Walk down the expansion ancestors to find a span that's contained within `outer`.
      970 ( 0.00%)      pub fn find_ancestor_inside(mut self, outer: Span) -> Option<Span> {
      485 ( 0.00%)          while !outer.contains(self) {
        .                       self = self.parent_callsite()?;
        .                   }
        .                   Some(self)
    1,067 ( 0.00%)      }
        .           
        .               /// Edition of the crate from which this span came.
   15,450 ( 0.00%)      pub fn edition(self) -> edition::Edition {
        .                   self.ctxt().edition()
   10,300 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn rust_2015(self) -> bool {
    3,338 ( 0.00%)          self.edition() == edition::Edition::Edition2015
        .               }
        .           
        .               #[inline]
        .               pub fn rust_2018(self) -> bool {
    1,652 ( 0.00%)          self.edition() >= edition::Edition::Edition2018
        .               }
        .           
        .               #[inline]
        .               pub fn rust_2021(self) -> bool {
    1,990 ( 0.00%)          self.edition() >= edition::Edition::Edition2021
        .               }
        .           
        .               /// Returns the source callee.
        .               ///
        .               /// Returns `None` if the supplied span has no expansion trace,
        .               /// else returns the `ExpnData` for the macro definition
        .               /// corresponding to the source callsite.
        .               pub fn source_callee(self) -> Option<ExpnData> {
-- line 703 ----------------------------------------
-- line 707 ----------------------------------------
        .                   }
        .                   let expn_data = self.ctxt().outer_expn_data();
        .                   if !expn_data.is_root() { Some(source_callee(expn_data)) } else { None }
        .               }
        .           
        .               /// Checks if a span is "internal" to a macro in which `#[unstable]`
        .               /// items can be used (that is, a macro marked with
        .               /// `#[allow_internal_unstable]`).
    1,890 ( 0.00%)      pub fn allows_unstable(self, feature: Symbol) -> bool {
      378 ( 0.00%)          self.ctxt()
        .                       .outer_expn_data()
        .                       .allow_internal_unstable
        .                       .map_or(false, |features| features.iter().any(|&f| f == feature))
    1,512 ( 0.00%)      }
        .           
        .               /// Checks if this span arises from a compiler desugaring of kind `kind`.
    6,818 ( 0.00%)      pub fn is_desugaring(self, kind: DesugaringKind) -> bool {
    5,844 ( 0.00%)          match self.ctxt().outer_expn_data().kind {
        .                       ExpnKind::Desugaring(k) => k == kind,
        .                       _ => false,
        .                   }
    4,870 ( 0.00%)      }
        .           
        .               /// Returns the compiler desugaring that created this span, or `None`
        .               /// if this span is not from a desugaring.
      520 ( 0.00%)      pub fn desugaring_kind(self) -> Option<DesugaringKind> {
      624 ( 0.00%)          match self.ctxt().outer_expn_data().kind {
        .                       ExpnKind::Desugaring(k) => Some(k),
        .                       _ => None,
        .                   }
      416 ( 0.00%)      }
        .           
        .               /// Checks if a span is "internal" to a macro in which `unsafe`
        .               /// can be used without triggering the `unsafe_code` lint.
        .               //  (that is, a macro marked with `#[allow_internal_unsafe]`).
        .               pub fn allows_unsafe(self) -> bool {
        .                   self.ctxt().outer_expn_data().allow_internal_unsafe
        .               }
        .           
-- line 745 ----------------------------------------
-- line 767 ----------------------------------------
        .           
        .               /// Returns a `Span` that would enclose both `self` and `end`.
        .               ///
        .               /// ```text
        .               ///     ____             ___
        .               ///     self lorem ipsum end
        .               ///     ^^^^^^^^^^^^^^^^^^^^
        .               /// ```
  334,939 ( 0.01%)      pub fn to(self, end: Span) -> Span {
        .                   let span_data = self.data();
        .                   let end_data = end.data();
        .                   // FIXME(jseyfried): `self.ctxt` should always equal `end.ctxt` here (cf. issue #23480).
        .                   // Return the macro span on its own to avoid weird diagnostic output. It is preferable to
        .                   // have an incomplete span than a completely nonsensical one.
   59,518 ( 0.00%)          if span_data.ctxt != end_data.ctxt {
    1,380 ( 0.00%)              if span_data.ctxt == SyntaxContext::root() {
        .                           return end;
    1,203 ( 0.00%)              } else if end_data.ctxt == SyntaxContext::root() {
        .                           return self;
        .                       }
        .                       // Both spans fall within a macro.
        .                       // FIXME(estebank): check if it is the *same* macro.
        .                   }
        .                   Span::new(
        .                       cmp::min(span_data.lo, end_data.lo),
        .                       cmp::max(span_data.hi, end_data.hi),
        .                       if span_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },
  204,099 ( 0.01%)              if span_data.parent == end_data.parent { span_data.parent } else { None },
        .                   )
  274,041 ( 0.01%)      }
        .           
        .               /// Returns a `Span` between the end of `self` to the beginning of `end`.
        .               ///
        .               /// ```text
        .               ///     ____             ___
        .               ///     self lorem ipsum end
        .               ///         ^^^^^^^^^^^^^
        .               /// ```
    2,167 ( 0.00%)      pub fn between(self, end: Span) -> Span {
        .                   let span = self.data();
        .                   let end = end.data();
        .                   Span::new(
        .                       span.hi,
        .                       end.lo,
        .                       if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },
    1,379 ( 0.00%)              if span.parent == end.parent { span.parent } else { None },
        .                   )
    1,576 ( 0.00%)      }
        .           
        .               /// Returns a `Span` from the beginning of `self` until the beginning of `end`.
        .               ///
        .               /// ```text
        .               ///     ____             ___
        .               ///     self lorem ipsum end
        .               ///     ^^^^^^^^^^^^^^^^^
        .               /// ```
    3,267 ( 0.00%)      pub fn until(self, end: Span) -> Span {
        .                   // Most of this function's body is copied from `to`.
        .                   // We can't just do `self.to(end.shrink_to_lo())`,
        .                   // because to also does some magic where it uses min/max so
        .                   // it can handle overlapping spans. Some advanced mis-use of
        .                   // `until` with different ctxts makes this visible.
        .                   let span_data = self.data();
        .                   let end_data = end.data();
        .                   // FIXME(jseyfried): `self.ctxt` should always equal `end.ctxt` here (cf. issue #23480).
        .                   // Return the macro span on its own to avoid weird diagnostic output. It is preferable to
        .                   // have an incomplete span than a completely nonsensical one.
      594 ( 0.00%)          if span_data.ctxt != end_data.ctxt {
        .                       if span_data.ctxt == SyntaxContext::root() {
        .                           return end;
        .                       } else if end_data.ctxt == SyntaxContext::root() {
        .                           return self;
        .                       }
        .                       // Both spans fall within a macro.
        .                       // FIXME(estebank): check if it is the *same* macro.
        .                   }
        .                   Span::new(
        .                       span_data.lo,
        .                       end_data.lo,
        .                       if end_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },
    2,079 ( 0.00%)              if span_data.parent == end_data.parent { span_data.parent } else { None },
        .                   )
    2,673 ( 0.00%)      }
        .           
      242 ( 0.00%)      pub fn from_inner(self, inner: InnerSpan) -> Span {
        .                   let span = self.data();
        .                   Span::new(
        .                       span.lo + BytePos::from_usize(inner.start),
        .                       span.lo + BytePos::from_usize(inner.end),
        .                       span.ctxt,
        .                       span.parent,
        .                   )
      154 ( 0.00%)      }
        .           
        .               /// Equivalent of `Span::def_site` from the proc macro API,
        .               /// except that the location is taken from the `self` span.
        .               pub fn with_def_site_ctxt(self, expn_id: ExpnId) -> Span {
    1,602 ( 0.00%)          self.with_ctxt_from_mark(expn_id, Transparency::Opaque)
        .               }
        .           
        .               /// Equivalent of `Span::call_site` from the proc macro API,
        .               /// except that the location is taken from the `self` span.
        .               pub fn with_call_site_ctxt(self, expn_id: ExpnId) -> Span {
       26 ( 0.00%)          self.with_ctxt_from_mark(expn_id, Transparency::Transparent)
        .               }
        .           
        .               /// Equivalent of `Span::mixed_site` from the proc macro API,
        .               /// except that the location is taken from the `self` span.
        .               pub fn with_mixed_site_ctxt(self, expn_id: ExpnId) -> Span {
        .                   self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)
        .               }
        .           
        .               /// Produces a span with the same location as `self` and context produced by a macro with the
        .               /// given ID and transparency, assuming that macro was defined directly and not produced by
        .               /// some other macro (which is the case for built-in and procedural macros).
    9,768 ( 0.00%)      pub fn with_ctxt_from_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {
        .                   self.with_ctxt(SyntaxContext::root().apply_mark(expn_id, transparency))
    5,698 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {
        .                   let span = self.data();
   67,077 ( 0.00%)          span.with_ctxt(span.ctxt.apply_mark(expn_id, transparency))
        .               }
        .           
        .               #[inline]
        .               pub fn remove_mark(&mut self) -> ExpnId {
        .                   let mut span = self.data();
        .                   let mark = span.ctxt.remove_mark();
        .                   *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                   mark
-- line 897 ----------------------------------------
-- line 901 ----------------------------------------
        .               pub fn adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {
        .                   let mut span = self.data();
        .                   let mark = span.ctxt.adjust(expn_id);
        .                   *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                   mark
        .               }
        .           
        .               #[inline]
   52,497 ( 0.00%)      pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {
   34,998 ( 0.00%)          let mut span = self.data();
   28,461 ( 0.00%)          let mark = span.ctxt.normalize_to_macros_2_0_and_adjust(expn_id);
   52,497 ( 0.00%)          *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                   mark
   57,626 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {
        .                   let mut span = self.data();
        .                   let mark = span.ctxt.glob_adjust(expn_id, glob_span);
        .                   *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                   mark
        .               }
        .           
        .               #[inline]
        .               pub fn reverse_glob_adjust(
        .                   &mut self,
        .                   expn_id: ExpnId,
        .                   glob_span: Span,
        .               ) -> Option<Option<ExpnId>> {
      124 ( 0.00%)          let mut span = self.data();
      248 ( 0.00%)          let mark = span.ctxt.reverse_glob_adjust(expn_id, glob_span);
      496 ( 0.00%)          *self = Span::new(span.lo, span.hi, span.ctxt, span.parent);
        .                   mark
        .               }
        .           
        .               #[inline]
   52,408 ( 0.00%)      pub fn normalize_to_macros_2_0(self) -> Span {
        .                   let span = self.data();
        .                   span.with_ctxt(span.ctxt.normalize_to_macros_2_0())
   45,857 ( 0.00%)      }
        .           
        .               #[inline]
        .               pub fn normalize_to_macro_rules(self) -> Span {
        .                   let span = self.data();
        .                   span.with_ctxt(span.ctxt.normalize_to_macro_rules())
        .               }
        .           }
        .           
-- line 948 ----------------------------------------
-- line 958 ----------------------------------------
        .           
        .               /// What label should we attach to this span (if any)?
        .               pub label: Option<String>,
        .           }
        .           
        .           impl Default for Span {
        .               fn default() -> Self {
        .                   DUMMY_SP
        2 ( 0.00%)      }
        .           }
        .           
        .           impl<E: Encoder> Encodable<E> for Span {
        .               default fn encode(&self, s: &mut E) -> Result<(), E::Error> {
        .                   let span = self.data();
        .                   s.emit_struct(false, |s| {
        .                       s.emit_struct_field("lo", true, |s| span.lo.encode(s))?;
        .                       s.emit_struct_field("hi", false, |s| span.hi.encode(s))
-- line 974 ----------------------------------------
-- line 990 ----------------------------------------
        .           /// any spans that are debug-printed during the closure's execution.
        .           ///
        .           /// Normally, the global `TyCtxt` is used to retrieve the `SourceMap`
        .           /// (see `rustc_interface::callbacks::span_debug1`). However, some parts
        .           /// of the compiler (e.g. `rustc_parse`) may debug-print `Span`s before
        .           /// a `TyCtxt` is available. In this case, we fall back to
        .           /// the `SourceMap` provided to this function. If that is not available,
        .           /// we fall back to printing the raw `Span` field values.
        9 ( 0.00%)  pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) -> T {
        .               with_session_globals(|session_globals| {
        2 ( 0.00%)          *session_globals.source_map.borrow_mut() = Some(source_map);
        .               });
        .               struct ClearSourceMap;
        .               impl Drop for ClearSourceMap {
        .                   fn drop(&mut self) {
        .                       with_session_globals(|session_globals| {
        1 ( 0.00%)                  session_globals.source_map.borrow_mut().take();
        .                       });
        .                   }
        .               }
        .           
        .               let _guard = ClearSourceMap;
        4 ( 0.00%)      f()
        8 ( 0.00%)  }
        .           
        .           pub fn debug_with_source_map(
        .               span: Span,
        .               f: &mut fmt::Formatter<'_>,
        .               source_map: &SourceMap,
        .           ) -> fmt::Result {
        .               write!(f, "{} ({:?})", source_map.span_to_diagnostic_string(span), span.ctxt())
        .           }
-- line 1021 ----------------------------------------
-- line 1048 ----------------------------------------
        .           
        .           impl MultiSpan {
        .               #[inline]
        .               pub fn new() -> MultiSpan {
        .                   MultiSpan { primary_spans: vec![], span_labels: vec![] }
        .               }
        .           
        .               pub fn from_span(primary_span: Span) -> MultiSpan {
    2,510 ( 0.00%)          MultiSpan { primary_spans: vec![primary_span], span_labels: vec![] }
        .               }
        .           
        .               pub fn from_spans(mut vec: Vec<Span>) -> MultiSpan {
        .                   vec.sort();
      190 ( 0.00%)          MultiSpan { primary_spans: vec, span_labels: vec![] }
        .               }
        .           
        .               pub fn push_span_label(&mut self, span: Span, label: String) {
        .                   self.span_labels.push((span, label));
        .               }
        .           
        .               /// Selects the first primary span (if any).
        .               pub fn primary_span(&self) -> Option<Span> {
        .                   self.primary_spans.first().cloned()
      454 ( 0.00%)      }
        .           
        .               /// Returns all primary spans.
        .               pub fn primary_spans(&self) -> &[Span] {
        .                   &self.primary_spans
       11 ( 0.00%)      }
        .           
        .               /// Returns `true` if any of the primary spans are displayable.
        .               pub fn has_primary_spans(&self) -> bool {
        .                   self.primary_spans.iter().any(|sp| !sp.is_dummy())
        .               }
        .           
        .               /// Returns `true` if this contains only a dummy primary span with any hygienic context.
        .               pub fn is_dummy(&self) -> bool {
-- line 1084 ----------------------------------------
-- line 1139 ----------------------------------------
        .           
        .               /// Returns `true` if any of the span labels is displayable.
        .               pub fn has_span_labels(&self) -> bool {
        .                   self.span_labels.iter().any(|(sp, _)| !sp.is_dummy())
        .               }
        .           }
        .           
        .           impl From<Span> for MultiSpan {
    2,510 ( 0.00%)      fn from(span: Span) -> MultiSpan {
        .                   MultiSpan::from_span(span)
    2,510 ( 0.00%)      }
        .           }
        .           
        .           impl From<Vec<Span>> for MultiSpan {
      190 ( 0.00%)      fn from(spans: Vec<Span>) -> MultiSpan {
      152 ( 0.00%)          MultiSpan::from_spans(spans)
      190 ( 0.00%)      }
        .           }
        .           
        .           /// Identifies an offset of a multi-byte character in a `SourceFile`.
       66 ( 0.00%)  #[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]
        .           pub struct MultiByteChar {
        .               /// The absolute offset of the character in the `SourceMap`.
        .               pub pos: BytePos,
        .               /// The number of bytes, `>= 2`.
        .               pub bytes: u8,
        .           }
        .           
        .           /// Identifies an offset of a non-narrow character in a `SourceFile`.
      308 ( 0.00%)  #[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]
        .           pub enum NonNarrowChar {
        .               /// Represents a zero-width character.
        .               ZeroWidth(BytePos),
        .               /// Represents a wide (full-width) character.
        .               Wide(BytePos),
        .               /// Represents a tab character, represented visually with a width of 4 characters.
        .               Tab(BytePos),
        .           }
-- line 1176 ----------------------------------------
-- line 1201 ----------------------------------------
        .                   }
        .               }
        .           }
        .           
        .           impl Add<BytePos> for NonNarrowChar {
        .               type Output = Self;
        .           
        .               fn add(self, rhs: BytePos) -> Self {
      532 ( 0.00%)          match self {
        .                       NonNarrowChar::ZeroWidth(pos) => NonNarrowChar::ZeroWidth(pos + rhs),
        .                       NonNarrowChar::Wide(pos) => NonNarrowChar::Wide(pos + rhs),
        .                       NonNarrowChar::Tab(pos) => NonNarrowChar::Tab(pos + rhs),
        .                   }
        .               }
        .           }
        .           
        .           impl Sub<BytePos> for NonNarrowChar {
        .               type Output = Self;
        .           
      154 ( 0.00%)      fn sub(self, rhs: BytePos) -> Self {
      532 ( 0.00%)          match self {
        .                       NonNarrowChar::ZeroWidth(pos) => NonNarrowChar::ZeroWidth(pos - rhs),
        .                       NonNarrowChar::Wide(pos) => NonNarrowChar::Wide(pos - rhs),
        .                       NonNarrowChar::Tab(pos) => NonNarrowChar::Tab(pos - rhs),
        .                   }
      462 ( 0.00%)      }
        .           }
        .           
        .           /// Identifies an offset of a character that was normalized away from `SourceFile`.
        .           #[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]
        .           pub struct NormalizedPos {
        .               /// The absolute offset of the character in the `SourceMap`.
        .               pub pos: BytePos,
        .               /// The difference between original and normalized string at position.
        .               pub diff: u32,
        .           }
        .           
       51 ( 0.00%)  #[derive(PartialEq, Eq, Clone, Debug)]
        .           pub enum ExternalSource {
        .               /// No external source has to be loaded, since the `SourceFile` represents a local crate.
        .               Unneeded,
        .               Foreign {
        .                   kind: ExternalSourceKind,
        .                   /// This SourceFile's byte-offset within the source_map of its original crate.
        .                   original_start_pos: BytePos,
        .                   /// The end of this SourceFile within the source_map of its original crate.
-- line 1246 ----------------------------------------
-- line 1257 ----------------------------------------
        .               AbsentOk,
        .               /// A failed attempt has been made to load the external source.
        .               AbsentErr,
        .               Unneeded,
        .           }
        .           
        .           impl ExternalSource {
        .               pub fn get_source(&self) -> Option<&Lrc<String>> {
      216 ( 0.00%)          match self {
        .                       ExternalSource::Foreign { kind: ExternalSourceKind::Present(ref src), .. } => Some(src),
        .                       _ => None,
        .                   }
        .               }
        .           }
        .           
        .           #[derive(Debug)]
        .           pub struct OffsetOverflowError;
        .           
    1,066 ( 0.00%)  #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]
        .           pub enum SourceFileHashAlgorithm {
        .               Md5,
        .               Sha1,
        .               Sha256,
        .           }
        .           
        .           impl FromStr for SourceFileHashAlgorithm {
        .               type Err = ();
-- line 1283 ----------------------------------------
-- line 1290 ----------------------------------------
        .                       _ => Err(()),
        .                   }
        .               }
        .           }
        .           
        .           rustc_data_structures::impl_stable_hash_via_hash!(SourceFileHashAlgorithm);
        .           
        .           /// The hash of the on-disk source file used for debug info.
      102 ( 0.00%)  #[derive(Copy, Clone, PartialEq, Eq, Debug)]
    2,132 ( 0.00%)  #[derive(HashStable_Generic, Encodable, Decodable)]
        .           pub struct SourceFileHash {
        .               pub kind: SourceFileHashAlgorithm,
        .               value: [u8; 32],
        .           }
        .           
        .           impl SourceFileHash {
        .               pub fn new(kind: SourceFileHashAlgorithm, src: &str) -> SourceFileHash {
        .                   let mut hash = SourceFileHash { kind, value: Default::default() };
        .                   let len = hash.hash_len();
        .                   let value = &mut hash.value[..len];
        .                   let data = src.as_bytes();
        .                   match kind {
        .                       SourceFileHashAlgorithm::Md5 => {
       60 ( 0.00%)                  value.copy_from_slice(&Md5::digest(data));
        .                       }
        .                       SourceFileHashAlgorithm::Sha1 => {
        .                           value.copy_from_slice(&Sha1::digest(data));
        .                       }
        .                       SourceFileHashAlgorithm::Sha256 => {
        .                           value.copy_from_slice(&Sha256::digest(data));
        .                       }
        .                   }
-- line 1321 ----------------------------------------
-- line 1329 ----------------------------------------
        .           
        .               /// The bytes of the hash.
        .               pub fn hash_bytes(&self) -> &[u8] {
        .                   let len = self.hash_len();
        .                   &self.value[..len]
        .               }
        .           
        .               fn hash_len(&self) -> usize {
       60 ( 0.00%)          match self.kind {
        .                       SourceFileHashAlgorithm::Md5 => 16,
        .                       SourceFileHashAlgorithm::Sha1 => 20,
        .                       SourceFileHashAlgorithm::Sha256 => 32,
        .                   }
        .               }
        .           }
        .           
        .           /// A single source in the [`SourceMap`].
      986 ( 0.00%)  #[derive(Clone)]
        .           pub struct SourceFile {
        .               /// The name of the file that the source came from. Source that doesn't
        .               /// originate from files has names between angle brackets by convention
        .               /// (e.g., `<anon>`).
        .               pub name: FileName,
        .               /// The complete source code.
       17 ( 0.00%)      pub src: Option<Lrc<String>>,
        .               /// The source code's hash.
        .               pub src_hash: SourceFileHash,
        .               /// The external source code (used for external crates, which will have a `None`
        .               /// value as `self.src`.
        .               pub external_src: Lock<ExternalSource>,
        .               /// The start position of this source in the `SourceMap`.
        .               pub start_pos: BytePos,
        .               /// The end position of this source in the `SourceMap`.
-- line 1361 ----------------------------------------
-- line 1364 ----------------------------------------
        .               pub lines: Vec<BytePos>,
        .               /// Locations of multi-byte characters in the source code.
        .               pub multibyte_chars: Vec<MultiByteChar>,
        .               /// Width of characters that are not narrow in the source code.
        .               pub non_narrow_chars: Vec<NonNarrowChar>,
        .               /// Locations of characters removed during normalization.
        .               pub normalized_pos: Vec<NormalizedPos>,
        .               /// A hash of the filename, used for speeding up hashing in incremental compilation.
       17 ( 0.00%)      pub name_hash: u128,
        .               /// Indicates which crate this `SourceFile` was imported from.
       17 ( 0.00%)      pub cnum: CrateNum,
        .           }
        .           
        .           impl<S: Encoder> Encodable<S> for SourceFile {
        .               fn encode(&self, s: &mut S) -> Result<(), S::Error> {
        .                   s.emit_struct(false, |s| {
        .                       s.emit_struct_field("name", true, |s| self.name.encode(s))?;
        .                       s.emit_struct_field("src_hash", false, |s| self.src_hash.encode(s))?;
        .                       s.emit_struct_field("start_pos", false, |s| self.start_pos.encode(s))?;
        .                       s.emit_struct_field("end_pos", false, |s| self.end_pos.encode(s))?;
        .                       s.emit_struct_field("lines", false, |s| {
        .                           let lines = &self.lines[..];
        .                           // Store the length.
        .                           s.emit_u32(lines.len() as u32)?;
        .           
       68 ( 0.00%)                  if !lines.is_empty() {
        .                               // In order to preserve some space, we exploit the fact that
        .                               // the lines list is sorted and individual lines are
        .                               // probably not that long. Because of that we can store lines
        .                               // as a difference list, using as little space as possible
        .                               // for the differences.
        .                               let max_line_length = if lines.len() == 1 {
        .                                   0
        .                               } else {
-- line 1397 ----------------------------------------
-- line 1399 ----------------------------------------
        .                                       .array_windows()
        .                                       .map(|&[fst, snd]| snd - fst)
        .                                       .map(|bp| bp.to_usize())
        .                                       .max()
        .                                       .unwrap()
        .                               };
        .           
        .                               let bytes_per_diff: u8 = match max_line_length {
       34 ( 0.00%)                          0..=0xFF => 1,
        .                                   0x100..=0xFFFF => 2,
        .                                   _ => 4,
        .                               };
        .           
        .                               // Encode the number of bytes used per diff.
        .                               bytes_per_diff.encode(s)?;
        .           
        .                               // Encode the first element.
        .                               lines[0].encode(s)?;
        .           
        .                               let diff_iter = lines.array_windows().map(|&[fst, snd]| snd - fst);
        .           
       34 ( 0.00%)                      match bytes_per_diff {
        .                                   1 => {
        .                                       for diff in diff_iter {
        .                                           (diff.0 as u8).encode(s)?
        .                                       }
        .                                   }
        .                                   2 => {
        .                                       for diff in diff_iter {
        .                                           (diff.0 as u16).encode(s)?
-- line 1428 ----------------------------------------
-- line 1436 ----------------------------------------
        .                                   _ => unreachable!(),
        .                               }
        .                           }
        .           
        .                           Ok(())
        .                       })?;
        .                       s.emit_struct_field("multibyte_chars", false, |s| self.multibyte_chars.encode(s))?;
        .                       s.emit_struct_field("non_narrow_chars", false, |s| self.non_narrow_chars.encode(s))?;
       51 ( 0.00%)              s.emit_struct_field("name_hash", false, |s| self.name_hash.encode(s))?;
        .                       s.emit_struct_field("normalized_pos", false, |s| self.normalized_pos.encode(s))?;
      187 ( 0.00%)              s.emit_struct_field("cnum", false, |s| self.cnum.encode(s))
        .                   })
        .               }
        .           }
        .           
        .           impl<D: Decoder> Decodable<D> for SourceFile {
    4,797 ( 0.00%)      fn decode(d: &mut D) -> SourceFile {
        .                   d.read_struct(|d| {
        .                       let name: FileName = d.read_struct_field("name", |d| Decodable::decode(d));
        .                       let src_hash: SourceFileHash =
        .                           d.read_struct_field("src_hash", |d| Decodable::decode(d));
        .                       let start_pos: BytePos = d.read_struct_field("start_pos", |d| Decodable::decode(d));
        .                       let end_pos: BytePos = d.read_struct_field("end_pos", |d| Decodable::decode(d));
        .                       let lines: Vec<BytePos> = d.read_struct_field("lines", |d| {
        .                           let num_lines: u32 = Decodable::decode(d);
      533 ( 0.00%)                  let mut lines = Vec::with_capacity(num_lines as usize);
        .           
        .                           if num_lines > 0 {
        .                               // Read the number of bytes used per diff.
        .                               let bytes_per_diff: u8 = Decodable::decode(d);
        .           
        .                               // Read the first element.
        .                               let mut line_start: BytePos = Decodable::decode(d);
        .                               lines.push(line_start);
        .           
        .                               for _ in 1..num_lines {
  867,562 ( 0.03%)                          let diff = match bytes_per_diff {
        .                                       1 => d.read_u8() as u32,
        .                                       2 => d.read_u16() as u32,
        .                                       4 => d.read_u32(),
        .                                       _ => unreachable!(),
        .                                   };
        .           
        .                                   line_start = line_start + BytePos(diff);
        .           
-- line 1480 ----------------------------------------
-- line 1483 ----------------------------------------
        .                           }
        .           
        .                           lines
        .                       });
        .                       let multibyte_chars: Vec<MultiByteChar> =
        .                           d.read_struct_field("multibyte_chars", |d| Decodable::decode(d));
        .                       let non_narrow_chars: Vec<NonNarrowChar> =
        .                           d.read_struct_field("non_narrow_chars", |d| Decodable::decode(d));
    1,066 ( 0.00%)              let name_hash: u128 = d.read_struct_field("name_hash", |d| Decodable::decode(d));
        .                       let normalized_pos: Vec<NormalizedPos> =
        .                           d.read_struct_field("normalized_pos", |d| Decodable::decode(d));
        .                       let cnum: CrateNum = d.read_struct_field("cnum", |d| Decodable::decode(d));
    5,863 ( 0.00%)              SourceFile {
    4,264 ( 0.00%)                  name,
        .                           start_pos,
        .                           end_pos,
        .                           src: None,
    2,132 ( 0.00%)                  src_hash,
        .                           // Unused - the metadata decoder will construct
        .                           // a new SourceFile, filling in `external_src` properly
        .                           external_src: Lock::new(ExternalSource::Unneeded),
    2,132 ( 0.00%)                  lines,
    2,132 ( 0.00%)                  multibyte_chars,
    2,132 ( 0.00%)                  non_narrow_chars,
    2,132 ( 0.00%)                  normalized_pos,
        .                           name_hash,
        .                           cnum,
        .                       }
        .                   })
    4,797 ( 0.00%)      }
        .           }
        .           
        .           impl fmt::Debug for SourceFile {
        .               fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        .                   write!(fmt, "SourceFile({:?})", self.name)
        .               }
        .           }
        .           
        .           impl SourceFile {
      220 ( 0.00%)      pub fn new(
        .                   name: FileName,
        .                   mut src: String,
        .                   start_pos: BytePos,
        .                   hash_kind: SourceFileHashAlgorithm,
        .               ) -> Self {
        .                   // Compute the file hash before any normalization.
        .                   let src_hash = SourceFileHash::new(hash_kind, &src);
       60 ( 0.00%)          let normalized_pos = normalize_src(&mut src, start_pos);
        .           
        .                   let name_hash = {
        .                       let mut hasher: StableHasher = StableHasher::new();
       40 ( 0.00%)              name.hash(&mut hasher);
        .                       hasher.finish::<u128>()
        .                   };
       40 ( 0.00%)          let end_pos = start_pos.to_usize() + src.len();
       60 ( 0.00%)          assert!(end_pos <= u32::MAX as usize);
        .           
      240 ( 0.00%)          let (lines, multibyte_chars, non_narrow_chars) =
       40 ( 0.00%)              analyze_source_file::analyze_source_file(&src, start_pos);
        .           
      340 ( 0.00%)          SourceFile {
        .                       name,
        .                       src: Some(Lrc::new(src)),
      220 ( 0.00%)              src_hash,
        .                       external_src: Lock::new(ExternalSource::Unneeded),
        .                       start_pos,
        .                       end_pos: Pos::from_usize(end_pos),
       80 ( 0.00%)              lines,
       80 ( 0.00%)              multibyte_chars,
       80 ( 0.00%)              non_narrow_chars,
       80 ( 0.00%)              normalized_pos,
        .                       name_hash,
        .                       cnum: LOCAL_CRATE,
        .                   }
      180 ( 0.00%)      }
        .           
        .               /// Returns the `BytePos` of the beginning of the current line.
        .               pub fn line_begin_pos(&self, pos: BytePos) -> BytePos {
        .                   let line_index = self.lookup_line(pos).unwrap();
        .                   self.lines[line_index]
        .               }
        .           
        .               /// Add externally loaded source.
        .               /// If the hash of the input doesn't match or no input is supplied via None,
        .               /// it is interpreted as an error and the corresponding enum variant is set.
        .               /// The return value signifies whether some kind of source is present.
    4,753 ( 0.00%)      pub fn add_external_src<F>(&self, get_src: F) -> bool
        .               where
        .                   F: FnOnce() -> Option<String>,
        .               {
      679 ( 0.00%)          if matches!(
    1,358 ( 0.00%)              *self.external_src.borrow(),
        .                       ExternalSource::Foreign { kind: ExternalSourceKind::AbsentOk, .. }
        .                   ) {
        .                       let src = get_src();
        .                       let mut external_src = self.external_src.borrow_mut();
        .                       // Check that no-one else have provided the source while we were getting it
        .                       if let ExternalSource::Foreign {
        .                           kind: src_kind @ ExternalSourceKind::AbsentOk, ..
        .                       } = &mut *external_src
-- line 1582 ----------------------------------------
-- line 1592 ----------------------------------------
        .                               *src_kind = ExternalSourceKind::AbsentErr;
        .                           }
        .           
        .                           false
        .                       } else {
        .                           self.src.is_some() || external_src.get_source().is_some()
        .                       }
        .                   } else {
      679 ( 0.00%)              self.src.is_some() || self.external_src.borrow().get_source().is_some()
        .                   }
    6,111 ( 0.00%)      }
        .           
        .               /// Gets a line from the list of pre-computed line-beginnings.
        .               /// The line number here is 0-based.
        .               pub fn get_line(&self, line_number: usize) -> Option<Cow<'_, str>> {
        .                   fn get_until_newline(src: &str, begin: usize) -> &str {
        .                       // We can't use `lines.get(line_number+1)` because we might
        .                       // be parsing when we call this function and thus the current
        .                       // line is the last one we have line info for.
-- line 1610 ----------------------------------------
-- line 1627 ----------------------------------------
        .                       Some(Cow::Owned(String::from(get_until_newline(src, begin))))
        .                   } else {
        .                       None
        .                   }
        .               }
        .           
        .               pub fn is_real_file(&self) -> bool {
        .                   self.name.is_real()
      545 ( 0.00%)      }
        .           
        .               pub fn is_imported(&self) -> bool {
        .                   self.src.is_none()
   34,378 ( 0.00%)      }
        .           
        .               pub fn count_lines(&self) -> usize {
        .                   self.lines.len()
        .               }
        .           
        .               /// Finds the line containing the given position. The return value is the
        .               /// index into the `lines` array of this `SourceFile`, not the 1-based line
        .               /// number. If the source_file is empty or the position is located before the
        .               /// first line, `None` is returned.
        .               pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {
   13,069 ( 0.00%)          match self.lines.binary_search(&pos) {
        .                       Ok(idx) => Some(idx),
        .                       Err(0) => None,
        .                       Err(idx) => Some(idx - 1),
        .                   }
        .               }
        .           
        .               pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {
   31,288 ( 0.00%)          if self.is_empty() {
        .                       return self.start_pos..self.end_pos;
        .                   }
        .           
   21,980 ( 0.00%)          assert!(line_index < self.lines.len());
   30,216 ( 0.00%)          if line_index == (self.lines.len() - 1) {
       63 ( 0.00%)              self.lines[line_index]..self.end_pos
        .                   } else {
   20,092 ( 0.00%)              self.lines[line_index]..self.lines[line_index + 1]
        .                   }
        .               }
        .           
        .               /// Returns whether or not the file contains the given `SourceMap` byte
        .               /// position. The position one past the end of the file is considered to be
        .               /// contained by the file. This implies that files for which `is_empty`
        .               /// returns true still contain one byte position according to this function.
        .               #[inline]
-- line 1674 ----------------------------------------
-- line 1692 ----------------------------------------
        .                       Err(i) if i == 0 => 0,
        .                       Err(i) => self.normalized_pos[i - 1].diff,
        .                   };
        .           
        .                   BytePos::from_u32(pos.0 - self.start_pos.0 + diff)
        .               }
        .           
        .               /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.
      982 ( 0.00%)      pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {
        .                   // The number of extra bytes due to multibyte chars in the `SourceFile`.
        .                   let mut total_extra_bytes = 0;
        .           
    2,946 ( 0.00%)          for mbc in self.multibyte_chars.iter() {
        .                       debug!("{}-byte char at {:?}", mbc.bytes, mbc.pos);
    1,472 ( 0.00%)              if mbc.pos < bpos {
        .                           // Every character is at least one byte, so we only
        .                           // count the actual extra bytes.
    4,128 ( 0.00%)                  total_extra_bytes += mbc.bytes as u32 - 1;
        .                           // We should never see a byte position in the middle of a
        .                           // character.
    3,440 ( 0.00%)                  assert!(bpos.to_u32() >= mbc.pos.to_u32() + mbc.bytes as u32);
        .                       } else {
        .                           break;
        .                       }
        .                   }
        .           
    5,892 ( 0.00%)          assert!(self.start_pos.to_u32() + total_extra_bytes <= bpos.to_u32());
    4,910 ( 0.00%)          CharPos(bpos.to_usize() - self.start_pos.to_usize() - total_extra_bytes as usize)
    1,964 ( 0.00%)      }
        .           
        .               /// Looks up the file's (1-based) line number and (0-based `CharPos`) column offset, for a
        .               /// given `BytePos`.
    3,437 ( 0.00%)      pub fn lookup_file_pos(&self, pos: BytePos) -> (usize, CharPos) {
      982 ( 0.00%)          let chpos = self.bytepos_to_file_charpos(pos);
      472 ( 0.00%)          match self.lookup_line(pos) {
        .                       Some(a) => {
        .                           let line = a + 1; // Line numbers start at 1
      491 ( 0.00%)                  let linebpos = self.lines[a];
      982 ( 0.00%)                  let linechpos = self.bytepos_to_file_charpos(linebpos);
        .                           let col = chpos - linechpos;
        .                           debug!("byte pos {:?} is on the line at byte pos {:?}", pos, linebpos);
        .                           debug!("char pos {:?} is on the line at char pos {:?}", chpos, linechpos);
        .                           debug!("byte is on line: {}", line);
      491 ( 0.00%)                  assert!(chpos >= linechpos);
        .                           (line, col)
        .                       }
        .                       None => (0, chpos),
        .                   }
    3,928 ( 0.00%)      }
        .           
        .               /// Looks up the file's (1-based) line number, (0-based `CharPos`) column offset, and (0-based)
        .               /// column offset when displayed, for a given `BytePos`.
    3,928 ( 0.00%)      pub fn lookup_file_pos_with_col_display(&self, pos: BytePos) -> (usize, CharPos, usize) {
    1,473 ( 0.00%)          let (line, col_or_chpos) = self.lookup_file_pos(pos);
      982 ( 0.00%)          if line > 0 {
        .                       let col = col_or_chpos;
      491 ( 0.00%)              let linebpos = self.lines[line - 1];
        .                       let col_display = {
        .                           let start_width_idx = self
        .                               .non_narrow_chars
        .                               .binary_search_by_key(&linebpos, |x| x.pos())
        .                               .unwrap_or_else(|x| x);
        .                           let end_width_idx = self
        .                               .non_narrow_chars
        .                               .binary_search_by_key(&pos, |x| x.pos())
        .                               .unwrap_or_else(|x| x);
        .                           let special_chars = end_width_idx - start_width_idx;
        .                           let non_narrow: usize = self.non_narrow_chars[start_width_idx..end_width_idx]
        .                               .iter()
        .                               .map(|x| x.width())
        .                               .sum();
    2,455 ( 0.00%)                  col.0 - special_chars + non_narrow
        .                       };
        .                       (line, col, col_display)
        .                   } else {
        .                       let chpos = col_or_chpos;
        .                       let col_display = {
        .                           let end_width_idx = self
        .                               .non_narrow_chars
        .                               .binary_search_by_key(&pos, |x| x.pos())
        .                               .unwrap_or_else(|x| x);
        .                           let non_narrow: usize =
        .                               self.non_narrow_chars[0..end_width_idx].iter().map(|x| x.width()).sum();
        .                           chpos.0 - end_width_idx + non_narrow
        .                       };
        .                       (0, chpos, col_display)
        .                   }
    3,437 ( 0.00%)      }
        .           }
        .           
        .           /// Normalizes the source code and records the normalizations.
      200 ( 0.00%)  fn normalize_src(src: &mut String, start_pos: BytePos) -> Vec<NormalizedPos> {
        .               let mut normalized_pos = vec![];
        .               remove_bom(src, &mut normalized_pos);
        .               normalize_newlines(src, &mut normalized_pos);
        .           
        .               // Offset all the positions by start_pos to match the final file positions.
        .               for np in &mut normalized_pos {
        .                   np.pos.0 += start_pos.0;
        .               }
        .           
        .               normalized_pos
      180 ( 0.00%)  }
        .           
        .           /// Removes UTF-8 BOM, if any.
        .           fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {
       20 ( 0.00%)      if src.starts_with('\u{feff}') {
        .                   src.drain(..3);
        .                   normalized_pos.push(NormalizedPos { pos: BytePos(0), diff: 3 });
        .               }
        .           }
        .           
        .           /// Replaces `\r\n` with `\n` in-place in `src`.
        .           ///
        .           /// Returns error if there's a lone `\r` in the string.
        .           fn normalize_newlines(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {
       20 ( 0.00%)      if !src.as_bytes().contains(&b'\r') {
        .                   return;
        .               }
        .           
        .               // We replace `\r\n` with `\n` in-place, which doesn't break utf-8 encoding.
        .               // While we *can* call `as_mut_vec` and do surgery on the live string
        .               // directly, let's rather steal the contents of `src`. This makes the code
        .               // safe even if a panic occurs.
        .           
-- line 1816 ----------------------------------------
-- line 1877 ----------------------------------------
        .               (
        .                   $(
        .                       $(#[$attr:meta])*
        .                       $vis:vis struct $ident:ident($inner_vis:vis $inner_ty:ty);
        .                   )*
        .               ) => {
        .                   $(
        .                       $(#[$attr])*
   55,084 ( 0.00%)              $vis struct $ident($inner_vis $inner_ty);
        .           
        .                       impl Pos for $ident {
        .                           #[inline(always)]
        .                           fn from_usize(n: usize) -> $ident {
    4,991 ( 0.00%)                      $ident(n as $inner_ty)
        .                           }
        .           
        .                           #[inline(always)]
        .                           fn to_usize(&self) -> usize {
   86,073 ( 0.00%)                      self.0 as usize
        .                           }
        .           
        .                           #[inline(always)]
        .                           fn from_u32(n: u32) -> $ident {
        .                               $ident(n as $inner_ty)
        .                           }
        .           
        .                           #[inline(always)]
-- line 1903 ----------------------------------------
-- line 1906 ----------------------------------------
        .                           }
        .                       }
        .           
        .                       impl Add for $ident {
        .                           type Output = $ident;
        .           
        .                           #[inline(always)]
        .                           fn add(self, rhs: $ident) -> $ident {
1,665,756 ( 0.06%)                      $ident(self.0 + rhs.0)
        .                           }
        .                       }
        .           
        .                       impl Sub for $ident {
        .                           type Output = $ident;
        .           
        .                           #[inline(always)]
        .                           fn sub(self, rhs: $ident) -> $ident {
1,556,415 ( 0.06%)                      $ident(self.0 - rhs.0)
        .                           }
        .                       }
        .                   )*
        .               };
        .           }
        .           
        .           impl_pos! {
        .               /// A byte offset.
-- line 1931 ----------------------------------------
-- line 1946 ----------------------------------------
        .           impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {
        .               fn encode(&self, s: &mut S) -> Result<(), S::Error> {
        .                   s.emit_u32(self.0)
        .               }
        .           }
        .           
        .           impl<D: rustc_serialize::Decoder> Decodable<D> for BytePos {
        .               fn decode(d: &mut D) -> BytePos {
  132,550 ( 0.01%)          BytePos(d.read_u32())
        .               }
        .           }
        .           
        .           // _____________________________________________________________________________
        .           // Loc, SourceFileAndLine, SourceFileAndBytePos
        .           //
        .           
        .           /// A source code location used for error reporting.
-- line 1962 ----------------------------------------
-- line 2042 ----------------------------------------
        .           /// Range inside of a `Span` used for diagnostics when we only have access to relative positions.
        .           #[derive(Copy, Clone, PartialEq, Eq, Debug)]
        .           pub struct InnerSpan {
        .               pub start: usize,
        .               pub end: usize,
        .           }
        .           
        .           impl InnerSpan {
      104 ( 0.00%)      pub fn new(start: usize, end: usize) -> InnerSpan {
        .                   InnerSpan { start, end }
       52 ( 0.00%)      }
        .           }
        .           
        .           /// Requirements for a `StableHashingContext` to be used in this crate.
        .           ///
        .           /// This is a hack to allow using the [`HashStable_Generic`] derive macro
        .           /// instead of implementing everything in rustc_middle.
        .           pub trait HashStableContext {
        .               fn def_path_hash(&self, def_id: DefId) -> DefPathHash;
-- line 2060 ----------------------------------------
-- line 2079 ----------------------------------------
        .               /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)
        .               /// triple, which stays the same even if the containing `SourceFile` has moved
        .               /// within the `SourceMap`.
        .               ///
        .               /// Also note that we are hashing byte offsets for the column, not unicode
        .               /// codepoint offsets. For the purpose of the hash that's sufficient.
        .               /// Also, hashing filenames is expensive so we avoid doing it twice when the
        .               /// span starts and ends in the same file, which is almost always the case.
  444,542 ( 0.02%)      fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {
        .                   const TAG_VALID_SPAN: u8 = 0;
        .                   const TAG_INVALID_SPAN: u8 = 1;
        .                   const TAG_RELATIVE_SPAN: u8 = 2;
        .           
   84,040 ( 0.00%)          if !ctx.hash_spans() {
        .                       return;
        .                   }
        .           
  360,502 ( 0.01%)          let span = self.data_untracked();
  128,924 ( 0.00%)          span.ctxt.hash_stable(ctx, hasher);
  190,518 ( 0.01%)          span.parent.hash_stable(ctx, hasher);
        .           
  128,262 ( 0.00%)          if span.is_dummy() {
        .                       Hash::hash(&TAG_INVALID_SPAN, hasher);
        .                       return;
        .                   }
        .           
  124,512 ( 0.00%)          if let Some(parent) = span.parent {
        .                       let def_span = ctx.def_span(parent).data_untracked();
        .                       if def_span.contains(span) {
        .                           // This span is enclosed in a definition: only hash the relative position.
        .                           Hash::hash(&TAG_RELATIVE_SPAN, hasher);
        .                           (span.lo - def_span.lo).to_u32().hash_stable(ctx, hasher);
        .                           (span.hi - def_span.lo).to_u32().hash_stable(ctx, hasher);
        .                           return;
        .                       }
        .                   }
        .           
        .                   // If this is not an empty or invalid span, we want to hash the last
        .                   // position that belongs to it, as opposed to hashing the first
        .                   // position past it.
  249,024 ( 0.01%)          let (file, line_lo, col_lo, line_hi, col_hi) = match ctx.span_data_to_lines_and_cols(&span)
        .                   {
  124,512 ( 0.00%)              Some(pos) => pos,
        .                       None => {
        .                           Hash::hash(&TAG_INVALID_SPAN, hasher);
        .                           return;
        .                       }
        .                   };
        .           
        .                   Hash::hash(&TAG_VALID_SPAN, hasher);
        .                   // We truncate the stable ID hash and line and column numbers. The chances
-- line 2129 ----------------------------------------
-- line 2134 ----------------------------------------
        .                   // hash only the length, for example, then two otherwise equal spans with
        .                   // different end locations will have the same hash. This can cause a problem
        .                   // during incremental compilation wherein a previous result for a query that
        .                   // depends on the end location of a span will be incorrectly reused when the
        .                   // end location of the span it depends on has changed (see issue #74890). A
        .                   // similar analysis applies if some query depends specifically on the length
        .                   // of the span, but we only hash the end location. So hash both.
        .           
   62,256 ( 0.00%)          let col_lo_trunc = (col_lo.0 as u64) & 0xFF;
        .                   let line_lo_trunc = ((line_lo as u64) & 0xFF_FF_FF) << 8;
        .                   let col_hi_trunc = (col_hi.0 as u64) & 0xFF << 32;
        .                   let line_hi_trunc = ((line_hi as u64) & 0xFF_FF_FF) << 40;
        .                   let col_line = col_lo_trunc | line_lo_trunc | col_hi_trunc | line_hi_trunc;
   62,256 ( 0.00%)          let len = (span.hi - span.lo).0;
        .                   Hash::hash(&col_line, hasher);
        .                   Hash::hash(&len, hasher);
  508,048 ( 0.02%)      }
        .           }

2,093,758 ( 0.08%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_span/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs
--------------------------------------------------------------------------------
Ir                  

-- line 111 ----------------------------------------
         .           const EMPTY: u8 = 0b1111_1111;
         .           
         .           /// Control byte value for a deleted bucket.
         .           const DELETED: u8 = 0b1000_0000;
         .           
         .           /// Checks whether a control byte represents a full bucket (top bit is clear).
         .           #[inline]
         .           fn is_full(ctrl: u8) -> bool {
 1,524,058 ( 0.06%)      ctrl & 0x80 == 0
         .           }
         .           
         .           /// Checks whether a control byte represents a special value (top bit is set).
         .           #[inline]
         .           fn is_special(ctrl: u8) -> bool {
         .               ctrl & 0x80 != 0
         .           }
         .           
         .           /// Checks whether a special control value is EMPTY (just check 1 bit).
         .           #[inline]
         .           fn special_is_empty(ctrl: u8) -> bool {
         .               debug_assert!(is_special(ctrl));
   123,827 ( 0.00%)      ctrl & 0x01 != 0
         .           }
         .           
         .           /// Primary hash function, used to select the initial bucket to probe from.
         .           #[inline]
         .           #[allow(clippy::cast_possible_truncation)]
         .           fn h1(hash: u64) -> usize {
         .               // On 32-bit platforms we simply ignore the higher hash bits.
         .               hash as usize
-- line 140 ----------------------------------------
-- line 143 ----------------------------------------
         .           /// Secondary hash function, saved in the low 7 bits of the control byte.
         .           #[inline]
         .           #[allow(clippy::cast_possible_truncation)]
         .           fn h2(hash: u64) -> u8 {
         .               // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
         .               // value, some hash functions (such as FxHash) produce a usize result
         .               // instead, which means that the top 32 bits are 0 on 32-bit platforms.
         .               let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
22,713,014 ( 0.87%)      let top7 = hash >> (hash_len * 8 - 7);
         .               (top7 & 0x7f) as u8 // truncation
         .           }
         .           
         .           /// Probe sequence based on triangular numbers, which is guaranteed (since our
         .           /// table size is a power of two) to visit every group of elements exactly once.
         .           ///
         .           /// A triangular probe has us jump by 1 more group every time. So first we
         .           /// jump by 1 group (meaning we just continue our linear scan), then 2 groups
-- line 159 ----------------------------------------
-- line 170 ----------------------------------------
         .               #[inline]
         .               fn move_next(&mut self, bucket_mask: usize) {
         .                   // We should have found an empty bucket by now and ended the probe.
         .                   debug_assert!(
         .                       self.stride <= bucket_mask,
         .                       "Went past end of probe sequence"
         .                   );
         .           
   143,752 ( 0.01%)          self.stride += Group::WIDTH;
   143,752 ( 0.01%)          self.pos += self.stride;
   119,635 ( 0.00%)          self.pos &= bucket_mask;
         .               }
         .           }
         .           
         .           /// Returns the number of buckets needed to hold the given number of items,
         .           /// taking the maximum load factor into account.
         .           ///
         .           /// Returns `None` if an overflow occurs.
         .           // Workaround for emscripten bug emscripten-core/emscripten-fastcomp#258
         .           #[cfg_attr(target_os = "emscripten", inline(never))]
         .           #[cfg_attr(not(target_os = "emscripten"), inline)]
         .           fn capacity_to_buckets(cap: usize) -> Option<usize> {
         .               debug_assert_ne!(cap, 0);
         .           
         .               // For small tables we require at least 1 empty bucket so that lookups are
         .               // guaranteed to terminate if an element doesn't exist in the table.
   124,748 ( 0.00%)      if cap < 8 {
         .                   // We don't bother with a table size of 2 buckets since that can only
         .                   // hold a single element. Instead we skip directly to a 4 bucket table
         .                   // which can hold 3 elements.
   269,250 ( 0.01%)          return Some(if cap < 4 { 4 } else { 8 });
         .               }
         .           
         .               // Otherwise require 1/8 buckets to be empty (87.5% load)
         .               //
         .               // Be careful when modifying this, calculate_layout relies on the
         .               // overflow check here.
    51,144 ( 0.00%)      let adjusted_cap = cap.checked_mul(8)? / 7;
         .           
         .               // Any overflows will have been caught by the checked_mul. Also, any
         .               // rounding errors from the division above will be cleaned up by
         .               // next_power_of_two (which can't overflow because of the previous division).
         .               Some(adjusted_cap.next_power_of_two())
         .           }
         .           
         .           /// Returns the maximum effective capacity for the given bucket mask, taking
         .           /// the maximum load factor into account.
         .           #[inline]
         .           fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
   315,207 ( 0.01%)      if bucket_mask < 8 {
         .                   // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
         .                   // Keep in mind that the bucket mask is one less than the bucket count.
         .                   bucket_mask
         .               } else {
         .                   // For larger tables we reserve 12.5% of the slots as empty.
    66,878 ( 0.00%)          ((bucket_mask + 1) / 8) * 7
         .               }
         .           }
         .           
         .           /// Helper which allows the max calculation for ctrl_align to be statically computed for each T
         .           /// while keeping the rest of `calculate_layout_for` independent of `T`
         .           #[derive(Copy, Clone)]
         .           struct TableLayout {
         .               size: usize,
-- line 233 ----------------------------------------
-- line 246 ----------------------------------------
         .           
         .               #[inline]
         .               fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
         .                   debug_assert!(buckets.is_power_of_two());
         .           
         .                   let TableLayout { size, ctrl_align } = self;
         .                   // Manual layout calculation since Layout methods are not yet stable.
         .                   let ctrl_offset =
   262,687 ( 0.01%)              size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
   345,888 ( 0.01%)          let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
         .           
         .                   Some((
         .                       unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
         .                       ctrl_offset,
         .                   ))
         .               }
         .           }
         .           
-- line 263 ----------------------------------------
-- line 337 ----------------------------------------
         .                   }
         .               }
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub unsafe fn drop(&self) {
         .                   self.as_ptr().drop_in_place();
         .               }
         .               #[inline]
         .               pub unsafe fn read(&self) -> T {
     1,530 ( 0.00%)          self.as_ptr().read()
         .               }
         .               #[inline]
         .               pub unsafe fn write(&self, val: T) {
         .                   self.as_ptr().write(val);
         .               }
         .               #[inline]
         .               pub unsafe fn as_ref<'a>(&self) -> &'a T {
         .                   &*self.as_ptr()
-- line 353 ----------------------------------------
-- line 422 ----------------------------------------
         .               /// Creates a new empty hash table without allocating any memory, using the
         .               /// given allocator.
         .               ///
         .               /// In effect this returns a table with exactly 1 bucket. However we can
         .               /// leave the data pointer dangling since that bucket is never written to
         .               /// due to our load factor forcing us to always have at least 1 free bucket.
         .               #[inline]
         .               pub fn new_in(alloc: A) -> Self {
     1,857 ( 0.00%)          Self {
         .                       table: RawTableInner::new_in(alloc),
         .                       marker: PhantomData,
         .                   }
         .               }
         .           
         .               /// Allocates a new hash table with the given number of buckets.
         .               ///
         .               /// The control bytes are left uninitialized.
-- line 438 ----------------------------------------
-- line 440 ----------------------------------------
         .               unsafe fn new_uninitialized(
         .                   alloc: A,
         .                   buckets: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
         .                   debug_assert!(buckets.is_power_of_two());
         .           
         .                   Ok(Self {
       493 ( 0.00%)              table: RawTableInner::new_uninitialized(
         .                           alloc,
         .                           TableLayout::new::<T>(),
         .                           buckets,
         .                           fallibility,
         .                       )?,
         .                       marker: PhantomData,
         .                   })
         .               }
-- line 456 ----------------------------------------
-- line 458 ----------------------------------------
         .               /// Attempts to allocate a new hash table with at least enough capacity
         .               /// for inserting the given number of elements without reallocating.
         .               fn fallible_with_capacity(
         .                   alloc: A,
         .                   capacity: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
         .                   Ok(Self {
     9,998 ( 0.00%)              table: RawTableInner::fallible_with_capacity(
         .                           alloc,
         .                           TableLayout::new::<T>(),
         .                           capacity,
         .                           fallibility,
         .                       )?,
         .                       marker: PhantomData,
         .                   })
         .               }
-- line 474 ----------------------------------------
-- line 527 ----------------------------------------
         .                   debug_assert_ne!(self.table.bucket_mask, 0);
         .                   debug_assert!(index < self.buckets());
         .                   Bucket::from_base_index(self.data_end(), index)
         .               }
         .           
         .               /// Erases an element from the table without dropping it.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[deprecated(since = "0.8.1", note = "use erase or remove instead")]
    16,422 ( 0.00%)      pub unsafe fn erase_no_drop(&mut self, item: &Bucket<T>) {
    16,422 ( 0.00%)          let index = self.bucket_index(item);
         .                   self.table.erase(index);
    32,844 ( 0.00%)      }
         .           
         .               /// Erases an element from the table, dropping it in place.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[allow(clippy::needless_pass_by_value)]
         .               #[allow(deprecated)]
         .               pub unsafe fn erase(&mut self, item: Bucket<T>) {
         .                   // Erase the element from the table first since drop might panic.
    12,768 ( 0.00%)          self.erase_no_drop(&item);
         .                   item.drop();
         .               }
         .           
         .               /// Finds and erases an element from the table, dropping it in place.
         .               /// Returns true if an element was found.
         .               #[cfg(feature = "raw")]
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn erase_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> bool {
-- line 554 ----------------------------------------
-- line 563 ----------------------------------------
         .                   }
         .               }
         .           
         .               /// Removes an element from the table, returning it.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[allow(clippy::needless_pass_by_value)]
         .               #[allow(deprecated)]
         .               pub unsafe fn remove(&mut self, item: Bucket<T>) -> T {
    20,076 ( 0.00%)          self.erase_no_drop(&item);
       241 ( 0.00%)          item.read()
         .               }
         .           
         .               /// Finds and removes an element from the table, returning it.
         .               #[cfg_attr(feature = "inline-more", inline)]
   617,245 ( 0.02%)      pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T> {
         .                   // Avoid `Option::map` because it bloats LLVM IR.
     2,250 ( 0.00%)          match self.find(hash, eq) {
    10,035 ( 0.00%)              Some(bucket) => Some(unsafe { self.remove(bucket) }),
   145,367 ( 0.01%)              None => None,
         .                   }
   901,517 ( 0.03%)      }
         .           
         .               /// Marks all table buckets as empty without dropping their contents.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn clear_no_drop(&mut self) {
         .                   self.table.clear_no_drop();
         .               }
         .           
         .               /// Removes all elements from the table without freeing the backing memory.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn clear(&mut self) {
         .                   // Ensure that the table is reset even if one of the drops panic
         .                   let mut self_ = guard(self, |self_| self_.clear_no_drop());
         .                   unsafe {
         1 ( 0.00%)              self_.drop_elements();
         .                   }
         .               }
         .           
         7 ( 0.00%)      unsafe fn drop_elements(&mut self) {
    14,190 ( 0.00%)          if mem::needs_drop::<T>() && !self.is_empty() {
         .                       for item in self.iter() {
         .                           item.drop();
         .                       }
         .                   }
         8 ( 0.00%)      }
         .           
         .               /// Shrinks the table to fit `max(self.len(), min_size)` elements.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn shrink_to(&mut self, min_size: usize, hasher: impl Fn(&T) -> u64) {
         .                   // Calculate the minimal number of elements that we need to reserve
         .                   // space for.
         .                   let min_size = usize::max(self.table.items, min_size);
         .                   if min_size == 0 {
-- line 615 ----------------------------------------
-- line 642 ----------------------------------------
         .                       }
         .                   }
         .               }
         .           
         .               /// Ensures that at least `additional` items can be inserted into the table
         .               /// without reallocation.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
   322,772 ( 0.01%)          if additional > self.table.growth_left {
         .                       // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
   214,579 ( 0.01%)              if self
         .                           .reserve_rehash(additional, hasher, Fallibility::Infallible)
         .                           .is_err()
         .                       {
         .                           unsafe { hint::unreachable_unchecked() }
         .                       }
         .                   }
         .               }
         .           
-- line 660 ----------------------------------------
-- line 671 ----------------------------------------
         .                   } else {
         .                       Ok(())
         .                   }
         .               }
         .           
         .               /// Out-of-line slow path for `reserve` and `try_reserve`.
         .               #[cold]
         .               #[inline(never)]
   496,312 ( 0.02%)      fn reserve_rehash(
         .                   &mut self,
         .                   additional: usize,
         .                   hasher: impl Fn(&T) -> u64,
         .                   fallibility: Fallibility,
         .               ) -> Result<(), TryReserveError> {
         .                   unsafe {
         .                       self.table.reserve_rehash_inner(
         .                           additional,
-- line 687 ----------------------------------------
-- line 690 ----------------------------------------
         .                           TableLayout::new::<T>(),
         .                           if mem::needs_drop::<T>() {
         .                               Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
         .                           } else {
         .                               None
         .                           },
         .                       )
         .                   }
   361,928 ( 0.01%)      }
         .           
         .               /// Allocates a new table of a different size and moves the contents of the
         .               /// current table into it.
         .               fn resize(
         .                   &mut self,
         .                   capacity: usize,
         .                   hasher: impl Fn(&T) -> u64,
         .                   fallibility: Fallibility,
-- line 706 ----------------------------------------
-- line 714 ----------------------------------------
         .                       )
         .                   }
         .               }
         .           
         .               /// Inserts a new element into the table, and returns its raw bucket.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg_attr(feature = "inline-more", inline)]
 2,188,758 ( 0.08%)      pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
         .                   unsafe {
         .                       let mut index = self.table.find_insert_slot(hash);
         .           
         .                       // We can avoid growing the table once we have reached our load
         .                       // factor if we are replacing a tombstone. This works since the
         .                       // number of EMPTY slots does not change in this case.
     5,589 ( 0.00%)              let old_ctrl = *self.table.ctrl(index);
 1,437,026 ( 0.05%)              if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
         .                           self.reserve(1, hasher);
         .                           index = self.table.find_insert_slot(hash);
         .                       }
         .           
         .                       self.table.record_item_insert_at(index, old_ctrl, hash);
         .           
         .                       let bucket = self.bucket(index);
         2 ( 0.00%)              bucket.write(value);
         .                       bucket
         .                   }
 1,610,390 ( 0.06%)      }
         .           
         .               /// Attempts to insert a new element without growing the table and return its raw bucket.
         .               ///
         .               /// Returns an `Err` containing the given element if inserting it would require growing the
         .               /// table.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg(feature = "raw")]
-- line 749 ----------------------------------------
-- line 760 ----------------------------------------
         .                       }
         .                   }
         .               }
         .           
         .               /// Inserts a new element into the table, and returns a mutable reference to it.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg_attr(feature = "inline-more", inline)]
   390,736 ( 0.01%)      pub fn insert_entry(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> &mut T {
        22 ( 0.00%)          unsafe { self.insert(hash, value, hasher).as_mut() }
   293,052 ( 0.01%)      }
         .           
         .               /// Inserts a new element into the table, without growing the table.
         .               ///
         .               /// There must be enough space in the table to insert the new element.
         .               ///
         .               /// This does not check if the given element already exists in the table.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               #[cfg(any(feature = "raw", feature = "rustc-internal-api"))]
     2,586 ( 0.00%)      pub unsafe fn insert_no_grow(&mut self, hash: u64, value: T) -> Bucket<T> {
   350,860 ( 0.01%)          let (index, old_ctrl) = self.table.prepare_insert_slot(hash);
    11,761 ( 0.00%)          let bucket = self.table.bucket(index);
         .           
         .                   // If we are replacing a DELETED entry then we don't need to update
         .                   // the load counter.
   725,334 ( 0.03%)          self.table.growth_left -= special_is_empty(old_ctrl) as usize;
         .           
         .                   bucket.write(value);
   586,081 ( 0.02%)          self.table.items += 1;
         .                   bucket
     5,074 ( 0.00%)      }
         .           
         .               /// Temporary removes a bucket, applying the given function to the removed
         .               /// element and optionally put back the returned value in the same bucket.
         .               ///
         .               /// Returns `true` if the bucket still contains an element
         .               ///
         .               /// This does not check if the given bucket is actually occupied.
         .               #[cfg_attr(feature = "inline-more", inline)]
-- line 798 ----------------------------------------
-- line 813 ----------------------------------------
         .                       true
         .                   } else {
         .                       false
         .                   }
         .               }
         .           
         .               /// Searches for an element in the table.
         .               #[inline]
    24,027 ( 0.00%)      pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
    10,639 ( 0.00%)          let result = self.table.find_inner(hash, &mut |index| unsafe {
    21,942 ( 0.00%)              eq(self.bucket(index).as_ref())
     5,111 ( 0.00%)          });
         .           
         .                   // Avoid `Option::map` because it bloats LLVM IR.
         .                   match result {
     1,371 ( 0.00%)              Some(index) => Some(unsafe { self.bucket(index) }),
         .                       None => None,
         .                   }
    27,136 ( 0.00%)      }
         .           
         .               /// Gets a reference to an element in the table.
         .               #[inline]
         .               pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
         .                   // Avoid `Option::map` because it bloats LLVM IR.
    22,655 ( 0.00%)          match self.find(hash, eq) {
         .                       Some(bucket) => Some(unsafe { bucket.as_ref() }),
         .                       None => None,
         .                   }
         .               }
         .           
         .               /// Gets a mutable reference to an element in the table.
         .               #[inline]
     1,624 ( 0.00%)      pub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {
         .                   // Avoid `Option::map` because it bloats LLVM IR.
    12,903 ( 0.00%)          match self.find(hash, eq) {
         .                       Some(bucket) => Some(unsafe { bucket.as_mut() }),
         .                       None => None,
         .                   }
     1,856 ( 0.00%)      }
         .           
         .               /// Attempts to get mutable references to `N` entries in the table at once.
         .               ///
         .               /// Returns an array of length `N` with the results of each query.
         .               ///
         .               /// At most one mutable reference will be returned to any entry. `None` will be returned if any
         .               /// of the hashes are duplicates. `None` will be returned if the hash is not found.
         .               ///
-- line 859 ----------------------------------------
-- line 920 ----------------------------------------
         .               #[inline]
         .               pub fn len(&self) -> usize {
         .                   self.table.items
         .               }
         .           
         .               /// Returns `true` if the table contains no elements.
         .               #[inline]
         .               pub fn is_empty(&self) -> bool {
   821,162 ( 0.03%)          self.len() == 0
         .               }
         .           
         .               /// Returns the number of buckets in the table.
         .               #[inline]
         .               pub fn buckets(&self) -> usize {
         .                   self.table.bucket_mask + 1
         .               }
         .           
         .               /// Returns an iterator over every element in the table. It is up to
         .               /// the caller to ensure that the `RawTable` outlives the `RawIter`.
         .               /// Because we cannot make the `next` method unsafe on the `RawIter`
         .               /// struct, we have to make the `iter` method unsafe.
         .               #[inline]
         .               pub unsafe fn iter(&self) -> RawIter<T> {
        15 ( 0.00%)          let data = Bucket::from_base_index(self.data_end(), 0);
         .                   RawIter {
         .                       iter: RawIterRange::new(self.table.ctrl.as_ptr(), data, self.table.buckets()),
   127,085 ( 0.00%)              items: self.table.items,
         .                   }
         .               }
         .           
         .               /// Returns an iterator over occupied buckets that could match a given hash.
         .               ///
         .               /// `RawTable` only stores 7 bits of the hash value, so this iterator may
         .               /// return items that have a hash value different than the one provided. You
         .               /// should always validate the returned values before using them.
-- line 954 ----------------------------------------
-- line 995 ----------------------------------------
         .               /// Iteration starts at the provided iterator's current location.
         .               ///
         .               /// It is up to the caller to ensure that the iterator is valid for this
         .               /// `RawTable` and covers all items that remain in the table.
         .               pub unsafe fn into_iter_from(self, iter: RawIter<T>) -> RawIntoIter<T, A> {
         .                   debug_assert_eq!(iter.len(), self.len());
         .           
         .                   let alloc = self.table.alloc.clone();
     9,036 ( 0.00%)          let allocation = self.into_allocation();
     6,777 ( 0.00%)          RawIntoIter {
    11,295 ( 0.00%)              iter,
         .                       allocation,
         .                       marker: PhantomData,
         .                       alloc,
         .                   }
         .               }
         .           
         .               /// Converts the table into a raw allocation. The contents of the table
         .               /// should be dropped using a `RawIter` before freeing the allocation.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               pub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout)> {
     4,481 ( 0.00%)          let alloc = if self.table.is_empty_singleton() {
         .                       None
         .                   } else {
         .                       // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
         .                       let (layout, ctrl_offset) = match calculate_layout::<T>(self.table.buckets()) {
         .                           Some(lco) => lco,
         .                           None => unsafe { hint::unreachable_unchecked() },
         .                       };
         .                       Some((
       559 ( 0.00%)                  unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().sub(ctrl_offset)) },
         .                           layout,
         .                       ))
         .                   };
         .                   mem::forget(self);
         .                   alloc
         .               }
         .           }
         .           
-- line 1033 ----------------------------------------
-- line 1042 ----------------------------------------
         .               T: Sync,
         .               A: Sync,
         .           {
         .           }
         .           
         .           impl<A> RawTableInner<A> {
         .               #[inline]
         .               const fn new_in(alloc: A) -> Self {
   709,390 ( 0.03%)          Self {
         .                       // Be careful to cast the entire slice to a raw pointer.
         .                       ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
         .                       bucket_mask: 0,
         .                       items: 0,
         .                       growth_left: 0,
         .                       alloc,
         .                   }
         .               }
         .           }
         .           
         .           impl<A: Allocator + Clone> RawTableInner<A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
   480,318 ( 0.02%)      unsafe fn new_uninitialized(
         .                   alloc: A,
         .                   table_layout: TableLayout,
         .                   buckets: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
         .                   debug_assert!(buckets.is_power_of_two());
         .           
         .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
-- line 1071 ----------------------------------------
-- line 1078 ----------------------------------------
         .                   // exceed `isize::MAX`. We can skip this check on 64-bit systems since
         .                   // such allocations will never succeed anyways.
         .                   //
         .                   // This mirrors what Vec does in the standard library.
         .                   if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
         .                       return Err(fallibility.capacity_overflow());
         .                   }
         .           
   109,034 ( 0.00%)          let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
         .                       Ok(block) => block.cast(),
         .                       Err(_) => return Err(fallibility.alloc_err(layout)),
         .                   };
         .           
         .                   let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
   264,834 ( 0.01%)          Ok(Self {
         .                       ctrl,
   106,619 ( 0.00%)              bucket_mask: buckets - 1,
         .                       items: 0,
         .                       growth_left: bucket_mask_to_capacity(buckets - 1),
         .                       alloc,
         .                   })
   349,638 ( 0.01%)      }
         .           
         .               #[inline]
    31,966 ( 0.00%)      fn fallible_with_capacity(
         .                   alloc: A,
         .                   table_layout: TableLayout,
         .                   capacity: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<Self, TryReserveError> {
     8,380 ( 0.00%)          if capacity == 0 {
     6,308 ( 0.00%)              Ok(Self::new_in(alloc))
         .                   } else {
         .                       unsafe {
         .                           let buckets =
         .                               capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
         .           
   218,360 ( 0.01%)                  let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
         .                           result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
         .           
    16,949 ( 0.00%)                  Ok(result)
         .                       }
         .                   }
    31,966 ( 0.00%)      }
         .           
         .               /// Searches for an empty or deleted bucket which is suitable for inserting
         .               /// a new element and sets the hash for that slot.
         .               ///
         .               /// There must be at least 1 empty bucket in the table.
         .               #[inline]
   121,317 ( 0.00%)      unsafe fn prepare_insert_slot(&self, hash: u64) -> (usize, u8) {
         .                   let index = self.find_insert_slot(hash);
   121,317 ( 0.00%)          let old_ctrl = *self.ctrl(index);
         .                   self.set_ctrl_h2(index, hash);
         .                   (index, old_ctrl)
   242,634 ( 0.01%)      }
         .           
         .               /// Searches for an empty or deleted bucket which is suitable for inserting
         .               /// a new element.
         .               ///
         .               /// There must be at least 1 empty bucket in the table.
         .               #[inline]
         .               fn find_insert_slot(&self, hash: u64) -> usize {
         .                   let mut probe_seq = self.probe_seq(hash);
         .                   loop {
         .                       unsafe {
         .                           let group = Group::load(self.ctrl(probe_seq.pos));
   989,948 ( 0.04%)                  if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
 2,905,722 ( 0.11%)                      let result = (probe_seq.pos + bit) & self.bucket_mask;
         .           
         .                               // In tables smaller than the group width, trailing control
         .                               // bytes outside the range of the table are filled with
         .                               // EMPTY entries. These will unfortunately trigger a
         .                               // match, but once masked may point to a full bucket that
         .                               // is already occupied. We detect this situation here and
         .                               // perform a second scan starting at the beginning of the
         .                               // table. This second scan is guaranteed to find an empty
         .                               // slot (due to the load factor) before hitting the trailing
         .                               // control bytes (containing EMPTY).
 1,327,308 ( 0.05%)                      if unlikely(is_full(*self.ctrl(result))) {
         .                                   debug_assert!(self.bucket_mask < Group::WIDTH);
         .                                   debug_assert_ne!(probe_seq.pos, 0);
         .                                   return Group::load_aligned(self.ctrl(0))
         .                                       .match_empty_or_deleted()
         .                                       .lowest_set_bit_nonzero();
         .                               }
         .           
         .                               return result;
-- line 1165 ----------------------------------------
-- line 1171 ----------------------------------------
         .           
         .               /// Searches for an element in the table. This uses dynamic dispatch to reduce the amount of
         .               /// code generated, but it is eliminated by LLVM optimizations.
         .               #[inline]
         .               fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
         .                   let h2_hash = h2(hash);
         .                   let mut probe_seq = self.probe_seq(hash);
         .           
    45,628 ( 0.00%)          loop {
         .                       let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
         .           
 2,959,804 ( 0.11%)              for bit in group.match_byte(h2_hash) {
 5,605,327 ( 0.21%)                  let index = (probe_seq.pos + bit) & self.bucket_mask;
         .           
 4,170,562 ( 0.16%)                  if likely(eq(index)) {
         .                               return Some(index);
         .                           }
         .                       }
         .           
   937,357 ( 0.04%)              if likely(group.match_empty().any_bit_set()) {
         .                           return None;
         .                       }
         .           
         .                       probe_seq.move_next(self.bucket_mask);
         .                   }
         .               }
         .           
         .               #[allow(clippy::mut_mut)]
-- line 1198 ----------------------------------------
-- line 1225 ----------------------------------------
         .                   Bucket::from_base_index(self.data_end(), index)
         .               }
         .           
         .               #[inline]
         .               unsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8 {
         .                   debug_assert_ne!(self.bucket_mask, 0);
         .                   debug_assert!(index < self.buckets());
         .                   let base: *mut u8 = self.data_end().as_ptr();
 3,543,912 ( 0.14%)          base.sub((index + 1) * size_of)
         .               }
         .           
         .               #[inline]
         .               unsafe fn data_end<T>(&self) -> NonNull<T> {
         .                   NonNull::new_unchecked(self.ctrl.as_ptr().cast())
         .               }
         .           
         .               /// Returns an iterator-like object for a probe sequence on the table.
         .               ///
         .               /// This iterator never terminates, but is guaranteed to visit each bucket
         .               /// group exactly once. The loop using `probe_seq` must terminate upon
         .               /// reaching a group containing an empty bucket.
         .               #[inline]
         .               fn probe_seq(&self, hash: u64) -> ProbeSeq {
         .                   ProbeSeq {
17,271,859 ( 0.66%)              pos: h1(hash) & self.bucket_mask,
         .                       stride: 0,
         .                   }
         .               }
         .           
         .               /// Returns the index of a bucket for which a value must be inserted if there is enough rooom
         .               /// in the table, otherwise returns error
         .               #[cfg(feature = "raw")]
         .               #[inline]
-- line 1257 ----------------------------------------
-- line 1263 ----------------------------------------
         .                   } else {
         .                       self.record_item_insert_at(index, old_ctrl, hash);
         .                       Ok(index)
         .                   }
         .               }
         .           
         .               #[inline]
         .               unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
 1,795,421 ( 0.07%)          self.growth_left -= special_is_empty(old_ctrl) as usize;
         .                   self.set_ctrl_h2(index, hash);
 1,436,272 ( 0.05%)          self.items += 1;
         .               }
         .           
         .               #[inline]
         .               fn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool {
         .                   let probe_seq_pos = self.probe_seq(hash).pos;
         .                   let probe_index =
         .                       |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;
         .                   probe_index(i) == probe_index(new_i)
-- line 1281 ----------------------------------------
-- line 1312 ----------------------------------------
         .                   // replicate the buckets at the end of the trailing group. For example
         .                   // with 2 buckets and a group size of 4, the control bytes will look
         .                   // like this:
         .                   //
         .                   //     Real    |             Replicated
         .                   // ---------------------------------------------
         .                   // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
         .                   // ---------------------------------------------
 2,778,948 ( 0.11%)          let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
         .           
   925,884 ( 0.04%)          *self.ctrl(index) = ctrl;
   926,565 ( 0.04%)          *self.ctrl(index2) = ctrl;
         .               }
         .           
         .               /// Returns a pointer to a control byte.
         .               #[inline]
         .               unsafe fn ctrl(&self, index: usize) -> *mut u8 {
         .                   debug_assert!(index < self.num_ctrl_bytes());
         .                   self.ctrl.as_ptr().add(index)
         .               }
         .           
         .               #[inline]
         .               fn buckets(&self) -> usize {
   356,053 ( 0.01%)          self.bucket_mask + 1
         .               }
         .           
         .               #[inline]
         .               fn num_ctrl_bytes(&self) -> usize {
   252,918 ( 0.01%)          self.bucket_mask + 1 + Group::WIDTH
         .               }
         .           
         .               #[inline]
         .               fn is_empty_singleton(&self) -> bool {
 1,284,325 ( 0.05%)          self.bucket_mask == 0
         .               }
         .           
         .               #[allow(clippy::mut_mut)]
         .               #[inline]
         .               unsafe fn prepare_resize(
         .                   &self,
         .                   table_layout: TableLayout,
         .                   capacity: usize,
         .                   fallibility: Fallibility,
         .               ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
         .                   debug_assert!(self.items <= capacity);
         .           
         .                   // Allocate and initialize the new table.
     4,683 ( 0.00%)          let mut new_table = RawTableInner::fallible_with_capacity(
         .                       self.alloc.clone(),
         .                       table_layout,
         .                       capacity,
         .                       fallibility,
         .                   )?;
   136,079 ( 0.01%)          new_table.growth_left -= self.items;
         .                   new_table.items = self.items;
         .           
         .                   // The hash function may panic, in which case we simply free the new
         .                   // table without dropping any elements that may have been copied into
         .                   // it.
         .                   //
         .                   // This guard is also used to free the old table on success, see
         .                   // the comment at the bottom of this function.
         .                   Ok(guard(new_table, move |self_| {
    61,110 ( 0.00%)              if !self_.is_empty_singleton() {
         .                           self_.free_buckets(table_layout);
         .                       }
         .                   }))
         .               }
         .           
         .               /// Reserves or rehashes to make room for `additional` more elements.
         .               ///
         .               /// This uses dynamic dispatch to reduce the amount of
-- line 1383 ----------------------------------------
-- line 1388 ----------------------------------------
         .                   &mut self,
         .                   additional: usize,
         .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
         .                   fallibility: Fallibility,
         .                   layout: TableLayout,
         .                   drop: Option<fn(*mut u8)>,
         .               ) -> Result<(), TryReserveError> {
         .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
   122,224 ( 0.00%)          let new_items = match self.items.checked_add(additional) {
         .                       Some(new_items) => new_items,
         .                       None => return Err(fallibility.capacity_overflow()),
         .                   };
   122,220 ( 0.00%)          let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
   259,518 ( 0.01%)          if new_items <= full_capacity / 2 {
         .                       // Rehash in-place without re-allocating if we have plenty of spare
         .                       // capacity that is locked up due to DELETED entries.
         .                       self.rehash_in_place(hasher, layout.size, drop);
         .                       Ok(())
         .                   } else {
         .                       // Otherwise, conservatively resize to at least the next size up
         .                       // to avoid churning deletes into frequent rehashes.
         .                       self.resize_inner(
    61,110 ( 0.00%)                  usize::max(new_items, full_capacity + 1),
         .                           hasher,
         .                           fallibility,
         .                           layout,
         .                       )
         .                   }
         .               }
         .           
         .               /// Allocates a new table of a different size and moves the contents of the
-- line 1418 ----------------------------------------
-- line 1424 ----------------------------------------
         .               #[inline(always)]
         .               unsafe fn resize_inner(
         .                   &mut self,
         .                   capacity: usize,
         .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
         .                   fallibility: Fallibility,
         .                   layout: TableLayout,
         .               ) -> Result<(), TryReserveError> {
    11,671 ( 0.00%)          let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
         .           
         .                   // Copy all elements to the new table.
         .                   for i in 0..self.buckets() {
   555,818 ( 0.02%)              if !is_full(*self.ctrl(i)) {
         .                           continue;
         .                       }
         .           
         .                       // This may panic.
         .                       let hash = hasher(self, i);
         .           
         .                       // We can use a simpler version of insert() here since:
         .                       // - there are no DELETED entries.
-- line 1444 ----------------------------------------
-- line 1454 ----------------------------------------
         .                   }
         .           
         .                   // We successfully copied all elements without panicking. Now replace
         .                   // self with the new table. The old table will have its memory freed but
         .                   // the items will not be dropped (since they have been moved into the
         .                   // new table).
         .                   mem::swap(self, &mut new_table);
         .           
    61,110 ( 0.00%)          Ok(())
         .               }
         .           
         .               /// Rehashes the contents of the table in place (i.e. without changing the
         .               /// allocation).
         .               ///
         .               /// If `hasher` panics then some the table's contents may be lost.
         .               ///
         .               /// This uses dynamic dispatch to reduce the amount of
-- line 1470 ----------------------------------------
-- line 1554 ----------------------------------------
         .               #[inline]
         .               unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
         .                   // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
         .                   let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
         .                       Some(lco) => lco,
         .                       None => hint::unreachable_unchecked(),
         .                   };
         .                   self.alloc.deallocate(
    42,102 ( 0.00%)              NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
         .                       layout,
         .                   );
         .               }
         .           
         .               /// Marks all table buckets as empty without dropping their contents.
         .               #[inline]
         .               fn clear_no_drop(&mut self) {
     8,246 ( 0.00%)          if !self.is_empty_singleton() {
         .                       unsafe {
         .                           self.ctrl(0).write_bytes(EMPTY, self.num_ctrl_bytes());
         .                       }
         .                   }
    11,838 ( 0.00%)          self.items = 0;
     8,260 ( 0.00%)          self.growth_left = bucket_mask_to_capacity(self.bucket_mask);
         .               }
         .           
         .               #[inline]
         .               unsafe fn erase(&mut self, index: usize) {
         .                   debug_assert!(is_full(*self.ctrl(index)));
   109,416 ( 0.00%)          let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;
         .                   let empty_before = Group::load(self.ctrl(index_before)).match_empty();
         .                   let empty_after = Group::load(self.ctrl(index)).match_empty();
         .           
         .                   // If we are inside a continuous block of Group::WIDTH full or deleted
         .                   // cells then a probe window may have seen a full block when trying to
         .                   // insert. We therefore need to keep that block non-empty so that
         .                   // lookups will continue searching to the next probe window.
         .                   //
         .                   // Note that in this context `leading_zeros` refers to the bytes at the
         .                   // end of a group, while `trailing_zeros` refers to the bytes at the
         .                   // beginning of a group.
   437,664 ( 0.02%)          let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {
         .                       DELETED
         .                   } else {
   544,600 ( 0.02%)              self.growth_left += 1;
         .                       EMPTY
         .                   };
         .                   self.set_ctrl(index, ctrl);
   437,664 ( 0.02%)          self.items -= 1;
         .               }
         .           }
         .           
         .           impl<T: Clone, A: Allocator + Clone> Clone for RawTable<T, A> {
     5,264 ( 0.00%)      fn clone(&self) -> Self {
       732 ( 0.00%)          if self.table.is_empty_singleton() {
         .                       Self::new_in(self.table.alloc.clone())
         .                   } else {
         .                       unsafe {
         .                           let mut new_table = ManuallyDrop::new(
         .                               // Avoid `Result::ok_or_else` because it bloats LLVM IR.
         .                               match Self::new_uninitialized(
         .                                   self.table.alloc.clone(),
         .                                   self.table.buckets(),
-- line 1615 ----------------------------------------
-- line 1624 ----------------------------------------
         .                               // We need to free the memory allocated for the new table.
         .                               new_table.free_buckets();
         .                           });
         .           
         .                           // Return the newly created table.
         .                           ManuallyDrop::into_inner(new_table)
         .                       }
         .                   }
     5,922 ( 0.00%)      }
         .           
         .               fn clone_from(&mut self, source: &Self) {
         .                   if source.table.is_empty_singleton() {
         .                       *self = Self::new_in(self.table.alloc.clone());
         .                   } else {
         .                       unsafe {
         .                           // First, drop all our elements without clearing the control bytes.
         .                           self.drop_elements();
-- line 1640 ----------------------------------------
-- line 1687 ----------------------------------------
         .                       .table
         .                       .ctrl(0)
         .                       .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());
         .                   source
         .                       .data_start()
         .                       .copy_to_nonoverlapping(self.data_start(), self.table.buckets());
         .           
         .                   self.table.items = source.table.items;
       138 ( 0.00%)          self.table.growth_left = source.table.growth_left;
         .               }
         .           }
         .           
         .           impl<T: Clone, A: Allocator + Clone> RawTable<T, A> {
         .               /// Common code for clone and clone_from. Assumes `self.buckets() == source.buckets()`.
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               unsafe fn clone_from_impl(&mut self, source: &Self, mut on_panic: impl FnMut(&mut Self)) {
         .                   // Copy the control bytes unchanged. We do this in a single pass
-- line 1703 ----------------------------------------
-- line 1732 ----------------------------------------
         .                       // Update the index in case we need to unwind.
         .                       guard.0 = index;
         .                   }
         .           
         .                   // Successfully cloned all items, no need to clean up.
         .                   mem::forget(guard);
         .           
         .                   self.table.items = source.table.items;
       111 ( 0.00%)          self.table.growth_left = source.table.growth_left;
         .               }
         .           
         .               /// Variant of `clone_from` to use when a hasher is available.
         .               #[cfg(feature = "raw")]
         .               pub fn clone_from_with_hasher(&mut self, source: &Self, hasher: impl Fn(&T) -> u64) {
         .                   // If we have enough capacity in the table, just clear it and insert
         .                   // elements one by one. We don't do this if we have the same number of
         .                   // buckets as the source since we can just copy the contents directly
-- line 1748 ----------------------------------------
-- line 1790 ----------------------------------------
         .               fn default() -> Self {
         .                   Self::new_in(Default::default())
         .               }
         .           }
         .           
         .           #[cfg(feature = "nightly")]
         .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawTable<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
   683,021 ( 0.03%)      fn drop(&mut self) {
   557,025 ( 0.02%)          if !self.table.is_empty_singleton() {
         .                       unsafe {
         .                           self.drop_elements();
         .                           self.free_buckets();
         .                       }
         .                   }
   736,784 ( 0.03%)      }
         .           }
         .           #[cfg(not(feature = "nightly"))]
         .           impl<T, A: Allocator + Clone> Drop for RawTable<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn drop(&mut self) {
         .                   if !self.table.is_empty_singleton() {
         .                       unsafe {
         .                           self.drop_elements();
-- line 1813 ----------------------------------------
-- line 1817 ----------------------------------------
         .               }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> IntoIterator for RawTable<T, A> {
         .               type Item = T;
         .               type IntoIter = RawIntoIter<T, A>;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
     9,036 ( 0.00%)      fn into_iter(self) -> RawIntoIter<T, A> {
         .                   unsafe {
         .                       let iter = self.iter();
         .                       self.into_iter_from(iter)
         .                   }
    11,295 ( 0.00%)      }
         .           }
         .           
         .           /// Iterator over a sub-range of a table. Unlike `RawIter` this iterator does
         .           /// not track an item count.
         .           pub(crate) struct RawIterRange<T> {
         .               // Mask of full buckets in the current group. Bits are cleared from this
         .               // mask as each element is processed.
         .               current_group: BitMask,
-- line 1838 ----------------------------------------
-- line 1934 ----------------------------------------
         .           
         .           impl<T> Iterator for RawIterRange<T> {
         .               type Item = Bucket<T>;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn next(&mut self) -> Option<Bucket<T>> {
         .                   unsafe {
         .                       loop {
   263,591 ( 0.01%)                  if let Some(index) = self.current_group.lowest_set_bit() {
    36,301 ( 0.00%)                      self.current_group = self.current_group.remove_lowest_bit();
    64,196 ( 0.00%)                      return Some(self.data.next_n(index));
         .                           }
         .           
   230,221 ( 0.01%)                  if self.next_ctrl >= self.end {
         .                               return None;
         .                           }
         .           
         .                           // We might read past self.end up to the next group boundary,
         .                           // but this is fine because it only occurs on tables smaller
         .                           // than the group size where the trailing control bytes are all
         .                           // EMPTY. On larger tables self.end is guaranteed to be aligned
         .                           // to the group size (since tables are power-of-two sized).
     4,449 ( 0.00%)                  self.current_group = Group::load_aligned(self.next_ctrl).match_full();
     5,350 ( 0.00%)                  self.data = self.data.next_n(Group::WIDTH);
     6,952 ( 0.00%)                  self.next_ctrl = self.next_ctrl.add(Group::WIDTH);
         .                       }
         .                   }
         .               }
         .           
         .               #[inline]
         .               fn size_hint(&self) -> (usize, Option<usize>) {
         .                   // We don't have an item count, so just guess based on the range size.
         .                   (
-- line 1966 ----------------------------------------
-- line 2102 ----------------------------------------
         .                           }
         .                       } else {
         .                           // We must have already iterated past the removed item.
         .                       }
         .                   }
         .               }
         .           
         .               unsafe fn drop_elements(&mut self) {
     1,721 ( 0.00%)          if mem::needs_drop::<T>() && self.len() != 0 {
         .                       for item in self {
         .                           item.drop();
         .                       }
         .                   }
         .               }
         .           }
         .           
         .           impl<T> Clone for RawIter<T> {
-- line 2118 ----------------------------------------
-- line 2124 ----------------------------------------
         .                   }
         .               }
         .           }
         .           
         .           impl<T> Iterator for RawIter<T> {
         .               type Item = Bucket<T>;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
    45,237 ( 0.00%)      fn next(&mut self) -> Option<Bucket<T>> {
   157,362 ( 0.01%)          if let Some(b) = self.iter.next() {
   343,880 ( 0.01%)              self.items -= 1;
         .                       Some(b)
         .                   } else {
         .                       // We don't check against items == 0 here to allow the
         .                       // compiler to optimize away the item count entirely if the
         .                       // iterator length is never queried.
         .                       debug_assert_eq!(self.items, 0);
         .                       None
         .                   }
    90,474 ( 0.00%)      }
         .           
         .               #[inline]
         .               fn size_hint(&self) -> (usize, Option<usize>) {
         .                   (self.items, Some(self.items))
         .               }
         .           }
         .           
         .           impl<T> ExactSizeIterator for RawIter<T> {}
-- line 2151 ----------------------------------------
-- line 2177 ----------------------------------------
         .               T: Sync,
         .               A: Sync,
         .           {
         .           }
         .           
         .           #[cfg(feature = "nightly")]
         .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
     3,150 ( 0.00%)      fn drop(&mut self) {
         .                   unsafe {
         .                       // Drop all remaining elements
         .                       self.iter.drop_elements();
         .           
         .                       // Free the table
    21,102 ( 0.00%)              if let Some((ptr, layout)) = self.allocation {
         .                           self.alloc.deallocate(ptr, layout);
         .                       }
         .                   }
       318 ( 0.00%)      }
         .           }
         .           #[cfg(not(feature = "nightly"))]
         .           impl<T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn drop(&mut self) {
         .                   unsafe {
         .                       // Drop all remaining elements
         .                       self.iter.drop_elements();
-- line 2203 ----------------------------------------
-- line 2209 ----------------------------------------
         .                   }
         .               }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> Iterator for RawIntoIter<T, A> {
         .               type Item = T;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
     1,994 ( 0.00%)      fn next(&mut self) -> Option<T> {
     1,398 ( 0.00%)          unsafe { Some(self.iter.next()?.read()) }
     4,591 ( 0.00%)      }
         .           
         .               #[inline]
         .               fn size_hint(&self) -> (usize, Option<usize>) {
         4 ( 0.00%)          self.iter.size_hint()
         .               }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> ExactSizeIterator for RawIntoIter<T, A> {}
         .           impl<T, A: Allocator + Clone> FusedIterator for RawIntoIter<T, A> {}
         .           
         .           /// Iterator which consumes elements without freeing the table storage.
         .           pub struct RawDrain<'a, T, A: Allocator + Clone = Global> {
-- line 2231 ----------------------------------------
-- line 2259 ----------------------------------------
         .           where
         .               T: Sync,
         .               A: Sync,
         .           {
         .           }
         .           
         .           impl<T, A: Allocator + Clone> Drop for RawDrain<'_, T, A> {
         .               #[cfg_attr(feature = "inline-more", inline)]
     1,256 ( 0.00%)      fn drop(&mut self) {
         .                   unsafe {
         .                       // Drop all remaining elements. Note that this may panic.
         .                       self.iter.drop_elements();
         .           
         .                       // Reset the contents of the table now that all elements have been
         .                       // dropped.
         .                       self.table.clear_no_drop();
         .           
         .                       // Move the now empty table back to its original location.
       157 ( 0.00%)              self.orig_table
         .                           .as_ptr()
         .                           .copy_from_nonoverlapping(&*self.table, 1);
         .                   }
     1,256 ( 0.00%)      }
         .           }
         .           
         .           impl<T, A: Allocator + Clone> Iterator for RawDrain<'_, T, A> {
         .               type Item = T;
         .           
         .               #[cfg_attr(feature = "inline-more", inline)]
         .               fn next(&mut self) -> Option<T> {
         .                   unsafe {
-- line 2289 ----------------------------------------

 9,747,299 ( 0.37%)  <counts for unidentified lines in /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/library/core/src/num/uint_macros.rs
--------------------------------------------------------------------------------
Ir                 

-- line 57 ----------------------------------------
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
        .                   ///
        .                   /// ```
        .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::from_str_radix(\"A\", 16), Ok(10));")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
    1,592 ( 0.00%)          pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {
      796 ( 0.00%)              from_str_radix(src, radix)
    2,388 ( 0.00%)          }
        .           
        .                   /// Returns the number of ones in the binary representation of `self`.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
        .                   ///
        .                   /// ```
-- line 75 ----------------------------------------
-- line 80 ----------------------------------------
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
        .                   #[doc(alias = "popcount")]
        .                   #[doc(alias = "popcnt")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn count_ones(self) -> u32 {
  230,700 ( 0.01%)              intrinsics::ctpop(self as $ActualT) as u32
        .                   }
        .           
        .                   /// Returns the number of zeros in the binary representation of `self`.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
        .                   ///
-- line 96 ----------------------------------------
-- line 118 ----------------------------------------
        .                   /// assert_eq!(n.leading_zeros(), 2);
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn leading_zeros(self) -> u32 {
  448,668 ( 0.02%)              intrinsics::ctlz(self as $ActualT) as u32
        .                   }
        .           
        .                   /// Returns the number of trailing zeros in the binary representation
        .                   /// of `self`.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 134 ----------------------------------------
-- line 139 ----------------------------------------
        .                   /// assert_eq!(n.trailing_zeros(), 3);
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn trailing_zeros(self) -> u32 {
  424,764 ( 0.02%)              intrinsics::cttz(self) as u32
        .                   }
        .           
        .                   /// Returns the number of leading ones in the binary representation of `self`.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
        .                   ///
-- line 155 ----------------------------------------
-- line 204 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(n.rotate_left(", $rot, "), m);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn rotate_left(self, n: u32) -> Self {
8,670,927 ( 0.33%)              intrinsics::rotate_left(self, n as $SelfT)
        .                   }
        .           
        .                   /// Shifts the bits to the right by a specified amount, `n`,
        .                   /// wrapping the truncated bits to the beginning of the resulting
        .                   /// integer.
        .                   ///
        .                   /// Please note this isn't the same operation as the `>>` shifting operator!
        .                   ///
-- line 220 ----------------------------------------
-- line 430 ----------------------------------------
        .                   #[doc = concat!("assert_eq!((", stringify!($SelfT), "::MAX - 2).checked_add(3), None);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_checked_int_methods", since = "1.47.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline]
        .                   pub const fn checked_add(self, rhs: Self) -> Option<Self> {
        4 ( 0.00%)              let (a, b) = self.overflowing_add(rhs);
        .                       if unlikely!(b) {None} else {Some(a)}
        .                   }
        .           
        .                   /// Unchecked integer addition. Computes `self + rhs`, assuming overflow
        .                   /// cannot occur.
        .                   ///
        .                   /// # Safety
        .                   ///
-- line 446 ----------------------------------------
-- line 456 ----------------------------------------
        .                   )]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[rustc_const_unstable(feature = "const_inherent_unchecked_arith", issue = "85122")]
        .                   #[inline(always)]
        .                   pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
        .                       // SAFETY: the caller must uphold the safety contract for
        .                       // `unchecked_add`.
  794,187 ( 0.03%)              unsafe { intrinsics::unchecked_add(self, rhs) }
        .                   }
        .           
        .                   /// Checked addition with a signed integer. Computes `self + rhs`,
        .                   /// returning `None` if overflow occurred.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 472 ----------------------------------------
-- line 525 ----------------------------------------
        .                   )]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[rustc_const_unstable(feature = "const_inherent_unchecked_arith", issue = "85122")]
        .                   #[inline(always)]
        .                   pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {
        .                       // SAFETY: the caller must uphold the safety contract for
        .                       // `unchecked_sub`.
   58,726 ( 0.00%)              unsafe { intrinsics::unchecked_sub(self, rhs) }
        .                   }
        .           
        .                   /// Checked integer multiplication. Computes `self * rhs`, returning
        .                   /// `None` if overflow occurred.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 541 ----------------------------------------
-- line 596 ----------------------------------------
        .                                 without modifying the original"]
        .                   #[inline]
        .                   pub const fn checked_div(self, rhs: Self) -> Option<Self> {
        .                       if unlikely!(rhs == 0) {
        .                           None
        .                       } else {
        .                           // SAFETY: div by zero has been checked above and unsigned types have no other
        .                           // failure modes for division
    1,032 ( 0.00%)                  Some(unsafe { intrinsics::unchecked_div(self, rhs) })
        .                       }
        .                   }
        .           
        .                   /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`
        .                   /// if `rhs == 0`.
        .                   ///
        .                   /// # Examples
        .                   ///
-- line 612 ----------------------------------------
-- line 1035 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.saturating_add(127), ", stringify!($SelfT), "::MAX);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
        .                   #[inline(always)]
        .                   pub const fn saturating_add(self, rhs: Self) -> Self {
  210,451 ( 0.01%)              intrinsics::saturating_add(self, rhs)
        .                   }
        .           
        .                   /// Saturating addition with a signed integer. Computes `self + rhs`,
        .                   /// saturating at the numeric bounds instead of overflowing.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 1051 ----------------------------------------
-- line 1084 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(13", stringify!($SelfT), ".saturating_sub(127), 0);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
        .                   #[inline(always)]
        .                   pub const fn saturating_sub(self, rhs: Self) -> Self {
   15,715 ( 0.00%)              intrinsics::saturating_sub(self, rhs)
        .                   }
        .           
        .                   /// Saturating integer multiplication. Computes `self * rhs`,
        .                   /// saturating at the numeric bounds instead of overflowing.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 1100 ----------------------------------------
-- line 1104 ----------------------------------------
        .                   #[doc = concat!("assert_eq!((", stringify!($SelfT), "::MAX).saturating_mul(10), ", stringify!($SelfT),"::MAX);")]
        .                   /// ```
        .                   #[stable(feature = "wrapping", since = "1.7.0")]
        .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline]
        .                   pub const fn saturating_mul(self, rhs: Self) -> Self {
       20 ( 0.00%)              match self.checked_mul(rhs) {
        .                           Some(x) => x,
        .                           None => Self::MAX,
        .                       }
        .                   }
        .           
        .                   /// Saturating integer division. Computes `self / rhs`, saturating at the
        .                   /// numeric bounds instead of overflowing.
        .                   ///
-- line 1120 ----------------------------------------
-- line 1175 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(200", stringify!($SelfT), ".wrapping_add(", stringify!($SelfT), "::MAX), 199);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn wrapping_add(self, rhs: Self) -> Self {
5,071,472 ( 0.19%)              intrinsics::wrapping_add(self, rhs)
        .                   }
        .           
        .                   /// Wrapping (modular) addition with a signed integer. Computes
        .                   /// `self + rhs`, wrapping around at the boundary of the type.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 1191 ----------------------------------------
-- line 1217 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(100", stringify!($SelfT), ".wrapping_sub(", stringify!($SelfT), "::MAX), 101);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn wrapping_sub(self, rhs: Self) -> Self {
1,602,931 ( 0.06%)              intrinsics::wrapping_sub(self, rhs)
        .                   }
        .           
        .                   /// Wrapping (modular) multiplication. Computes `self *
        .                   /// rhs`, wrapping around at the boundary of the type.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 1233 ----------------------------------------
-- line 1240 ----------------------------------------
        .                   /// assert_eq!(25u8.wrapping_mul(12), 44);
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn wrapping_mul(self, rhs: Self) -> Self {
5,142,828 ( 0.20%)              intrinsics::wrapping_mul(self, rhs)
        .                   }
        .           
        .                   /// Wrapping (modular) division. Computes `self / rhs`.
        .                   /// Wrapped division on unsigned types is just normal division.
        .                   /// There's no way wrapping could ever happen.
        .                   /// This function exists, so that all operations
        .                   /// are accounted for in the wrapping operations.
        .                   ///
-- line 1256 ----------------------------------------
-- line 1491 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(5", stringify!($SelfT), ".overflowing_add(2), (7, false));")]
        .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.overflowing_add(1), (0, true));")]
        .                   /// ```
        .                   #[stable(feature = "wrapping", since = "1.7.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
       20 ( 0.00%)          pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
  751,270 ( 0.03%)              let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
        .                       (a as Self, b)
       40 ( 0.00%)          }
        .           
        .                   /// Calculates `self + rhs + carry` without the ability to overflow.
        .                   ///
        .                   /// Performs "ternary addition" which takes in an extra bit to add, and may return an
        .                   /// additional bit of overflow. This allows for chaining together multiple additions
        .                   /// to create "big integers" which represent larger values.
        .                   ///
        .                   #[doc = concat!("This can be thought of as a ", stringify!($BITS), "-bit \"full adder\", in the electronics sense.")]
-- line 1510 ----------------------------------------
-- line 1587 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(5", stringify!($SelfT), ".overflowing_sub(2), (3, false));")]
        .                   #[doc = concat!("assert_eq!(0", stringify!($SelfT), ".overflowing_sub(1), (", stringify!($SelfT), "::MAX, true));")]
        .                   /// ```
        .                   #[stable(feature = "wrapping", since = "1.7.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
       20 ( 0.00%)          pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
  141,478 ( 0.01%)              let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);
        .                       (a as Self, b)
       40 ( 0.00%)          }
        .           
        .                   /// Calculates `self - rhs - borrow` without the ability to overflow.
        .                   ///
        .                   /// Performs "ternary subtraction" which takes in an extra bit to subtract, and may return
        .                   /// an additional bit of overflow. This allows for chaining together multiple subtractions
        .                   /// to create "big integers" which represent larger values.
        .                   ///
        .                   /// # Examples
-- line 1606 ----------------------------------------
-- line 1674 ----------------------------------------
        .                   /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));
        .                   /// ```
        .                   #[stable(feature = "wrapping", since = "1.7.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                     without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
1,387,302 ( 0.05%)              let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
        .                       (a as Self, b)
        .                   }
        .           
        .                   /// Calculates the divisor when `self` is divided by `rhs`.
        .                   ///
        .                   /// Returns a tuple of the divisor along with a boolean indicating
        .                   /// whether an arithmetic overflow would occur. Note that for unsigned
        .                   /// integers overflow never occurs, so the second value is always
-- line 1690 ----------------------------------------
-- line 2132 ----------------------------------------
        .                   #[doc = concat!("assert!(16", stringify!($SelfT), ".is_power_of_two());")]
        .                   #[doc = concat!("assert!(!10", stringify!($SelfT), ".is_power_of_two());")]
        .                   /// ```
        .                   #[must_use]
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_is_power_of_two", since = "1.32.0")]
        .                   #[inline(always)]
        .                   pub const fn is_power_of_two(self) -> bool {
      162 ( 0.00%)              self.count_ones() == 1
        .                   }
        .           
        .                   // Returns one less than next power of two.
        .                   // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)
        .                   //
        .                   // 8u8.one_less_than_next_power_of_two() == 7
        .                   // 6u8.one_less_than_next_power_of_two() == 7
        .                   //
        .                   // This method cannot overflow, as in the `next_power_of_two`
        .                   // overflow cases it instead ends up returning the maximum value
        .                   // of the type, and can return 0 for 0.
        .                   #[inline]
        .                   #[rustc_const_stable(feature = "const_int_pow", since = "1.50.0")]
        .                   const fn one_less_than_next_power_of_two(self) -> Self {
    7,150 ( 0.00%)              if self <= 1 { return 0; }
        .           
   18,201 ( 0.00%)              let p = self - 1;
        .                       // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
        .                       // That means the shift is always in-bounds, and some processors
        .                       // (such as intel pre-haswell) have more efficient ctlz
        .                       // intrinsics when the argument is non-zero.
   54,475 ( 0.00%)              let z = unsafe { intrinsics::ctlz_nonzero(p) };
   18,201 ( 0.00%)              <$SelfT>::MAX >> z
        .                   }
        .           
        .                   /// Returns the smallest power of two greater than or equal to `self`.
        .                   ///
        .                   /// When return value overflows (i.e., `self > (1 << (N-1))` for type
        .                   /// `uN`), it panics in debug mode and the return value is wrapped to 0 in
        .                   /// release mode (the only situation in which method can return 0).
        .                   ///
-- line 2171 ----------------------------------------
-- line 2179 ----------------------------------------
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_int_pow", since = "1.50.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline]
        .                   #[rustc_inherit_overflow_checks]
        .                   pub const fn next_power_of_two(self) -> Self {
   29,188 ( 0.00%)              self.one_less_than_next_power_of_two() + 1
        .                   }
        .           
        .                   /// Returns the smallest power of two greater than or equal to `n`. If
        .                   /// the next power of two is greater than the type's maximum value,
        .                   /// `None` is returned, otherwise the power of two is wrapped in `Some`.
        .                   ///
        .                   /// # Examples
        .                   ///
-- line 2195 ----------------------------------------

   99,156 ( 0.00%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/library/core/src/num/uint_macros.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/dl-lookup.c
  ./malloc/malloc.c
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
192,579,124 ( 7.36%)  events annotated

