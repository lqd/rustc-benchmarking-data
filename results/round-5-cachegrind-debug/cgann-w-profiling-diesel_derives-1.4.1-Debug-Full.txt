--------------------------------------------------------------------------------
I1 cache:         65536 B, 64 B, 4-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         67108864 B, 64 B, 64-way associative
Command:          /usr/home/liquid/.rustup/toolchains/w-profiling/bin/rustc --crate-name diesel_derives src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debuginfo=2 --cfg feature="default" -C metadata=22df57f9953d4e67 -C extra-filename=-22df57f9953d4e67 --out-dir /usr/home/liquid/tmp/.tmpF20bKX/target/debug/deps -L dependency=/usr/home/liquid/tmp/.tmpF20bKX/target/debug/deps --extern proc_macro2=/usr/home/liquid/tmp/.tmpF20bKX/target/debug/deps/libproc_macro2-9ea6a84c35e9561f.rlib --extern quote=/usr/home/liquid/tmp/.tmpF20bKX/target/debug/deps/libquote-cd8d7b2b48dc8cf8.rlib --extern syn=/usr/home/liquid/tmp/.tmpF20bKX/target/debug/deps/libsyn-7301d1080effdf98.rlib --extern proc_macro -Adeprecated -Aunknown-lints -Zincremental-verify-ich
Data file:        results/cgout-w-profiling-diesel_derives-1.4.1-Debug-Full
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       0.1
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      
--------------------------------------------------------------------------------
37,422,518,972 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                      file:function
--------------------------------------------------------------------------------
1,922,612,933 ( 5.14%)  ???:llvm::FPPassManager::runOnFunction(llvm::Function&)
1,523,373,533 ( 4.07%)  ???:llvm::SelectionDAG::Combine(llvm::CombineLevel, llvm::AAResults*, llvm::CodeGenOpt::Level)
  795,131,382 ( 2.12%)  ./malloc/malloc.c:_int_free
  769,470,350 ( 2.06%)  ./malloc/malloc.c:_int_malloc
  688,243,816 ( 1.84%)  ???:llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode*, unsigned char const*, unsigned int)
  586,816,274 ( 1.57%)  ???:llvm::AttributeList::addAttributes(llvm::LLVMContext&, unsigned int, llvm::AttrBuilder const&) const
  530,911,906 ( 1.42%)  ???:(anonymous namespace)::Verifier::visitInstruction(llvm::Instruction&)
  493,003,858 ( 1.32%)  ./malloc/malloc.c:malloc
  465,462,798 ( 1.24%)  ???:llvm::MachineInstr::addOperand(llvm::MachineFunction&, llvm::MachineOperand const&)
  419,384,272 ( 1.12%)  ???:llvm::PMDataManager::verifyPreservedAnalysis(llvm::Pass*)
  398,920,199 ( 1.07%)  ???:llvm::raw_svector_ostream::write_impl(char const*, unsigned long)
  383,863,743 ( 1.03%)  ???:(anonymous namespace)::RegAllocFast::allocateBasicBlock(llvm::MachineBasicBlock&)
  370,155,587 ( 0.99%)  ???:(anonymous namespace)::Verifier::visitMDNode(llvm::MDNode const&, (anonymous namespace)::Verifier::AreDebugLocsAllowed)
  325,670,973 ( 0.87%)  ???:llvm::ScheduleDAGSDNodes::BuildSchedUnits()
  319,432,947 ( 0.85%)  ???:llvm::MCExpr::evaluateAsRelocatableImpl(llvm::MCValue&, llvm::MCAssembler const*, llvm::MCAsmLayout const*, llvm::MCFixup const*, llvm::DenseMap<llvm::MCSection const*, unsigned long, llvm::DenseMapInfo<llvm::MCSection const*>, llvm::detail::DenseMapPair<llvm::MCSection const*, unsigned long> > const*, bool) const
  299,985,348 ( 0.80%)  ???:llvm::TargetLoweringBase::getTypeConversion(llvm::LLVMContext&, llvm::EVT) const
  250,665,033 ( 0.67%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_erms
  249,377,114 ( 0.67%)  ???:llvm::MCAsmLayout::getSymbolOffset(llvm::MCSymbol const&) const
  246,413,024 ( 0.66%)  ???:llvm::SelectionDAG::MorphNodeTo(llvm::SDNode*, unsigned int, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>)
  237,218,316 ( 0.63%)  ./malloc/malloc.c:free
  231,739,892 ( 0.62%)  ???:(anonymous namespace)::VarLocBasedLDV::process(llvm::MachineInstr&, (anonymous namespace)::VarLocBasedLDV::OpenRangesSet&, (anonymous namespace)::VarLocBasedLDV::VarLocMap&, llvm::SmallVector<(anonymous namespace)::VarLocBasedLDV::TransferDebugPair, 4u>&)
  224,695,453 ( 0.60%)  ???:llvm::InstrEmitter::EmitMachineNode(llvm::SDNode*, bool, bool, llvm::DenseMap<llvm::SDValue, llvm::Register, llvm::DenseMapInfo<llvm::SDValue>, llvm::detail::DenseMapPair<llvm::SDValue, llvm::Register> >&)
  219,208,473 ( 0.59%)  ???:llvm::SelectionDAG::getConstant(llvm::ConstantInt const&, llvm::SDLoc const&, llvm::EVT, bool, bool)
  212,201,329 ( 0.57%)  ???:(anonymous namespace)::SelectionDAGLegalize::LegalizeOp(llvm::SDNode*) [clone .llvm.8386621111310650999]
  207,118,344 ( 0.55%)  ???:llvm::DAGTypeLegalizer::run()
  206,934,502 ( 0.55%)  ???:llvm::StringMapImpl::LookupBucketFor(llvm::StringRef)
  196,091,897 ( 0.52%)  ???:(anonymous namespace)::Verifier::visitCallBase(llvm::CallBase&)
  191,506,642 ( 0.51%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  183,351,024 ( 0.49%)  ???:llvm::TargetRegisterInfo::shouldRealignStack(llvm::MachineFunction const&) const
  177,616,792 ( 0.47%)  ???:llvm::SmallSet<llvm::Register, 32u, std::less<llvm::Register> >::insert(llvm::Register const&)
  172,947,420 ( 0.46%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe
  170,396,117 ( 0.46%)  ???:llvm::MetadataTracking::track(void*, llvm::Metadata&, llvm::PointerUnion<llvm::MetadataAsValue*, llvm::Metadata*>)
  169,860,129 ( 0.45%)  ???:(anonymous namespace)::TwoAddressInstructionPass::runOnMachineFunction(llvm::MachineFunction&)
  169,511,589 ( 0.45%)  ???:multikeySort(llvm::MutableArrayRef<std::pair<llvm::CachedHashStringRef, unsigned long>*>, int)
  163,471,876 ( 0.44%)  ???:llvm::calculateDbgEntityHistory(llvm::MachineFunction const*, llvm::TargetRegisterInfo const*, llvm::DbgValueHistoryMap&, llvm::DbgLabelInstrMap&)
  162,005,933 ( 0.43%)  ???:(anonymous namespace)::DAGCombiner::combine(llvm::SDNode*)
  160,660,908 ( 0.43%)  ???:llvm::TargetRegisterInfo::checkAllSuperRegsMarked(llvm::BitVector const&, llvm::ArrayRef<unsigned short>) const
  160,470,176 ( 0.43%)  ???:llvm::SelectionDAG::Legalize()
  160,434,254 ( 0.43%)  ???:llvm::coro::declaresIntrinsics(llvm::Module const&, std::initializer_list<llvm::StringRef>)
  156,013,623 ( 0.42%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_sse2_unaligned_erms
  154,651,671 ( 0.41%)  ???:(anonymous namespace)::X86MCCodeEmitter::emitPrefixImpl(unsigned int&, llvm::MCInst const&, llvm::MCSubtargetInfo const&, llvm::raw_ostream&) const
  153,879,324 ( 0.41%)  ???:(anonymous namespace)::VarLocBasedLDV::ExtendRanges(llvm::MachineFunction&, llvm::TargetPassConfig*) [clone .llvm.4451506318407214204]
  151,057,398 ( 0.40%)  ???:(anonymous namespace)::Verifier::verify(llvm::Function const&) [clone .llvm.4153962086227604281]
  149,521,996 ( 0.40%)  ???:(anonymous namespace)::Verifier::verifyFunctionAttrs(llvm::FunctionType*, llvm::AttributeList, llvm::Value const*, bool)
  147,672,658 ( 0.39%)  ???:llvm::MCAsmLayout::getFragmentOffset(llvm::MCFragment const*) const
  145,957,059 ( 0.39%)  ???:(anonymous namespace)::ScheduleDAGRRList::Schedule() [clone .llvm.6953762222372402862]
  145,503,101 ( 0.39%)  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S:__strncmp_avx2
  143,226,845 ( 0.38%)  ???:llvm::FoldingSetBase::FindNodeOrInsertPos(llvm::FoldingSetNodeID const&, void*&, llvm::FoldingSetBase::FoldingSetInfo const&)
  140,114,953 ( 0.37%)  ???:llvm::MCObjectStreamer::emitBytes(llvm::StringRef)
  133,433,998 ( 0.36%)  ???:llvm::FoldingSet<llvm::SDNode>::NodeEquals(llvm::FoldingSetBase const*, llvm::FoldingSetBase::Node*, llvm::FoldingSetNodeID const&, unsigned int, llvm::FoldingSetNodeID&)
  126,609,585 ( 0.34%)  ???:llvm::MCContext::getOrCreateSymbol(llvm::Twine const&)
  122,901,986 ( 0.33%)  ???:llvm::ScheduleDAGSDNodes::AddSchedEdges()
  120,816,117 ( 0.32%)  ???:llvm::FoldingSetNodeID::AddInteger(unsigned int)
  117,800,287 ( 0.31%)  ???:(anonymous namespace)::VectorLegalizer::LegalizeOp(llvm::SDValue) [clone .llvm.3993696295502019106]
  117,305,010 ( 0.31%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::CalculateFromScratch(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::BatchUpdateInfo*)
  117,108,059 ( 0.31%)  ???:(anonymous namespace)::PEI::runOnMachineFunction(llvm::MachineFunction&)
  111,530,037 ( 0.30%)  ???:llvm::SelectionDAG::AssignTopologicalOrder()
  100,115,272 ( 0.27%)  ./malloc/malloc.c:malloc_consolidate
   99,910,519 ( 0.27%)  ???:(anonymous namespace)::X86MCInstLower::Lower(llvm::MachineInstr const*, llvm::MCInst&) const
   99,401,288 ( 0.27%)  ./stdlib/msort.c:msort_with_tmp.part.0
   97,108,900 ( 0.26%)  ???:llvm::SelectionDAG::getRegister(unsigned int, llvm::EVT)
   95,732,142 ( 0.26%)  ???:(anonymous namespace)::Verifier::visitFunction(llvm::Function const&)::$_3::operator()(llvm::Instruction const&, llvm::MDNode const*) const
   95,067,413 ( 0.25%)  ???:llvm::DwarfDebug::beginInstruction(llvm::MachineInstr const*)
   94,837,936 ( 0.25%)  ???:llvm::X86FrameLowering::hasFP(llvm::MachineFunction const&) const
   92,303,560 ( 0.25%)  ???:llvm::TargetLowering::SimplifyDemandedBits(llvm::SDValue, llvm::APInt const&, llvm::APInt const&, llvm::KnownBits&, llvm::TargetLowering::TargetLoweringOpt&, unsigned int, bool) const
   91,915,960 ( 0.25%)  ???:(anonymous namespace)::X86MCCodeEmitter::encodeInstruction(llvm::MCInst const&, llvm::raw_ostream&, llvm::SmallVectorImpl<llvm::MCFixup>&, llvm::MCSubtargetInfo const&) const
   90,417,743 ( 0.24%)  ???:(anonymous namespace)::ELFObjectWriter::recordRelocation(llvm::MCAssembler&, llvm::MCAsmLayout const&, llvm::MCFragment const*, llvm::MCFixup const&, llvm::MCValue, unsigned long&) [clone .llvm.14145361893594770252]
   89,909,386 ( 0.24%)  ???:llvm::AttributeSetNode::get(llvm::LLVMContext&, llvm::AttrBuilder const&)
   88,699,825 ( 0.24%)  ./malloc/malloc.c:unlink_chunk.constprop.0
   85,594,936 ( 0.23%)  ???:llvm::FunctionLoweringInfo::set(llvm::Function const&, llvm::MachineFunction&, llvm::SelectionDAG*)
   84,684,143 ( 0.23%)  ???:llvm::DataLayout::getAlignment(llvm::Type*, bool) const
   84,489,932 ( 0.23%)  ???:llvm::SelectionDAG::computeKnownBits(llvm::SDValue, llvm::APInt const&, unsigned int) const
   83,326,757 ( 0.22%)  ???:llvm::MachineFunction::CreateMachineInstr(llvm::MCInstrDesc const&, llvm::DebugLoc const&, bool)
   82,976,670 ( 0.22%)  ???:llvm::FoldingSet<llvm::AttributeImpl>::NodeEquals(llvm::FoldingSetBase const*, llvm::FoldingSetBase::Node*, llvm::FoldingSetNodeID const&, unsigned int, llvm::FoldingSetNodeID&)
   80,959,302 ( 0.22%)  ???:llvm::PMDataManager::removeNotPreservedAnalysis(llvm::Pass*)
   78,254,864 ( 0.21%)  ???:llvm::SmallPtrSetImplBase::insert_imp_big(void const*)
   77,268,617 ( 0.21%)  ???:llvm::ScheduleDAGSDNodes::EmitSchedule(llvm::MachineInstrBundleIterator<llvm::MachineInstr, false>&)
   76,093,037 ( 0.20%)  ???:llvm::SelectionDAG::getNode(unsigned int, llvm::SDLoc const&, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>)
   74,908,365 ( 0.20%)  ???:(anonymous namespace)::RegAllocFast::markRegUsedInInstr(unsigned short)
   74,719,032 ( 0.20%)  ???:llvm::SelectionDAGISel::SelectAllBasicBlocks(llvm::Function const&)
   74,167,271 ( 0.20%)  ???:(anonymous namespace)::VarLocBasedLDV::collectIDsForRegs(llvm::SmallSet<unsigned int, 32u, std::less<unsigned int> >&, llvm::SmallSet<llvm::Register, 32u, std::less<llvm::Register> > const&, llvm::CoalescingBitVector<unsigned long> const&, (anonymous namespace)::VarLocBasedLDV::VarLocMap const&)
   71,668,295 ( 0.19%)  ???:llvm::SelectionDAG::getNode(unsigned int, llvm::SDLoc const&, llvm::EVT, llvm::SDValue, llvm::SDValue, llvm::SDNodeFlags)
   71,569,897 ( 0.19%)  ???:llvm::Twine::printOneChild(llvm::raw_ostream&, llvm::Twine::Child, llvm::Twine::NodeKind) const
   71,276,216 ( 0.19%)  /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs:<hashbrown::map::RawEntryBuilderMut<rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>, (), core::hash::BuildHasherDefault<rustc_hash::FxHasher>>>::from_hash::<hashbrown::map::equivalent<rustc_middle::ty::sty::TyKind, rustc_middle::ty::context::Interned<rustc_middle::ty::TyS>>::{closure#0}>
   70,945,603 ( 0.19%)  ???:llvm::AsmPrinter::emitFunctionBody()
   69,893,093 ( 0.19%)  ???:(anonymous namespace)::ELFWriter::writeObject(llvm::MCAssembler&, llvm::MCAsmLayout const&)
   69,805,975 ( 0.19%)  ???:llvm::MCAssembler::layout(llvm::MCAsmLayout&)
   69,621,557 ( 0.19%)  ???:llvm::X86RegisterInfo::eliminateFrameIndex(llvm::MachineInstrBundleIterator<llvm::MachineInstr, false>, int, unsigned int, llvm::RegScavenger*) const
   69,189,593 ( 0.18%)  ???:llvm::X86TargetMachine::getTargetTransformInfo(llvm::Function const&)
   68,645,605 ( 0.18%)  ???:(anonymous namespace)::X86MCCodeEmitter::emitMemModRMByte(llvm::MCInst const&, unsigned int, unsigned int, unsigned long, bool, unsigned long, llvm::raw_ostream&, llvm::SmallVectorImpl<llvm::MCFixup>&, llvm::MCSubtargetInfo const&, bool) const
   68,485,705 ( 0.18%)  ???:llvm::MCELFStreamer::emitLabel(llvm::MCSymbol*, llvm::SMLoc)
   67,921,744 ( 0.18%)  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long)
   67,893,675 ( 0.18%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   67,095,105 ( 0.18%)  ???:(anonymous namespace)::CFIInstrInserter::runOnMachineFunction(llvm::MachineFunction&)
   66,939,281 ( 0.18%)  ???:llvm::MCELFStreamer::emitInstToData(llvm::MCInst const&, llvm::MCSubtargetInfo const&)
   66,844,798 ( 0.18%)  ???:llvm::MDNode::MDNode(llvm::LLVMContext&, unsigned int, llvm::Metadata::StorageType, llvm::ArrayRef<llvm::Metadata*>, llvm::ArrayRef<llvm::Metadata*>)
   64,989,883 ( 0.17%)  ???:llvm::raw_ostream::write(char const*, unsigned long)
   62,808,151 ( 0.17%)  /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs:<rustc_span::source_map::SourceMap>::lookup_source_file_idx
   61,909,434 ( 0.17%)  ???:llvm::SmallDenseMap<llvm::SDNode*, llvm::detail::DenseSetEmpty, 32u, llvm::DenseMapInfo<llvm::SDNode*>, llvm::detail::DenseSetPair<llvm::SDNode*> >::grow(unsigned int)
   61,576,310 ( 0.16%)  ???:llvm::CoalescingBitVector<unsigned long>::find(unsigned long) const
   60,601,012 ( 0.16%)  ???:llvm::SelectionDAG::clear()
   60,381,872 ( 0.16%)  ???:llvm::MCObjectStreamer::emitInstruction(llvm::MCInst const&, llvm::MCSubtargetInfo const&)
   59,867,915 ( 0.16%)  ???:llvm::MachineFunctionPass::runOnFunction(llvm::Function&)
   59,315,328 ( 0.16%)  ???:llvm::X86TargetLowering::PerformDAGCombine(llvm::SDNode*, llvm::TargetLowering::DAGCombinerInfo&) const
   59,210,987 ( 0.16%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:memcpy@GLIBC_2.2.5
   58,302,941 ( 0.16%)  ???:llvm::MDString::get(llvm::LLVMContext&, llvm::StringRef)
   56,426,913 ( 0.15%)  ???:???
   54,870,344 ( 0.15%)  ???:llvm::MCDwarfLineAddr::Encode(llvm::MCContext&, llvm::MCDwarfLineTableParams, long, unsigned long, llvm::raw_ostream&)
   54,836,353 ( 0.15%)  ???:llvm::DomTreeBuilder::SemiNCAInfo<llvm::DominatorTreeBase<llvm::BasicBlock, false> >::runSemiNCA(llvm::DominatorTreeBase<llvm::BasicBlock, false>&, unsigned int)
   52,208,947 ( 0.14%)  ???:llvm::LLVMContextImpl::~LLVMContextImpl()
   51,964,946 ( 0.14%)  ???:llvm::SelectionDAG::getConstant(unsigned long, llvm::SDLoc const&, llvm::EVT, bool, bool)
   51,507,962 ( 0.14%)  ???:llvm::MCAssembler::layoutSectionOnce(llvm::MCAsmLayout&, llvm::MCSection&)
   51,252,717 ( 0.14%)  ???:(anonymous namespace)::RegAllocFast::setPhysReg(llvm::MachineInstr&, llvm::MachineOperand&, unsigned short)
   51,095,837 ( 0.14%)  ???:llvm::LazyCallGraph::Node::populateSlow()
   51,058,582 ( 0.14%)  ???:(anonymous namespace)::X86AsmBackend::applyFixup(llvm::MCAssembler const&, llvm::MCFixup const&, llvm::MCValue const&, llvm::MutableArrayRef<char>, unsigned long, bool, llvm::MCSubtargetInfo const*) const
   50,913,756 ( 0.14%)  ???:llvm::TargetLoweringBase::ArgListEntry::setAttributes(llvm::CallBase const*, unsigned int)
   50,883,761 ( 0.14%)  ???:llvm::DenseMapIterator<llvm::DebugVariable, std::pair<llvm::MachineOperand*, llvm::DIExpression const*>, llvm::DenseMapInfo<llvm::DebugVariable>, llvm::detail::DenseMapPair<llvm::DebugVariable, std::pair<llvm::MachineOperand*, llvm::DIExpression const*> >, false>::AdvancePastEmptyBuckets()
   49,621,068 ( 0.13%)  ???:llvm::MetadataTracking::untrack(void*, llvm::Metadata&)
   49,530,142 ( 0.13%)  ???:llvm::DILocation::getImpl(llvm::LLVMContext&, unsigned int, unsigned int, llvm::Metadata*, llvm::Metadata*, bool, llvm::Metadata::StorageType, bool)
   49,443,269 ( 0.13%)  ???:llvm::SelectionDAGISel::DoInstructionSelection()
   49,052,370 ( 0.13%)  /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs:<rustc_span::source_map::SourceMap>::lookup_line
   49,052,370 ( 0.13%)  /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs:<rustc_span::SourceFile>::line_begin_pos
   48,782,167 ( 0.13%)  ???:llvm::X86FrameLowering::getFrameIndexReference(llvm::MachineFunction const&, int, llvm::Register&) const
   48,212,987 ( 0.13%)  ???:(anonymous namespace)::RemoveRedundantDebugValues::runOnMachineFunction(llvm::MachineFunction&)
   48,018,829 ( 0.13%)  ???:llvm::MachineInstr::AddRegOperandsToUseLists(llvm::MachineRegisterInfo&)
   47,833,353 ( 0.13%)  ???:(anonymous namespace)::RegAllocFast::allocVirtReg(llvm::MachineInstr&, (anonymous namespace)::RegAllocFast::LiveReg&, llvm::Register, bool)
   47,507,357 ( 0.13%)  ???:llvm::Function::dropAllReferences()
   47,175,196 ( 0.13%)  ???:llvm::SelectionDAG::RemoveDeadNodes()
   45,691,814 ( 0.12%)  ???:(anonymous namespace)::X86AsmBackend::emitInstructionBegin(llvm::MCObjectStreamer&, llvm::MCInst const&)
   45,541,665 ( 0.12%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_expand/src/mbe/macro_parser.rs:rustc_expand::mbe::macro_parser::parse_tt
   44,375,326 ( 0.12%)  ???:(anonymous namespace)::RegAllocFast::isRegUsedInInstr(unsigned short, bool) const
   44,304,264 ( 0.12%)  ???:(anonymous namespace)::RegAllocFast::freePhysReg(unsigned short)
   44,043,669 ( 0.12%)  ???:llvm::InstrEmitter::EmitCopyFromReg(llvm::SDNode*, unsigned int, bool, bool, llvm::Register, llvm::DenseMap<llvm::SDValue, llvm::Register, llvm::DenseMapInfo<llvm::SDValue>, llvm::detail::DenseMapPair<llvm::SDValue, llvm::Register> >&)
   42,591,096 ( 0.11%)  ???:llvm::X86RegisterInfo::getReservedRegs(llvm::MachineFunction const&) const
   42,476,873 ( 0.11%)  ???:llvm::MCStreamer::emitULEB128IntValue(unsigned long, unsigned int)
   42,468,315 ( 0.11%)  ???:llvm::printEscapedString(llvm::StringRef, llvm::raw_ostream&)
   42,141,406 ( 0.11%)  ???:(anonymous namespace)::X86DAGToDAGISel::selectAddr(llvm::SDNode*, llvm::SDValue, llvm::SDValue&, llvm::SDValue&, llvm::SDValue&, llvm::SDValue&, llvm::SDValue&)
   41,615,030 ( 0.11%)  ???:llvm::hashing::detail::hash_combine_recursive_helper::combine(unsigned long, char*, char*)
   41,097,623 ( 0.11%)  ???:(anonymous namespace)::X86AsmBackend::emitInstructionEnd(llvm::MCObjectStreamer&, llvm::MCInst const&)
   40,811,890 ( 0.11%)  ???:llvm::Module::getOrInsertFunction(llvm::StringRef, llvm::FunctionType*)
   40,567,994 ( 0.11%)  /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_middle/src/ty/subst.rs:<rustc_middle::ty::subst::SubstFolder as rustc_middle::ty::fold::TypeFolder>::fold_ty
   40,544,506 ( 0.11%)  ???:llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>::Allocate(unsigned long, llvm::Align)
   40,445,631 ( 0.11%)  ???:llvm::ScheduleDAGSDNodes::ClusterNeighboringLoads(llvm::SDNode*)
   40,055,506 ( 0.11%)  ???:llvm::LexicalScopes::extractLexicalScopes(llvm::SmallVectorImpl<std::pair<llvm::MachineInstr const*, llvm::MachineInstr const*> >&, llvm::DenseMap<llvm::MachineInstr const*, llvm::LexicalScope*, llvm::DenseMapInfo<llvm::MachineInstr const*>, llvm::detail::DenseMapPair<llvm::MachineInstr const*, llvm::LexicalScope*> >&)
   39,499,499 ( 0.11%)  ???:llvm::X86AsmPrinter::emitInstruction(llvm::MachineInstr const*)
   39,332,708 ( 0.11%)  ???:llvm::X86TargetMachine::getSubtargetImpl(llvm::Function const&) const
   39,124,681 ( 0.10%)  ???:(anonymous namespace)::X86DAGToDAGISel::Select(llvm::SDNode*) [clone .llvm.5851529081540066507]
   38,937,872 ( 0.10%)  ???:llvm::MCObjectStreamer::emitValueImpl(llvm::MCExpr const*, unsigned int, llvm::SMLoc)
   38,650,634 ( 0.10%)  ???:(anonymous namespace)::X86DAGToDAGISel::CheckNodePredicate(llvm::SDNode*, unsigned int) const [clone .llvm.5851529081540066507]
   38,455,548 ( 0.10%)  ./nptl/pthread_rwlock_common.c:pthread_rwlock_unlock
   38,324,496 ( 0.10%)  ???:llvm::CallBase::getArgOperand(unsigned int) const
   38,293,500 ( 0.10%)  ???:bool llvm::DenseMapBase<llvm::DenseMap<llvm::DILocation*, llvm::detail::DenseSetEmpty, llvm::MDNodeInfo<llvm::DILocation>, llvm::detail::DenseSetPair<llvm::DILocation*> >, llvm::DILocation*, llvm::detail::DenseSetEmpty, llvm::MDNodeInfo<llvm::DILocation>, llvm::detail::DenseSetPair<llvm::DILocation*> >::LookupBucketFor<llvm::DILocation*>(llvm::DILocation* const&, llvm::detail::DenseSetPair<llvm::DILocation*> const*&) const
   37,988,231 ( 0.10%)  ./malloc/malloc.c:realloc

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_middle/src/ty/subst.rs
--------------------------------------------------------------------------------
Ir                  

-- line 22 ----------------------------------------
         .           
         .           /// An entity in the Rust type system, which can be one of
         .           /// several kinds (types, lifetimes, and consts).
         .           /// To reduce memory usage, a `GenericArg` is an interned pointer,
         .           /// with the lowest 2 bits being reserved for a tag to
         .           /// indicate the type (`Ty`, `Region`, or `Const`) it points to.
         .           #[derive(Copy, Clone, PartialEq, Eq, Hash)]
         .           pub struct GenericArg<'tcx> {
 2,033,143 ( 0.01%)      ptr: NonZeroUsize,
 4,229,532 ( 0.01%)      marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::Const<'tcx>)>,
         .           }
         .           
         .           const TAG_MASK: usize = 0b11;
         .           const TYPE_TAG: usize = 0b00;
         .           const REGION_TAG: usize = 0b01;
         .           const CONST_TAG: usize = 0b10;
         .           
   258,188 ( 0.00%)  #[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]
         .           pub enum GenericArgKind<'tcx> {
         .               Lifetime(ty::Region<'tcx>),
         .               Type(Ty<'tcx>),
         .               Const(&'tcx ty::Const<'tcx>),
         .           }
         .           
         .           impl<'tcx> GenericArgKind<'tcx> {
    40,447 ( 0.00%)      fn pack(self) -> GenericArg<'tcx> {
    40,447 ( 0.00%)          let (tag, ptr) = match self {
         .                       GenericArgKind::Lifetime(lt) => {
         .                           // Ensure we can use the tag bits.
         .                           assert_eq!(mem::align_of_val(lt) & TAG_MASK, 0);
         .                           (REGION_TAG, lt as *const _ as usize)
         .                       }
         .                       GenericArgKind::Type(ty) => {
         .                           // Ensure we can use the tag bits.
         .                           assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);
-- line 56 ----------------------------------------
-- line 58 ----------------------------------------
         .                       }
         .                       GenericArgKind::Const(ct) => {
         .                           // Ensure we can use the tag bits.
         .                           assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);
         .                           (CONST_TAG, ct as *const _ as usize)
         .                       }
         .                   };
         .           
   199,717 ( 0.00%)          GenericArg { ptr: unsafe { NonZeroUsize::new_unchecked(ptr | tag) }, marker: PhantomData }
    40,447 ( 0.00%)      }
         .           }
         .           
         .           impl<'tcx> fmt::Debug for GenericArg<'tcx> {
         .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         .                   match self.unpack() {
         .                       GenericArgKind::Lifetime(lt) => lt.fmt(f),
         .                       GenericArgKind::Type(ty) => ty.fmt(f),
         .                       GenericArgKind::Const(ct) => ct.fmt(f),
         .                   }
         .               }
         .           }
         .           
         .           impl<'tcx> Ord for GenericArg<'tcx> {
         3 ( 0.00%)      fn cmp(&self, other: &GenericArg<'_>) -> Ordering {
         2 ( 0.00%)          self.unpack().cmp(&other.unpack())
         .               }
         .           }
         .           
         .           impl<'tcx> PartialOrd for GenericArg<'tcx> {
         .               fn partial_cmp(&self, other: &GenericArg<'_>) -> Option<Ordering> {
         .                   Some(self.cmp(&other))
         .               }
         .           }
         .           
         .           impl<'tcx> From<ty::Region<'tcx>> for GenericArg<'tcx> {
    76,540 ( 0.00%)      fn from(r: ty::Region<'tcx>) -> GenericArg<'tcx> {
         .                   GenericArgKind::Lifetime(r).pack()
    76,540 ( 0.00%)      }
         .           }
         .           
         .           impl<'tcx> From<Ty<'tcx>> for GenericArg<'tcx> {
 1,443,993 ( 0.00%)      fn from(ty: Ty<'tcx>) -> GenericArg<'tcx> {
         .                   GenericArgKind::Type(ty).pack()
 1,443,993 ( 0.00%)      }
         .           }
         .           
         .           impl<'tcx> From<&'tcx ty::Const<'tcx>> for GenericArg<'tcx> {
         9 ( 0.00%)      fn from(c: &'tcx ty::Const<'tcx>) -> GenericArg<'tcx> {
         .                   GenericArgKind::Const(c).pack()
         9 ( 0.00%)      }
         .           }
         .           
         .           impl<'tcx> GenericArg<'tcx> {
         .               #[inline]
         .               pub fn unpack(self) -> GenericArgKind<'tcx> {
         .                   let ptr = self.ptr.get();
         .                   unsafe {
26,596,875 ( 0.07%)              match ptr & TAG_MASK {
    75,982 ( 0.00%)                  REGION_TAG => GenericArgKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),
 7,155,173 ( 0.02%)                  TYPE_TAG => GenericArgKind::Type(&*((ptr & !TAG_MASK) as *const _)),
     7,654 ( 0.00%)                  CONST_TAG => GenericArgKind::Const(&*((ptr & !TAG_MASK) as *const _)),
         .                           _ => intrinsics::unreachable(),
         .                       }
         .                   }
         .               }
         .           
         .               /// Unpack the `GenericArg` as a type when it is known certainly to be a type.
         .               /// This is true in cases where `Substs` is used in places where the kinds are known
         .               /// to be limited (e.g. in tuples, where the only parameters are type parameters).
         .               pub fn expect_ty(self) -> Ty<'tcx> {
         .                   match self.unpack() {
         .                       GenericArgKind::Type(ty) => ty,
         .                       _ => bug!("expected a type, but found another kind"),
         .                   }
   449,340 ( 0.00%)      }
         .           
         .               /// Unpack the `GenericArg` as a const when it is known certainly to be a const.
         .               pub fn expect_const(self) -> &'tcx ty::Const<'tcx> {
         .                   match self.unpack() {
         .                       GenericArgKind::Const(c) => c,
         .                       _ => bug!("expected a const, but found another kind"),
         .                   }
         .               }
-- line 140 ----------------------------------------
-- line 175 ----------------------------------------
         .           
         .           impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for GenericArg<'tcx> {
         .               fn encode(&self, e: &mut E) -> Result<(), E::Error> {
         .                   self.unpack().encode(e)
         .               }
         .           }
         .           
         .           impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for GenericArg<'tcx> {
   202,235 ( 0.00%)      fn decode(d: &mut D) -> GenericArg<'tcx> {
   202,235 ( 0.00%)          GenericArgKind::decode(d).pack()
         .               }
         .           }
         .           
         .           /// A substitution mapping generic parameters to new values.
         .           pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;
         .           
         .           pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;
         .           
         .           impl<'a, 'tcx> InternalSubsts<'tcx> {
         .               /// Interpret these substitutions as the substitutions of a closure type.
         .               /// Closure substitutions have a particular structure controlled by the
         .               /// compiler that encodes information like the signature and closure kind;
         .               /// see `ty::ClosureSubsts` struct for more comments.
    56,583 ( 0.00%)      pub fn as_closure(&'a self) -> ClosureSubsts<'a> {
         .                   ClosureSubsts { substs: self }
    56,583 ( 0.00%)      }
         .           
         .               /// Interpret these substitutions as the substitutions of a generator type.
         .               /// Generator substitutions have a particular structure controlled by the
         .               /// compiler that encodes information like the signature and generator kind;
         .               /// see `ty::GeneratorSubsts` struct for more comments.
         .               pub fn as_generator(&'tcx self) -> GeneratorSubsts<'tcx> {
         .                   GeneratorSubsts { substs: self }
         .               }
-- line 208 ----------------------------------------
-- line 211 ----------------------------------------
         .               /// Inline const substitutions have a particular structure controlled by the
         .               /// compiler that encodes information like the inferred type;
         .               /// see `ty::InlineConstSubsts` struct for more comments.
         .               pub fn as_inline_const(&'tcx self) -> InlineConstSubsts<'tcx> {
         .                   InlineConstSubsts { substs: self }
         .               }
         .           
         .               /// Creates an `InternalSubsts` that maps each generic parameter to itself.
     6,500 ( 0.00%)      pub fn identity_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {
     1,548 ( 0.00%)          Self::for_item(tcx, def_id, |param, _| tcx.mk_param_from_def(param))
     5,850 ( 0.00%)      }
         .           
         .               /// Creates an `InternalSubsts` for generic parameter definitions,
         .               /// by calling closures to obtain each kind.
         .               /// The closures get to observe the `InternalSubsts` as they're
         .               /// being built, which can be used to correctly
         .               /// substitute defaults of generic parameters.
   281,118 ( 0.00%)      pub fn for_item<F>(tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>
         .               where
         .                   F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .               {
         .                   let defs = tcx.generics_of(def_id);
         .                   let count = defs.count();
         .                   let mut substs = SmallVec::with_capacity(count);
    96,049 ( 0.00%)          Self::fill_item(&mut substs, tcx, defs, &mut mk_kind);
    62,064 ( 0.00%)          tcx.intern_substs(&substs)
   281,610 ( 0.00%)      }
         .           
         .               pub fn extend_to<F>(&self, tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>
         .               where
         .                   F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .               {
         .                   Self::for_item(tcx, def_id, |param, substs| {
         .                       self.get(param.index as usize).cloned().unwrap_or_else(|| mk_kind(param, substs))
         .                   })
         .               }
         .           
   330,132 ( 0.00%)      pub fn fill_item<F>(
         .                   substs: &mut SmallVec<[GenericArg<'tcx>; 8]>,
         .                   tcx: TyCtxt<'tcx>,
         .                   defs: &ty::Generics,
         .                   mk_kind: &mut F,
         .               ) where
         .                   F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .               {
   134,049 ( 0.00%)          if let Some(def_id) = defs.parent {
         .                       let parent_defs = tcx.generics_of(def_id);
     5,203 ( 0.00%)              Self::fill_item(substs, tcx, parent_defs, mk_kind);
         .                   }
         .                   Self::fill_single(substs, defs, mk_kind)
   263,696 ( 0.00%)      }
         .           
         8 ( 0.00%)      pub fn fill_single<F>(
         .                   substs: &mut SmallVec<[GenericArg<'tcx>; 8]>,
         .                   defs: &ty::Generics,
         .                   mk_kind: &mut F,
         .               ) where
         .                   F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,
         .               {
         .                   substs.reserve(defs.params.len());
         .                   for param in &defs.params {
         2 ( 0.00%)              let kind = mk_kind(param, substs);
   342,969 ( 0.00%)              assert_eq!(param.index as usize, substs.len());
         .                       substs.push(kind);
         .                   }
         8 ( 0.00%)      }
         .           
         .               #[inline]
         .               pub fn types(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {
         .                   self.iter()
         .                       .filter_map(|k| if let GenericArgKind::Type(ty) = k.unpack() { Some(ty) } else { None })
         .               }
         .           
         .               #[inline]
-- line 284 ----------------------------------------
-- line 301 ----------------------------------------
         .               ) -> impl DoubleEndedIterator<Item = GenericArgKind<'tcx>> + 'a {
         .                   self.iter().filter_map(|k| match k.unpack() {
         .                       GenericArgKind::Lifetime(_) => None,
         .                       generic => Some(generic),
         .                   })
         .               }
         .           
         .               #[inline]
        72 ( 0.00%)      pub fn type_at(&self, i: usize) -> Ty<'tcx> {
   547,200 ( 0.00%)          if let GenericArgKind::Type(ty) = self[i].unpack() {
         .                       ty
         .                   } else {
         .                       bug!("expected type for param #{} in {:?}", i, self);
         .                   }
        48 ( 0.00%)      }
         .           
         .               #[inline]
         .               pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {
         .                   if let GenericArgKind::Lifetime(lt) = self[i].unpack() {
         .                       lt
         .                   } else {
         .                       bug!("expected region for param #{} in {:?}", i, self);
         .                   }
-- line 323 ----------------------------------------
-- line 350 ----------------------------------------
         .               /// impl<U> X<U> for U { fn f<V>() {} }
         .               /// ```
         .               ///
         .               /// * If `self` is `[Self, S, T]`: the identity substs of `f` in the trait.
         .               /// * If `source_ancestor` is the def_id of the trait.
         .               /// * If `target_substs` is `[U]`, the substs for the impl.
         .               /// * Then we will return `[U, T]`, the subst for `f` in the impl that
         .               ///   are needed for it to match the trait.
   117,943 ( 0.00%)      pub fn rebase_onto(
         .                   &self,
         .                   tcx: TyCtxt<'tcx>,
         .                   source_ancestor: DefId,
         .                   target_substs: SubstsRef<'tcx>,
         .               ) -> SubstsRef<'tcx> {
         .                   let defs = tcx.generics_of(source_ancestor);
    33,698 ( 0.00%)          tcx.mk_substs(target_substs.iter().chain(self.iter().skip(defs.params.len())))
   134,792 ( 0.00%)      }
         .           
    11,799 ( 0.00%)      pub fn truncate_to(&self, tcx: TyCtxt<'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {
         .                   tcx.mk_substs(self.iter().take(generics.count()))
    23,598 ( 0.00%)      }
         .           }
         .           
         .           impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {
   464,051 ( 0.00%)      fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(
         .                   self,
         .                   folder: &mut F,
         .               ) -> Result<Self, F::Error> {
         .                   // This code is hot enough that it's worth specializing for the most
         .                   // common length lists, to avoid the overhead of `SmallVec` creation.
         .                   // The match arms are in order of frequency. The 1, 2, and 0 cases are
         .                   // typically hit in 90--99.99% of cases. When folding doesn't change
         .                   // the substs, it's faster to reuse the existing substs rather than
         .                   // calling `intern_substs`.
 5,685,346 ( 0.02%)          match self.len() {
         .                       1 => {
   756,237 ( 0.00%)                  let param0 = self[0].try_fold_with(folder)?;
 3,166,796 ( 0.01%)                  if param0 == self[0] { Ok(self) } else { Ok(folder.tcx().intern_substs(&[param0])) }
         .                       }
         .                       2 => {
   557,067 ( 0.00%)                  let param0 = self[0].try_fold_with(folder)?;
 1,340,681 ( 0.00%)                  let param1 = self[1].try_fold_with(folder)?;
 1,238,427 ( 0.00%)                  if param0 == self[0] && param1 == self[1] {
         .                               Ok(self)
         .                           } else {
 1,018,402 ( 0.00%)                      Ok(folder.tcx().intern_substs(&[param0, param1]))
         .                           }
         .                       }
         .                       0 => Ok(self),
         .                       _ => {
         .                           let params: SmallVec<[_; 8]> =
    91,187 ( 0.00%)                      self.iter().map(|k| k.try_fold_with(folder)).collect::<Result<_, _>>()?;
     4,355 ( 0.00%)                  if params[..] == self[..] {
         .                               Ok(self)
         .                           } else {
    51,701 ( 0.00%)                      Ok(folder.tcx().intern_substs(&params))
         .                           }
         .                       }
         .                   }
   558,400 ( 0.00%)      }
         .           
         .               fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {
   822,713 ( 0.00%)          self.iter().try_for_each(|t| t.visit_with(visitor))
         .               }
         .           }
         .           
         .           ///////////////////////////////////////////////////////////////////////////
         .           // Public trait `Subst`
         .           //
         .           // Just call `foo.subst(tcx, substs)` to perform a substitution across
         .           // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when
-- line 420 ----------------------------------------
-- line 435 ----------------------------------------
         .           
         .           impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {
         .               fn subst_spanned(
         .                   self,
         .                   tcx: TyCtxt<'tcx>,
         .                   substs: &[GenericArg<'tcx>],
         .                   span: Option<Span>,
         .               ) -> T {
 5,839,693 ( 0.02%)          let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };
         .                   self.fold_with(&mut folder)
         .               }
         .           }
         .           
         .           ///////////////////////////////////////////////////////////////////////////
         .           // The actual substitution engine itself is a type folder.
         .           
         .           struct SubstFolder<'a, 'tcx> {
-- line 451 ----------------------------------------
-- line 456 ----------------------------------------
         .               span: Option<Span>,
         .           
         .               /// Number of region binders we have passed through while doing the substitution
         .               binders_passed: u32,
         .           }
         .           
         .           impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {
         .               fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {
 1,198,604 ( 0.00%)          self.tcx
         .               }
         .           
         .               fn fold_binder<T: TypeFoldable<'tcx>>(
         .                   &mut self,
         .                   t: ty::Binder<'tcx, T>,
         .               ) -> ty::Binder<'tcx, T> {
   571,852 ( 0.00%)          self.binders_passed += 1;
    99,915 ( 0.00%)          let t = t.super_fold_with(self);
   571,852 ( 0.00%)          self.binders_passed -= 1;
         .                   t
         .               }
         .           
   872,760 ( 0.00%)      fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {
         .                   // Note: This routine only handles regions that are bound on
         .                   // type declarations and other outer declarations, not those
         .                   // bound in *fn types*. Region substitution of the bound
         .                   // regions that appear in a function signature is done using
         .                   // the specialized routine `ty::replace_late_regions()`.
   290,920 ( 0.00%)          match *r {
    52,990 ( 0.00%)              ty::ReEarlyBound(data) => {
    52,990 ( 0.00%)                  let rk = self.substs.get(data.index as usize).map(|k| k.unpack());
         .                           match rk {
    26,495 ( 0.00%)                      Some(GenericArgKind::Lifetime(lt)) => self.shift_region_through_binders(lt),
         .                               _ => {
         .                                   let span = self.span.unwrap_or(DUMMY_SP);
         .                                   let msg = format!(
         .                                       "Region parameter out of range \
         .                                        when substituting in region {} (index={})",
         .                                       data.name, data.index
         .                                   );
         .                                   span_bug!(span, "{}", msg);
         .                               }
         .                           }
         .                       }
         .                       _ => r,
         .                   }
 1,018,220 ( 0.00%)      }
         .           
 6,846,456 ( 0.02%)      fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {
 2,282,152 ( 0.01%)          if !t.needs_subst() {
         .                       return t;
         .                   }
         .           
 3,373,804 ( 0.01%)          match *t.kind() {
 4,996,130 ( 0.01%)              ty::Param(p) => self.ty_for_param(p, t),
 4,126,056 ( 0.01%)              _ => t.super_fold_with(self),
         .                   }
 7,972,380 ( 0.02%)      }
         .           
   673,540 ( 0.00%)      fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {
   192,820 ( 0.00%)          if let ty::ConstKind::Param(p) = c.val {
         .                       self.const_for_param(p, c)
         .                   } else {
   865,296 ( 0.00%)              c.super_fold_with(self)
         .                   }
       608 ( 0.00%)      }
         .           
         .               #[inline]
         .               fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {
         .                   c.super_fold_with(self)
         .               }
         .           }
         .           
         .           impl<'a, 'tcx> SubstFolder<'a, 'tcx> {
         .               fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {
         .                   // Look up the type in the substitutions. It really should be in there.
 1,998,452 ( 0.01%)          let opt_ty = self.substs.get(p.index as usize).map(|k| k.unpack());
         .                   let ty = match opt_ty {
         .                       Some(GenericArgKind::Type(ty)) => ty,
         .                       Some(kind) => {
         .                           let span = self.span.unwrap_or(DUMMY_SP);
         .                           span_bug!(
         .                               span,
         .                               "expected type for `{:?}` ({:?}/{}) but found {:?} \
         .                                when substituting, substs={:?}",
-- line 539 ----------------------------------------
-- line 562 ----------------------------------------
         .               }
         .           
         .               fn const_for_param(
         .                   &self,
         .                   p: ParamConst,
         .                   source_ct: &'tcx ty::Const<'tcx>,
         .               ) -> &'tcx ty::Const<'tcx> {
         .                   // Look up the const in the substitutions. It really should be in there.
       152 ( 0.00%)          let opt_ct = self.substs.get(p.index as usize).map(|k| k.unpack());
         .                   let ct = match opt_ct {
         .                       Some(GenericArgKind::Const(ct)) => ct,
         .                       Some(kind) => {
         .                           let span = self.span.unwrap_or(DUMMY_SP);
         .                           span_bug!(
         .                               span,
         .                               "expected const for `{:?}` ({:?}/{}) but found {:?} \
         .                                when substituting substs={:?}",
-- line 578 ----------------------------------------
-- line 645 ----------------------------------------
         .               fn shift_vars_through_binders<T: TypeFoldable<'tcx>>(&self, val: T) -> T {
         .                   debug!(
         .                       "shift_vars(val={:?}, binders_passed={:?}, has_escaping_bound_vars={:?})",
         .                       val,
         .                       self.binders_passed,
         .                       val.has_escaping_bound_vars()
         .                   );
         .           
 3,288,986 ( 0.01%)          if self.binders_passed == 0 || !val.has_escaping_bound_vars() {
         .                       return val;
         .                   }
         .           
         .                   let result = ty::fold::shift_vars(self.tcx(), val, self.binders_passed);
         .                   debug!("shift_vars: shifted result = {:?}", result);
         .           
         .                   result
         .               }
         .           
         .               fn shift_region_through_binders(&self, region: ty::Region<'tcx>) -> ty::Region<'tcx> {
    62,844 ( 0.00%)          if self.binders_passed == 0 || !region.has_escaping_bound_vars() {
         .                       return region;
         .                   }
         .                   ty::fold::shift_region(self.tcx, region, self.binders_passed)
         .               }
         .           }
         .           
         .           /// Stores the user-given substs to reach some fully qualified path
         .           /// (e.g., `<T>::Item` or `<T as Trait>::Item`).
         .           #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
     2,694 ( 0.00%)  #[derive(HashStable, TypeFoldable, Lift)]
         .           pub struct UserSubsts<'tcx> {
         .               /// The substitutions for the item as given by the user.
         .               pub substs: SubstsRef<'tcx>,
         .           
         .               /// The self type, in the case of a `<T>::Item` path (when applied
         .               /// to an inherent impl). See `UserSelfTy` below.
       273 ( 0.00%)      pub user_self_ty: Option<UserSelfTy<'tcx>>,
         .           }
         .           
         .           /// Specifies the user-given self type. In the case of a path that
         .           /// refers to a member in an inherent impl, this self type is
         .           /// sometimes needed to constrain the type parameters on the impl. For
         .           /// example, in this code:
         .           ///
         .           /// ```
-- line 689 ----------------------------------------
-- line 696 ----------------------------------------
         .           /// self type `Foo<u32>`. Then we can instantiate the parameters of
         .           /// the impl (with the substs from `UserSubsts`) and apply those to
         .           /// the self type, giving `Foo<?A>`. Finally, we unify that with
         .           /// the self type here, which contains `?A` to be `&'static u32`
         .           #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]
         .           #[derive(HashStable, TypeFoldable, Lift)]
         .           pub struct UserSelfTy<'tcx> {
         .               pub impl_def_id: DefId,
       156 ( 0.00%)      pub self_ty: Ty<'tcx>,
         .           }

11,168,549 ( 0.03%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_middle/src/ty/subst.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs
--------------------------------------------------------------------------------
Ir                  

-- line 141 ----------------------------------------
         .               /// ```
         .               /// let a = [1, 2, 3];
         .               /// assert!(!a.is_empty());
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_stable(feature = "const_slice_is_empty", since = "1.39.0")]
         .               #[inline]
         .               pub const fn is_empty(&self) -> bool {
 2,521,840 ( 0.01%)          self.len() == 0
         .               }
         .           
         .               /// Returns the first element of the slice, or `None` if it is empty.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let v = [10, 40, 30];
-- line 157 ----------------------------------------
-- line 159 ----------------------------------------
         .               ///
         .               /// let w: &[i32] = &[];
         .               /// assert_eq!(None, w.first());
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
         .               #[inline]
         .               pub const fn first(&self) -> Option<&T> {
     1,708 ( 0.00%)          if let [first, ..] = self { Some(first) } else { None }
         .               }
         .           
         .               /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let x = &mut [0, 1, 2];
-- line 175 ----------------------------------------
-- line 178 ----------------------------------------
         .               ///     *first = 5;
         .               /// }
         .               /// assert_eq!(x, &[5, 1, 2]);
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_unstable(feature = "const_slice_first_last", issue = "83570")]
         .               #[inline]
         .               pub const fn first_mut(&mut self) -> Option<&mut T> {
       772 ( 0.00%)          if let [first, ..] = self { Some(first) } else { None }
         .               }
         .           
         .               /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let x = &[0, 1, 2];
-- line 194 ----------------------------------------
-- line 237 ----------------------------------------
         .               ///     assert_eq!(last, &2);
         .               ///     assert_eq!(elements, &[0, 1]);
         .               /// }
         .               /// ```
         .               #[stable(feature = "slice_splits", since = "1.5.0")]
         .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
         .               #[inline]
         .               pub const fn split_last(&self) -> Option<(&T, &[T])> {
    26,587 ( 0.00%)          if let [init @ .., last] = self { Some((last, init)) } else { None }
         .               }
         .           
         .               /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let x = &mut [0, 1, 2];
-- line 253 ----------------------------------------
-- line 276 ----------------------------------------
         .               ///
         .               /// let w: &[i32] = &[];
         .               /// assert_eq!(None, w.last());
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
         .               #[inline]
         .               pub const fn last(&self) -> Option<&T> {
   427,384 ( 0.00%)          if let [.., last] = self { Some(last) } else { None }
         .               }
         .           
         .               /// Returns a mutable pointer to the last item in the slice.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let x = &mut [0, 1, 2];
-- line 292 ----------------------------------------
-- line 295 ----------------------------------------
         .               ///     *last = 10;
         .               /// }
         .               /// assert_eq!(x, &[0, 1, 10]);
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_unstable(feature = "const_slice_first_last", issue = "83570")]
         .               #[inline]
         .               pub const fn last_mut(&mut self) -> Option<&mut T> {
 2,574,229 ( 0.01%)          if let [.., last] = self { Some(last) } else { None }
         .               }
         .           
         .               /// Returns a reference to an element or subslice depending on the type of
         .               /// index.
         .               ///
         .               /// - If given a position, returns a reference to the element at that
         .               ///   position or `None` if out of bounds.
         .               /// - If given a range, returns the subslice corresponding to that range,
-- line 311 ----------------------------------------
-- line 448 ----------------------------------------
         .               /// }
         .               /// ```
         .               ///
         .               /// [`as_mut_ptr`]: slice::as_mut_ptr
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_stable(feature = "const_slice_as_ptr", since = "1.32.0")]
         .               #[inline]
         .               pub const fn as_ptr(&self) -> *const T {
 3,897,055 ( 0.01%)          self as *const [T] as *const T
         .               }
         .           
         .               /// Returns an unsafe mutable pointer to the slice's buffer.
         .               ///
         .               /// The caller must ensure that the slice outlives the pointer this
         .               /// function returns, or else it will end up pointing to garbage.
         .               ///
         .               /// Modifying the container referenced by this slice may cause its buffer
-- line 464 ----------------------------------------
-- line 476 ----------------------------------------
         .               ///     }
         .               /// }
         .               /// assert_eq!(x, &[3, 4, 6]);
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_unstable(feature = "const_ptr_offset", issue = "71499")]
         .               #[inline]
         .               pub const fn as_mut_ptr(&mut self) -> *mut T {
        20 ( 0.00%)          self as *mut [T] as *mut T
         .               }
         .           
         .               /// Returns the two raw pointers spanning the slice.
         .               ///
         .               /// The returned range is half-open, which means that the end pointer
         .               /// points *one past* the last element of the slice. This way, an empty
         .               /// slice is represented by two equal pointers, and the difference between
         .               /// the two pointers represents the size of the slice.
-- line 492 ----------------------------------------
-- line 582 ----------------------------------------
         .               /// v.swap(2, 4);
         .               /// assert!(v == ["a", "b", "e", "d", "c"]);
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[rustc_const_unstable(feature = "const_swap", issue = "83163")]
         .               #[inline]
         .               #[track_caller]
         .               pub const fn swap(&mut self, a: usize, b: usize) {
    73,110 ( 0.00%)          let _ = &self[a];
   130,092 ( 0.00%)          let _ = &self[b];
         .           
         .                   // SAFETY: we just checked that both `a` and `b` are in bounds
         .                   unsafe { self.swap_unchecked(a, b) }
         .               }
         .           
         .               /// Swaps two elements in the slice, without doing bounds checking.
         .               ///
         .               /// For a safe alternative see [`swap`].
-- line 599 ----------------------------------------
-- line 677 ----------------------------------------
         .           
         .                       // Because this function is first compiled in isolation,
         .                       // this check tells LLVM that the indexing below is
         .                       // in-bounds.  Then after inlining -- once the actual
         .                       // lengths of the slices are known -- it's removed.
         .                       let (a, b) = (&mut a[..n], &mut b[..n]);
         .           
         .                       for i in 0..n {
    51,323 ( 0.00%)                  mem::swap(&mut a[i], &mut b[n - 1 - i]);
         .                       }
         .                   }
         .               }
         .           
         .               /// Returns an iterator over the slice.
         .               ///
         .               /// # Examples
         .               ///
-- line 693 ----------------------------------------
-- line 1499 ----------------------------------------
         .               ///     assert_eq!(left, [1, 2, 3, 4, 5, 6]);
         .               ///     assert_eq!(right, []);
         .               /// }
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[inline]
         .               #[track_caller]
         .               pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {
       342 ( 0.00%)          assert!(mid <= self.len());
         .                   // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
         .                   // fulfills the requirements of `from_raw_parts_mut`.
         .                   unsafe { self.split_at_unchecked(mid) }
         .               }
         .           
         .               /// Divides one mutable slice into two at an index.
         .               ///
         .               /// The first will contain all indices from `[0, mid)` (excluding
-- line 1515 ----------------------------------------
-- line 1530 ----------------------------------------
         .               /// left[1] = 2;
         .               /// right[1] = 4;
         .               /// assert_eq!(v, [1, 2, 3, 4, 5, 6]);
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[inline]
         .               #[track_caller]
         .               pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
    79,326 ( 0.00%)          assert!(mid <= self.len());
         .                   // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
         .                   // fulfills the requirements of `from_raw_parts_mut`.
         .                   unsafe { self.split_at_mut_unchecked(mid) }
         .               }
         .           
         .               /// Divides one slice into two at an index, without doing bounds checking.
         .               ///
         .               /// The first will contain all indices from `[0, mid)` (excluding
-- line 1546 ----------------------------------------
-- line 1628 ----------------------------------------
         .               pub unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {
         .                   let len = self.len();
         .                   let ptr = self.as_mut_ptr();
         .           
         .                   // SAFETY: Caller has to check that `0 <= mid <= self.len()`.
         .                   //
         .                   // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference
         .                   // is fine.
     4,397 ( 0.00%)          unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }
         .               }
         .           
         .               /// Divides one slice into an array and a remainder slice at an index.
         .               ///
         .               /// The array will contain all indices from `[0, N)` (excluding
         .               /// the index `N` itself) and the slice will contain all
         .               /// indices from `[N, len)` (excluding the index `len` itself).
         .               ///
-- line 1644 ----------------------------------------
-- line 2113 ----------------------------------------
         .               /// assert!(!v.iter().any(|e| e == "hi"));
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               #[inline]
         .               pub fn contains(&self, x: &T) -> bool
         .               where
         .                   T: PartialEq,
         .               {
     1,898 ( 0.00%)          cmp::SliceContains::slice_contains(x, self)
         .               }
         .           
         .               /// Returns `true` if `needle` is a prefix of the slice.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let v = [10, 40, 30];
-- line 2129 ----------------------------------------
-- line 2142 ----------------------------------------
         .               /// assert!(v.starts_with(&[]));
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               pub fn starts_with(&self, needle: &[T]) -> bool
         .               where
         .                   T: PartialEq,
         .               {
         .                   let n = needle.len();
    19,818 ( 0.00%)          self.len() >= n && needle == &self[..n]
         .               }
         .           
         .               /// Returns `true` if `needle` is a suffix of the slice.
         .               ///
         .               /// # Examples
         .               ///
         .               /// ```
         .               /// let v = [10, 40, 30];
-- line 2158 ----------------------------------------
-- line 2171 ----------------------------------------
         .               /// assert!(v.ends_with(&[]));
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               pub fn ends_with(&self, needle: &[T]) -> bool
         .               where
         .                   T: PartialEq,
         .               {
         .                   let (m, n) = (self.len(), needle.len());
   354,250 ( 0.00%)          m >= n && needle == &self[m - n..]
         .               }
         .           
         .               /// Returns a subslice with the prefix removed.
         .               ///
         .               /// If the slice starts with `prefix`, returns the subslice after the prefix, wrapped in `Some`.
         .               /// If `prefix` is empty, simply returns the original slice.
         .               ///
         .               /// If the slice does not start with `prefix`, returns `None`.
-- line 2187 ----------------------------------------
-- line 2293 ----------------------------------------
         .               /// s.insert(idx, num);
         .               /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);
         .               /// ```
         .               #[stable(feature = "rust1", since = "1.0.0")]
         .               pub fn binary_search(&self, x: &T) -> Result<usize, usize>
         .               where
         .                   T: Ord,
         .               {
         3 ( 0.00%)          self.binary_search_by(|p| p.cmp(x))
         .               }
         .           
         .               /// Binary searches this sorted slice with a comparator function.
         .               ///
         .               /// The comparator function should implement an order consistent
         .               /// with the sort order of the underlying slice, returning an
         .               /// order code that indicates whether its argument is `Less`,
         .               /// `Equal` or `Greater` the desired target.
-- line 2309 ----------------------------------------
-- line 2345 ----------------------------------------
         .               #[inline]
         .               pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>
         .               where
         .                   F: FnMut(&'a T) -> Ordering,
         .               {
         .                   let mut size = self.len();
         .                   let mut left = 0;
         .                   let mut right = size;
27,874,764 ( 0.07%)          while left < right {
47,650,088 ( 0.13%)              let mid = left + size / 2;
         .           
         .                       // SAFETY: the call is made safe by the following invariants:
         .                       // - `mid >= 0`
         .                       // - `mid < size`: `mid` is limited by `[left; right)` bound.
 4,265,811 ( 0.01%)              let cmp = f(unsafe { self.get_unchecked(mid) });
         .           
         .                       // The reason why we use if/else control flow rather than match
         .                       // is because match reorders comparison operations, which is perf sensitive.
         .                       // This is x86 asm for u8: https://rust.godbolt.org/z/8Y8Pra.
12,170,894 ( 0.03%)              if cmp == Less {
28,356,775 ( 0.08%)                  left = mid + 1;
 5,987,024 ( 0.02%)              } else if cmp == Greater {
         .                           right = mid;
         .                       } else {
         .                           // SAFETY: same as the `get_unchecked` above
         .                           unsafe { crate::intrinsics::assume(mid < self.len()) };
         .                           return Ok(mid);
         .                       }
         .           
36,371,905 ( 0.10%)              size = right - left;
         .                   }
         .                   Err(left)
         .               }
         .           
         .               /// Binary searches this sorted slice with a key extraction function.
         .               ///
         .               /// Assumes that the slice is sorted by the key, for instance with
         .               /// [`sort_by_key`] using the same key extraction function.
-- line 2382 ----------------------------------------
-- line 3203 ----------------------------------------
         .                   #[track_caller]
         .                   fn len_mismatch_fail(dst_len: usize, src_len: usize) -> ! {
         .                       panic!(
         .                           "source slice length ({}) does not match destination slice length ({})",
         .                           src_len, dst_len,
         .                       );
         .                   }
         .           
   192,956 ( 0.00%)          if self.len() != src.len() {
         .                       len_mismatch_fail(self.len(), src.len());
         .                   }
         .           
         .                   // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was
         .                   // checked to have the same length. The slices cannot overlap because
         .                   // mutable references are exclusive.
         .                   unsafe {
         .                       ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());
-- line 3219 ----------------------------------------
-- line 3380 ----------------------------------------
         .                       }
         .                       a << k
         .                   }
         .                   let gcd: usize = gcd(mem::size_of::<T>(), mem::size_of::<U>());
         .                   let ts: usize = mem::size_of::<U>() / gcd;
         .                   let us: usize = mem::size_of::<T>() / gcd;
         .           
         .                   // Armed with this knowledge, we can find how many `U`s we can fit!
         1 ( 0.00%)          let us_len = self.len() / ts * us;
         .                   // And how many `T`s will be in the trailing slice!
    20,434 ( 0.00%)          let ts_len = self.len() % ts;
         .                   (us_len, ts_len)
         .               }
         .           
         .               /// Transmute the slice to a slice of another type, ensuring alignment of the types is
         .               /// maintained.
         .               ///
         .               /// This method splits the slice into three distinct slices: prefix, correctly aligned middle
         .               /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest
-- line 3398 ----------------------------------------
-- line 3429 ----------------------------------------
         .                       return (self, &[], &[]);
         .                   }
         .           
         .                   // First, find at what point do we split between the first and 2nd slice. Easy with
         .                   // ptr.align_offset.
         .                   let ptr = self.as_ptr();
         .                   // SAFETY: See the `align_to_mut` method for the detailed safety comment.
         .                   let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };
    20,434 ( 0.00%)          if offset > self.len() {
         .                       (self, &[], &[])
         .                   } else {
         .                       let (left, rest) = self.split_at(offset);
         .                       let (us_len, ts_len) = rest.align_to_offsets::<U>();
         .                       // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,
         .                       // since the caller guarantees that we can transmute `T` to `U` safely.
         .                       unsafe {
         .                           (
         .                               left,
         .                               from_raw_parts(rest.as_ptr() as *const U, us_len),
    20,435 ( 0.00%)                      from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),
         .                           )
         .                       }
         .                   }
         .               }
         .           
         .               /// Transmute the slice to a slice of another type, ensuring alignment of the types is
         .               /// maintained.
         .               ///
-- line 3456 ----------------------------------------

19,989,366 ( 0.05%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/library/core/src/slice/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs
--------------------------------------------------------------------------------
Ir                   

-- line 111 ----------------------------------------
          .           const EMPTY: u8 = 0b1111_1111;
          .           
          .           /// Control byte value for a deleted bucket.
          .           const DELETED: u8 = 0b1000_0000;
          .           
          .           /// Checks whether a control byte represents a full bucket (top bit is clear).
          .           #[inline]
          .           fn is_full(ctrl: u8) -> bool {
  6,680,467 ( 0.02%)      ctrl & 0x80 == 0
          .           }
          .           
          .           /// Checks whether a control byte represents a special value (top bit is set).
          .           #[inline]
          .           fn is_special(ctrl: u8) -> bool {
          .               ctrl & 0x80 != 0
          .           }
          .           
          .           /// Checks whether a special control value is EMPTY (just check 1 bit).
          .           #[inline]
          .           fn special_is_empty(ctrl: u8) -> bool {
          .               debug_assert!(is_special(ctrl));
    364,381 ( 0.00%)      ctrl & 0x01 != 0
          .           }
          .           
          .           /// Primary hash function, used to select the initial bucket to probe from.
          .           #[inline]
          .           #[allow(clippy::cast_possible_truncation)]
          .           fn h1(hash: u64) -> usize {
          .               // On 32-bit platforms we simply ignore the higher hash bits.
          .               hash as usize
-- line 140 ----------------------------------------
-- line 143 ----------------------------------------
          .           /// Secondary hash function, saved in the low 7 bits of the control byte.
          .           #[inline]
          .           #[allow(clippy::cast_possible_truncation)]
          .           fn h2(hash: u64) -> u8 {
          .               // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
          .               // value, some hash functions (such as FxHash) produce a usize result
          .               // instead, which means that the top 32 bits are 0 on 32-bit platforms.
          .               let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
139,539,714 ( 0.37%)      let top7 = hash >> (hash_len * 8 - 7);
          .               (top7 & 0x7f) as u8 // truncation
          .           }
          .           
          .           /// Probe sequence based on triangular numbers, which is guaranteed (since our
          .           /// table size is a power of two) to visit every group of elements exactly once.
          .           ///
          .           /// A triangular probe has us jump by 1 more group every time. So first we
          .           /// jump by 1 group (meaning we just continue our linear scan), then 2 groups
-- line 159 ----------------------------------------
-- line 170 ----------------------------------------
          .               #[inline]
          .               fn move_next(&mut self, bucket_mask: usize) {
          .                   // We should have found an empty bucket by now and ended the probe.
          .                   debug_assert!(
          .                       self.stride <= bucket_mask,
          .                       "Went past end of probe sequence"
          .                   );
          .           
  1,544,720 ( 0.00%)          self.stride += Group::WIDTH;
  1,544,720 ( 0.00%)          self.pos += self.stride;
  1,261,966 ( 0.00%)          self.pos &= bucket_mask;
          .               }
          .           }
          .           
          .           /// Returns the number of buckets needed to hold the given number of items,
          .           /// taking the maximum load factor into account.
          .           ///
          .           /// Returns `None` if an overflow occurs.
          .           // Workaround for emscripten bug emscripten-core/emscripten-fastcomp#258
          .           #[cfg_attr(target_os = "emscripten", inline(never))]
          .           #[cfg_attr(not(target_os = "emscripten"), inline)]
          .           fn capacity_to_buckets(cap: usize) -> Option<usize> {
          .               debug_assert_ne!(cap, 0);
          .           
          .               // For small tables we require at least 1 empty bucket so that lookups are
          .               // guaranteed to terminate if an element doesn't exist in the table.
    344,220 ( 0.00%)      if cap < 8 {
          .                   // We don't bother with a table size of 2 buckets since that can only
          .                   // hold a single element. Instead we skip directly to a 4 bucket table
          .                   // which can hold 3 elements.
    494,625 ( 0.00%)          return Some(if cap < 4 { 4 } else { 8 });
          .               }
          .           
          .               // Otherwise require 1/8 buckets to be empty (87.5% load)
          .               //
          .               // Be careful when modifying this, calculate_layout relies on the
          .               // overflow check here.
    439,110 ( 0.00%)      let adjusted_cap = cap.checked_mul(8)? / 7;
          .           
          .               // Any overflows will have been caught by the checked_mul. Also, any
          .               // rounding errors from the division above will be cleaned up by
          .               // next_power_of_two (which can't overflow because of the previous division).
          .               Some(adjusted_cap.next_power_of_two())
          .           }
          .           
          .           /// Returns the maximum effective capacity for the given bucket mask, taking
          .           /// the maximum load factor into account.
          .           #[inline]
          .           fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
  1,009,708 ( 0.00%)      if bucket_mask < 8 {
          .                   // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
          .                   // Keep in mind that the bucket mask is one less than the bucket count.
          .                   bucket_mask
          .               } else {
          .                   // For larger tables we reserve 12.5% of the slots as empty.
    437,602 ( 0.00%)          ((bucket_mask + 1) / 8) * 7
          .               }
          .           }
          .           
          .           /// Helper which allows the max calculation for ctrl_align to be statically computed for each T
          .           /// while keeping the rest of `calculate_layout_for` independent of `T`
          .           #[derive(Copy, Clone)]
          .           struct TableLayout {
          .               size: usize,
-- line 233 ----------------------------------------
-- line 246 ----------------------------------------
          .           
          .               #[inline]
          .               fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
          .                   debug_assert!(buckets.is_power_of_two());
          .           
          .                   let TableLayout { size, ctrl_align } = self;
          .                   // Manual layout calculation since Layout methods are not yet stable.
          .                   let ctrl_offset =
    554,858 ( 0.00%)              size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
    863,034 ( 0.00%)          let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
          .           
          .                   Some((
          .                       unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
          .                       ctrl_offset,
          .                   ))
          .               }
          .           }
          .           
-- line 263 ----------------------------------------
-- line 337 ----------------------------------------
          .                   }
          .               }
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub unsafe fn drop(&self) {
          .                   self.as_ptr().drop_in_place();
          .               }
          .               #[inline]
          .               pub unsafe fn read(&self) -> T {
        706 ( 0.00%)          self.as_ptr().read()
          .               }
          .               #[inline]
          .               pub unsafe fn write(&self, val: T) {
          .                   self.as_ptr().write(val);
          .               }
          .               #[inline]
          .               pub unsafe fn as_ref<'a>(&self) -> &'a T {
          .                   &*self.as_ptr()
-- line 353 ----------------------------------------
-- line 422 ----------------------------------------
          .               /// Creates a new empty hash table without allocating any memory, using the
          .               /// given allocator.
          .               ///
          .               /// In effect this returns a table with exactly 1 bucket. However we can
          .               /// leave the data pointer dangling since that bucket is never written to
          .               /// due to our load factor forcing us to always have at least 1 free bucket.
          .               #[inline]
          .               pub fn new_in(alloc: A) -> Self {
    271,164 ( 0.00%)          Self {
          .                       table: RawTableInner::new_in(alloc),
          .                       marker: PhantomData,
          .                   }
          .               }
          .           
          .               /// Allocates a new hash table with the given number of buckets.
          .               ///
          .               /// The control bytes are left uninitialized.
-- line 438 ----------------------------------------
-- line 440 ----------------------------------------
          .               unsafe fn new_uninitialized(
          .                   alloc: A,
          .                   buckets: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
          .                   debug_assert!(buckets.is_power_of_two());
          .           
          .                   Ok(Self {
        180 ( 0.00%)              table: RawTableInner::new_uninitialized(
          .                           alloc,
          .                           TableLayout::new::<T>(),
          .                           buckets,
          .                           fallibility,
          .                       )?,
          .                       marker: PhantomData,
          .                   })
          .               }
-- line 456 ----------------------------------------
-- line 458 ----------------------------------------
          .               /// Attempts to allocate a new hash table with at least enough capacity
          .               /// for inserting the given number of elements without reallocating.
          .               fn fallible_with_capacity(
          .                   alloc: A,
          .                   capacity: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
          .                   Ok(Self {
     10,565 ( 0.00%)              table: RawTableInner::fallible_with_capacity(
          .                           alloc,
          .                           TableLayout::new::<T>(),
          .                           capacity,
          .                           fallibility,
          .                       )?,
          .                       marker: PhantomData,
          .                   })
          .               }
-- line 474 ----------------------------------------
-- line 527 ----------------------------------------
          .                   debug_assert_ne!(self.table.bucket_mask, 0);
          .                   debug_assert!(index < self.buckets());
          .                   Bucket::from_base_index(self.data_end(), index)
          .               }
          .           
          .               /// Erases an element from the table without dropping it.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[deprecated(since = "0.8.1", note = "use erase or remove instead")]
     58,493 ( 0.00%)      pub unsafe fn erase_no_drop(&mut self, item: &Bucket<T>) {
     58,493 ( 0.00%)          let index = self.bucket_index(item);
          .                   self.table.erase(index);
    116,986 ( 0.00%)      }
          .           
          .               /// Erases an element from the table, dropping it in place.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[allow(clippy::needless_pass_by_value)]
          .               #[allow(deprecated)]
          .               pub unsafe fn erase(&mut self, item: Bucket<T>) {
          .                   // Erase the element from the table first since drop might panic.
     17,380 ( 0.00%)          self.erase_no_drop(&item);
          .                   item.drop();
          .               }
          .           
          .               /// Finds and erases an element from the table, dropping it in place.
          .               /// Returns true if an element was found.
          .               #[cfg(feature = "raw")]
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn erase_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> bool {
-- line 554 ----------------------------------------
-- line 563 ----------------------------------------
          .                   }
          .               }
          .           
          .               /// Removes an element from the table, returning it.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[allow(clippy::needless_pass_by_value)]
          .               #[allow(deprecated)]
          .               pub unsafe fn remove(&mut self, item: Bucket<T>) -> T {
     99,606 ( 0.00%)          self.erase_no_drop(&item);
      6,567 ( 0.00%)          item.read()
          .               }
          .           
          .               /// Finds and removes an element from the table, returning it.
          .               #[cfg_attr(feature = "inline-more", inline)]
  1,730,758 ( 0.00%)      pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T> {
          .                   // Avoid `Option::map` because it bloats LLVM IR.
      7,770 ( 0.00%)          match self.find(hash, eq) {
      6,262 ( 0.00%)              Some(bucket) => Some(unsafe { self.remove(bucket) }),
    189,737 ( 0.00%)              None => None,
          .                   }
  2,170,165 ( 0.01%)      }
          .           
          .               /// Marks all table buckets as empty without dropping their contents.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn clear_no_drop(&mut self) {
          .                   self.table.clear_no_drop();
          .               }
          .           
          .               /// Removes all elements from the table without freeing the backing memory.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn clear(&mut self) {
          .                   // Ensure that the table is reset even if one of the drops panic
          .                   let mut self_ = guard(self, |self_| self_.clear_no_drop());
          .                   unsafe {
          1 ( 0.00%)              self_.drop_elements();
          .                   }
          .               }
          .           
          7 ( 0.00%)      unsafe fn drop_elements(&mut self) {
     63,546 ( 0.00%)          if mem::needs_drop::<T>() && !self.is_empty() {
          .                       for item in self.iter() {
          .                           item.drop();
          .                       }
          .                   }
          8 ( 0.00%)      }
          .           
          .               /// Shrinks the table to fit `max(self.len(), min_size)` elements.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn shrink_to(&mut self, min_size: usize, hasher: impl Fn(&T) -> u64) {
          .                   // Calculate the minimal number of elements that we need to reserve
          .                   // space for.
          .                   let min_size = usize::max(self.table.items, min_size);
          .                   if min_size == 0 {
-- line 615 ----------------------------------------
-- line 642 ----------------------------------------
          .                       }
          .                   }
          .               }
          .           
          .               /// Ensures that at least `additional` items can be inserted into the table
          .               /// without reallocation.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
    994,331 ( 0.00%)          if additional > self.table.growth_left {
          .                       // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
    578,709 ( 0.00%)              if self
          .                           .reserve_rehash(additional, hasher, Fallibility::Infallible)
          .                           .is_err()
          .                       {
          .                           unsafe { hint::unreachable_unchecked() }
          .                       }
          .                   }
          .               }
          .           
-- line 660 ----------------------------------------
-- line 671 ----------------------------------------
          .                   } else {
          .                       Ok(())
          .                   }
          .               }
          .           
          .               /// Out-of-line slow path for `reserve` and `try_reserve`.
          .               #[cold]
          .               #[inline(never)]
  1,400,777 ( 0.00%)      fn reserve_rehash(
          .                   &mut self,
          .                   additional: usize,
          .                   hasher: impl Fn(&T) -> u64,
          .                   fallibility: Fallibility,
          .               ) -> Result<(), TryReserveError> {
          .                   unsafe {
          .                       self.table.reserve_rehash_inner(
          .                           additional,
-- line 687 ----------------------------------------
-- line 690 ----------------------------------------
          .                           TableLayout::new::<T>(),
          .                           if mem::needs_drop::<T>() {
          .                               Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
          .                           } else {
          .                               None
          .                           },
          .                       )
          .                   }
    843,944 ( 0.00%)      }
          .           
          .               /// Allocates a new table of a different size and moves the contents of the
          .               /// current table into it.
          .               fn resize(
          .                   &mut self,
          .                   capacity: usize,
          .                   hasher: impl Fn(&T) -> u64,
          .                   fallibility: Fallibility,
-- line 706 ----------------------------------------
-- line 714 ----------------------------------------
          .                       )
          .                   }
          .               }
          .           
          .               /// Inserts a new element into the table, and returns its raw bucket.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg_attr(feature = "inline-more", inline)]
 10,288,944 ( 0.03%)      pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
          .                   unsafe {
          .                       let mut index = self.table.find_insert_slot(hash);
          .           
          .                       // We can avoid growing the table once we have reached our load
          .                       // factor if we are replacing a tombstone. This works since the
          .                       // number of EMPTY slots does not change in this case.
     26,911 ( 0.00%)              let old_ctrl = *self.table.ctrl(index);
  7,004,362 ( 0.02%)              if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
          .                           self.reserve(1, hasher);
          .                           index = self.table.find_insert_slot(hash);
          .                       }
          .           
          .                       self.table.record_item_insert_at(index, old_ctrl, hash);
          .           
          .                       let bucket = self.bucket(index);
          2 ( 0.00%)              bucket.write(value);
          .                       bucket
          .                   }
  7,654,251 ( 0.02%)      }
          .           
          .               /// Attempts to insert a new element without growing the table and return its raw bucket.
          .               ///
          .               /// Returns an `Err` containing the given element if inserting it would require growing the
          .               /// table.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg(feature = "raw")]
-- line 749 ----------------------------------------
-- line 760 ----------------------------------------
          .                       }
          .                   }
          .               }
          .           
          .               /// Inserts a new element into the table, and returns a mutable reference to it.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg_attr(feature = "inline-more", inline)]
  2,034,312 ( 0.01%)      pub fn insert_entry(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> &mut T {
      6,129 ( 0.00%)          unsafe { self.insert(hash, value, hasher).as_mut() }
  1,525,734 ( 0.00%)      }
          .           
          .               /// Inserts a new element into the table, without growing the table.
          .               ///
          .               /// There must be enough space in the table to insert the new element.
          .               ///
          .               /// This does not check if the given element already exists in the table.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               #[cfg(any(feature = "raw", feature = "rustc-internal-api"))]
      8,535 ( 0.00%)      pub unsafe fn insert_no_grow(&mut self, hash: u64, value: T) -> Bucket<T> {
  1,043,890 ( 0.00%)          let (index, old_ctrl) = self.table.prepare_insert_slot(hash);
     54,521 ( 0.00%)          let bucket = self.table.bucket(index);
          .           
          .                   // If we are replacing a DELETED entry then we don't need to update
          .                   // the load counter.
  2,130,171 ( 0.01%)          self.table.growth_left -= special_is_empty(old_ctrl) as usize;
          .           
          .                   bucket.write(value);
  1,649,136 ( 0.00%)          self.table.items += 1;
          .                   bucket
     16,842 ( 0.00%)      }
          .           
          .               /// Temporary removes a bucket, applying the given function to the removed
          .               /// element and optionally put back the returned value in the same bucket.
          .               ///
          .               /// Returns `true` if the bucket still contains an element
          .               ///
          .               /// This does not check if the given bucket is actually occupied.
          .               #[cfg_attr(feature = "inline-more", inline)]
-- line 798 ----------------------------------------
-- line 813 ----------------------------------------
          .                       true
          .                   } else {
          .                       false
          .                   }
          .               }
          .           
          .               /// Searches for an element in the table.
          .               #[inline]
    512,069 ( 0.00%)      pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
     59,638 ( 0.00%)          let result = self.table.find_inner(hash, &mut |index| unsafe {
    196,813 ( 0.00%)              eq(self.bucket(index).as_ref())
     12,029 ( 0.00%)          });
          .           
          .                   // Avoid `Option::map` because it bloats LLVM IR.
          .                   match result {
      7,075 ( 0.00%)              Some(index) => Some(unsafe { self.bucket(index) }),
          .                       None => None,
          .                   }
    585,120 ( 0.00%)      }
          .           
          .               /// Gets a reference to an element in the table.
          .               #[inline]
          .               pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
          .                   // Avoid `Option::map` because it bloats LLVM IR.
    304,262 ( 0.00%)          match self.find(hash, eq) {
          .                       Some(bucket) => Some(unsafe { bucket.as_ref() }),
          .                       None => None,
          .                   }
          .               }
          .           
          .               /// Gets a mutable reference to an element in the table.
          .               #[inline]
     57,414 ( 0.00%)      pub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {
          .                   // Avoid `Option::map` because it bloats LLVM IR.
    277,948 ( 0.00%)          match self.find(hash, eq) {
          .                       Some(bucket) => Some(unsafe { bucket.as_mut() }),
          .                       None => None,
          .                   }
     65,616 ( 0.00%)      }
          .           
          .               /// Attempts to get mutable references to `N` entries in the table at once.
          .               ///
          .               /// Returns an array of length `N` with the results of each query.
          .               ///
          .               /// At most one mutable reference will be returned to any entry. `None` will be returned if any
          .               /// of the hashes are duplicates. `None` will be returned if the hash is not found.
          .               ///
-- line 859 ----------------------------------------
-- line 920 ----------------------------------------
          .               #[inline]
          .               pub fn len(&self) -> usize {
          .                   self.table.items
          .               }
          .           
          .               /// Returns `true` if the table contains no elements.
          .               #[inline]
          .               pub fn is_empty(&self) -> bool {
  2,707,749 ( 0.01%)          self.len() == 0
          .               }
          .           
          .               /// Returns the number of buckets in the table.
          .               #[inline]
          .               pub fn buckets(&self) -> usize {
          .                   self.table.bucket_mask + 1
          .               }
          .           
-- line 936 ----------------------------------------
-- line 938 ----------------------------------------
          .               /// the caller to ensure that the `RawTable` outlives the `RawIter`.
          .               /// Because we cannot make the `next` method unsafe on the `RawIter`
          .               /// struct, we have to make the `iter` method unsafe.
          .               #[inline]
          .               pub unsafe fn iter(&self) -> RawIter<T> {
          .                   let data = Bucket::from_base_index(self.data_end(), 0);
          .                   RawIter {
          .                       iter: RawIterRange::new(self.table.ctrl.as_ptr(), data, self.table.buckets()),
    162,967 ( 0.00%)              items: self.table.items,
          .                   }
          .               }
          .           
          .               /// Returns an iterator over occupied buckets that could match a given hash.
          .               ///
          .               /// `RawTable` only stores 7 bits of the hash value, so this iterator may
          .               /// return items that have a hash value different than the one provided. You
          .               /// should always validate the returned values before using them.
-- line 954 ----------------------------------------
-- line 995 ----------------------------------------
          .               /// Iteration starts at the provided iterator's current location.
          .               ///
          .               /// It is up to the caller to ensure that the iterator is valid for this
          .               /// `RawTable` and covers all items that remain in the table.
          .               pub unsafe fn into_iter_from(self, iter: RawIter<T>) -> RawIntoIter<T, A> {
          .                   debug_assert_eq!(iter.len(), self.len());
          .           
          .                   let alloc = self.table.alloc.clone();
      2,772 ( 0.00%)          let allocation = self.into_allocation();
      2,079 ( 0.00%)          RawIntoIter {
      3,465 ( 0.00%)              iter,
          .                       allocation,
          .                       marker: PhantomData,
          .                       alloc,
          .                   }
          .               }
          .           
          .               /// Converts the table into a raw allocation. The contents of the table
          .               /// should be dropped using a `RawIter` before freeing the allocation.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               pub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout)> {
      1,106 ( 0.00%)          let alloc = if self.table.is_empty_singleton() {
          .                       None
          .                   } else {
          .                       // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
          .                       let (layout, ctrl_offset) = match calculate_layout::<T>(self.table.buckets()) {
          .                           Some(lco) => lco,
          .                           None => unsafe { hint::unreachable_unchecked() },
          .                       };
          .                       Some((
        191 ( 0.00%)                  unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().sub(ctrl_offset)) },
          .                           layout,
          .                       ))
          .                   };
          .                   mem::forget(self);
          .                   alloc
          .               }
          .           }
          .           
-- line 1033 ----------------------------------------
-- line 1042 ----------------------------------------
          .               T: Sync,
          .               A: Sync,
          .           {
          .           }
          .           
          .           impl<A> RawTableInner<A> {
          .               #[inline]
          .               const fn new_in(alloc: A) -> Self {
  1,568,736 ( 0.00%)          Self {
          .                       // Be careful to cast the entire slice to a raw pointer.
          .                       ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
          .                       bucket_mask: 0,
          .                       items: 0,
          .                       growth_left: 0,
          .                       alloc,
          .                   }
          .               }
          .           }
          .           
          .           impl<A: Allocator + Clone> RawTableInner<A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
    884,848 ( 0.00%)      unsafe fn new_uninitialized(
          .                   alloc: A,
          .                   table_layout: TableLayout,
          .                   buckets: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
          .                   debug_assert!(buckets.is_power_of_two());
          .           
          .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
-- line 1071 ----------------------------------------
-- line 1078 ----------------------------------------
          .                   // exceed `isize::MAX`. We can skip this check on 64-bit systems since
          .                   // such allocations will never succeed anyways.
          .                   //
          .                   // This mirrors what Vec does in the standard library.
          .                   if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
          .                       return Err(fallibility.capacity_overflow());
          .                   }
          .           
    224,826 ( 0.00%)          let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
          .                       Ok(block) => block.cast(),
          .                       Err(_) => return Err(fallibility.alloc_err(layout)),
          .                   };
          .           
          .                   let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
    509,574 ( 0.00%)          Ok(Self {
          .                       ctrl,
    257,075 ( 0.00%)              bucket_mask: buckets - 1,
          .                       items: 0,
          .                       growth_left: bucket_mask_to_capacity(buckets - 1),
          .                       alloc,
          .                   })
    646,518 ( 0.00%)      }
          .           
          .               #[inline]
     29,119 ( 0.00%)      fn fallible_with_capacity(
          .                   alloc: A,
          .                   table_layout: TableLayout,
          .                   capacity: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<Self, TryReserveError> {
      7,354 ( 0.00%)          if capacity == 0 {
      7,506 ( 0.00%)              Ok(Self::new_in(alloc))
          .                   } else {
          .                       unsafe {
          .                           let buckets =
          .                               capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
          .           
    404,789 ( 0.00%)                  let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
          .                           result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
          .           
     12,941 ( 0.00%)                  Ok(result)
          .                       }
          .                   }
     29,119 ( 0.00%)      }
          .           
          .               /// Searches for an empty or deleted bucket which is suitable for inserting
          .               /// a new element and sets the hash for that slot.
          .               ///
          .               /// There must be at least 1 empty bucket in the table.
          .               #[inline]
    356,017 ( 0.00%)      unsafe fn prepare_insert_slot(&self, hash: u64) -> (usize, u8) {
          .                   let index = self.find_insert_slot(hash);
    356,017 ( 0.00%)          let old_ctrl = *self.ctrl(index);
          .                   self.set_ctrl_h2(index, hash);
          .                   (index, old_ctrl)
    712,034 ( 0.00%)      }
          .           
          .               /// Searches for an empty or deleted bucket which is suitable for inserting
          .               /// a new element.
          .               ///
          .               /// There must be at least 1 empty bucket in the table.
          .               #[inline]
          .               fn find_insert_slot(&self, hash: u64) -> usize {
          .                   let mut probe_seq = self.probe_seq(hash);
          .                   loop {
          .                       unsafe {
          .                           let group = Group::load(self.ctrl(probe_seq.pos));
  4,462,274 ( 0.01%)                  if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
 12,755,137 ( 0.03%)                      let result = (probe_seq.pos + bit) & self.bucket_mask;
          .           
          .                               // In tables smaller than the group width, trailing control
          .                               // bytes outside the range of the table are filled with
          .                               // EMPTY entries. These will unfortunately trigger a
          .                               // match, but once masked may point to a full bucket that
          .                               // is already occupied. We detect this situation here and
          .                               // perform a second scan starting at the beginning of the
          .                               // table. This second scan is guaranteed to find an empty
          .                               // slot (due to the load factor) before hitting the trailing
          .                               // control bytes (containing EMPTY).
  5,993,366 ( 0.02%)                      if unlikely(is_full(*self.ctrl(result))) {
          .                                   debug_assert!(self.bucket_mask < Group::WIDTH);
          .                                   debug_assert_ne!(probe_seq.pos, 0);
          .                                   return Group::load_aligned(self.ctrl(0))
          .                                       .match_empty_or_deleted()
          .                                       .lowest_set_bit_nonzero();
          .                               }
          .           
          .                               return result;
-- line 1165 ----------------------------------------
-- line 1171 ----------------------------------------
          .           
          .               /// Searches for an element in the table. This uses dynamic dispatch to reduce the amount of
          .               /// code generated, but it is eliminated by LLVM optimizations.
          .               #[inline]
          .               fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
          .                   let h2_hash = h2(hash);
          .                   let mut probe_seq = self.probe_seq(hash);
          .           
    445,828 ( 0.00%)          loop {
          .                       let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
          .           
 15,389,144 ( 0.04%)              for bit in group.match_byte(h2_hash) {
 33,013,293 ( 0.09%)                  let index = (probe_seq.pos + bit) & self.bucket_mask;
          .           
 21,890,516 ( 0.06%)                  if likely(eq(index)) {
          .                               return Some(index);
          .                           }
          .                       }
          .           
  3,790,673 ( 0.01%)              if likely(group.match_empty().any_bit_set()) {
          .                           return None;
          .                       }
          .           
          .                       probe_seq.move_next(self.bucket_mask);
          .                   }
          .               }
          .           
          .               #[allow(clippy::mut_mut)]
-- line 1198 ----------------------------------------
-- line 1225 ----------------------------------------
          .                   Bucket::from_base_index(self.data_end(), index)
          .               }
          .           
          .               #[inline]
          .               unsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8 {
          .                   debug_assert_ne!(self.bucket_mask, 0);
          .                   debug_assert!(index < self.buckets());
          .                   let base: *mut u8 = self.data_end().as_ptr();
 16,230,136 ( 0.04%)          base.sub((index + 1) * size_of)
          .               }
          .           
          .               #[inline]
          .               unsafe fn data_end<T>(&self) -> NonNull<T> {
          .                   NonNull::new_unchecked(self.ctrl.as_ptr().cast())
          .               }
          .           
          .               /// Returns an iterator-like object for a probe sequence on the table.
          .               ///
          .               /// This iterator never terminates, but is guaranteed to visit each bucket
          .               /// group exactly once. The loop using `probe_seq` must terminate upon
          .               /// reaching a group containing an empty bucket.
          .               #[inline]
          .               fn probe_seq(&self, hash: u64) -> ProbeSeq {
          .                   ProbeSeq {
 93,697,090 ( 0.25%)              pos: h1(hash) & self.bucket_mask,
          .                       stride: 0,
          .                   }
          .               }
          .           
          .               /// Returns the index of a bucket for which a value must be inserted if there is enough rooom
          .               /// in the table, otherwise returns error
          .               #[cfg(feature = "raw")]
          .               #[inline]
-- line 1257 ----------------------------------------
-- line 1263 ----------------------------------------
          .                   } else {
          .                       self.record_item_insert_at(index, old_ctrl, hash);
          .                       Ok(index)
          .                   }
          .               }
          .           
          .               #[inline]
          .               unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
  8,788,333 ( 0.02%)          self.growth_left -= special_is_empty(old_ctrl) as usize;
          .                   self.set_ctrl_h2(index, hash);
  7,004,060 ( 0.02%)          self.items += 1;
          .               }
          .           
          .               #[inline]
          .               fn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool {
          .                   let probe_seq_pos = self.probe_seq(hash).pos;
          .                   let probe_index =
          .                       |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;
          .                   probe_index(i) == probe_index(new_i)
-- line 1281 ----------------------------------------
-- line 1312 ----------------------------------------
          .                   // replicate the buckets at the end of the trailing group. For example
          .                   // with 2 buckets and a group size of 4, the control bytes will look
          .                   // like this:
          .                   //
          .                   //     Real    |             Replicated
          .                   // ---------------------------------------------
          .                   // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
          .                   // ---------------------------------------------
 12,457,333 ( 0.03%)          let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
          .           
  4,144,163 ( 0.01%)          *self.ctrl(index) = ctrl;
  4,144,502 ( 0.01%)          *self.ctrl(index2) = ctrl;
          .               }
          .           
          .               /// Returns a pointer to a control byte.
          .               #[inline]
          .               unsafe fn ctrl(&self, index: usize) -> *mut u8 {
          .                   debug_assert!(index < self.num_ctrl_bytes());
          .                   self.ctrl.as_ptr().add(index)
          .               }
          .           
          .               #[inline]
          .               fn buckets(&self) -> usize {
    649,933 ( 0.00%)          self.bucket_mask + 1
          .               }
          .           
          .               #[inline]
          .               fn num_ctrl_bytes(&self) -> usize {
    559,361 ( 0.00%)          self.bucket_mask + 1 + Group::WIDTH
          .               }
          .           
          .               #[inline]
          .               fn is_empty_singleton(&self) -> bool {
  3,141,458 ( 0.01%)          self.bucket_mask == 0
          .               }
          .           
          .               #[allow(clippy::mut_mut)]
          .               #[inline]
          .               unsafe fn prepare_resize(
          .                   &self,
          .                   table_layout: TableLayout,
          .                   capacity: usize,
          .                   fallibility: Fallibility,
          .               ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
          .                   debug_assert!(self.items <= capacity);
          .           
          .                   // Allocate and initialize the new table.
      3,033 ( 0.00%)          let mut new_table = RawTableInner::fallible_with_capacity(
          .                       self.alloc.clone(),
          .                       table_layout,
          .                       capacity,
          .                       fallibility,
          .                   )?;
    388,277 ( 0.00%)          new_table.growth_left -= self.items;
          .                   new_table.items = self.items;
          .           
          .                   // The hash function may panic, in which case we simply free the new
          .                   // table without dropping any elements that may have been copied into
          .                   // it.
          .                   //
          .                   // This guard is also used to free the old table on success, see
          .                   // the comment at the bottom of this function.
          .                   Ok(guard(new_table, move |self_| {
    170,960 ( 0.00%)              if !self_.is_empty_singleton() {
          .                           self_.free_buckets(table_layout);
          .                       }
          .                   }))
          .               }
          .           
          .               /// Reserves or rehashes to make room for `additional` more elements.
          .               ///
          .               /// This uses dynamic dispatch to reduce the amount of
-- line 1383 ----------------------------------------
-- line 1388 ----------------------------------------
          .                   &mut self,
          .                   additional: usize,
          .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
          .                   fallibility: Fallibility,
          .                   layout: TableLayout,
          .                   drop: Option<fn(*mut u8)>,
          .               ) -> Result<(), TryReserveError> {
          .                   // Avoid `Option::ok_or_else` because it bloats LLVM IR.
    341,926 ( 0.00%)          let new_items = match self.items.checked_add(additional) {
          .                       Some(new_items) => new_items,
          .                       None => return Err(fallibility.capacity_overflow()),
          .                   };
    341,920 ( 0.00%)          let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
    752,012 ( 0.00%)          if new_items <= full_capacity / 2 {
          .                       // Rehash in-place without re-allocating if we have plenty of spare
          .                       // capacity that is locked up due to DELETED entries.
          .                       self.rehash_in_place(hasher, layout.size, drop);
          .                       Ok(())
          .                   } else {
          .                       // Otherwise, conservatively resize to at least the next size up
          .                       // to avoid churning deletes into frequent rehashes.
          .                       self.resize_inner(
    170,960 ( 0.00%)                  usize::max(new_items, full_capacity + 1),
          .                           hasher,
          .                           fallibility,
          .                           layout,
          .                       )
          .                   }
          .               }
          .           
          .               /// Allocates a new table of a different size and moves the contents of the
-- line 1418 ----------------------------------------
-- line 1424 ----------------------------------------
          .               #[inline(always)]
          .               unsafe fn resize_inner(
          .                   &mut self,
          .                   capacity: usize,
          .                   hasher: &dyn Fn(&mut Self, usize) -> u64,
          .                   fallibility: Fallibility,
          .                   layout: TableLayout,
          .               ) -> Result<(), TryReserveError> {
      7,546 ( 0.00%)          let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
          .           
          .                   // Copy all elements to the new table.
          .                   for i in 0..self.buckets() {
  2,438,078 ( 0.01%)              if !is_full(*self.ctrl(i)) {
          .                           continue;
          .                       }
          .           
          .                       // This may panic.
          .                       let hash = hasher(self, i);
          .           
          .                       // We can use a simpler version of insert() here since:
          .                       // - there are no DELETED entries.
-- line 1444 ----------------------------------------
-- line 1454 ----------------------------------------
          .                   }
          .           
          .                   // We successfully copied all elements without panicking. Now replace
          .                   // self with the new table. The old table will have its memory freed but
          .                   // the items will not be dropped (since they have been moved into the
          .                   // new table).
          .                   mem::swap(self, &mut new_table);
          .           
    170,960 ( 0.00%)          Ok(())
          .               }
          .           
          .               /// Rehashes the contents of the table in place (i.e. without changing the
          .               /// allocation).
          .               ///
          .               /// If `hasher` panics then some the table's contents may be lost.
          .               ///
          .               /// This uses dynamic dispatch to reduce the amount of
-- line 1470 ----------------------------------------
-- line 1554 ----------------------------------------
          .               #[inline]
          .               unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
          .                   // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
          .                   let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
          .                       Some(lco) => lco,
          .                       None => hint::unreachable_unchecked(),
          .                   };
          .                   self.alloc.deallocate(
    105,073 ( 0.00%)              NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
          .                       layout,
          .                   );
          .               }
          .           
          .               /// Marks all table buckets as empty without dropping their contents.
          .               #[inline]
          .               fn clear_no_drop(&mut self) {
     32,179 ( 0.00%)          if !self.is_empty_singleton() {
          .                       unsafe {
          .                           self.ctrl(0).write_bytes(EMPTY, self.num_ctrl_bytes());
          .                       }
          .                   }
     41,000 ( 0.00%)          self.items = 0;
     32,285 ( 0.00%)          self.growth_left = bucket_mask_to_capacity(self.bucket_mask);
          .               }
          .           
          .               #[inline]
          .               unsafe fn erase(&mut self, index: usize) {
          .                   debug_assert!(is_full(*self.ctrl(index)));
    286,906 ( 0.00%)          let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;
          .                   let empty_before = Group::load(self.ctrl(index_before)).match_empty();
          .                   let empty_after = Group::load(self.ctrl(index)).match_empty();
          .           
          .                   // If we are inside a continuous block of Group::WIDTH full or deleted
          .                   // cells then a probe window may have seen a full block when trying to
          .                   // insert. We therefore need to keep that block non-empty so that
          .                   // lookups will continue searching to the next probe window.
          .                   //
          .                   // Note that in this context `leading_zeros` refers to the bytes at the
          .                   // end of a group, while `trailing_zeros` refers to the bytes at the
          .                   // beginning of a group.
  1,147,624 ( 0.00%)          let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {
          .                       DELETED
          .                   } else {
  1,403,375 ( 0.00%)              self.growth_left += 1;
          .                       EMPTY
          .                   };
          .                   self.set_ctrl(index, ctrl);
  1,147,624 ( 0.00%)          self.items -= 1;
          .               }
          .           }
          .           
          .           impl<T: Clone, A: Allocator + Clone> Clone for RawTable<T, A> {
    723,128 ( 0.00%)      fn clone(&self) -> Self {
     90,428 ( 0.00%)          if self.table.is_empty_singleton() {
          .                       Self::new_in(self.table.alloc.clone())
          .                   } else {
          .                       unsafe {
          .                           let mut new_table = ManuallyDrop::new(
          .                               // Avoid `Result::ok_or_else` because it bloats LLVM IR.
          .                               match Self::new_uninitialized(
          .                                   self.table.alloc.clone(),
          .                                   self.table.buckets(),
-- line 1615 ----------------------------------------
-- line 1624 ----------------------------------------
          .                               // We need to free the memory allocated for the new table.
          .                               new_table.free_buckets();
          .                           });
          .           
          .                           // Return the newly created table.
          .                           ManuallyDrop::into_inner(new_table)
          .                       }
          .                   }
    813,519 ( 0.00%)      }
          .           
          .               fn clone_from(&mut self, source: &Self) {
          .                   if source.table.is_empty_singleton() {
          .                       *self = Self::new_in(self.table.alloc.clone());
          .                   } else {
          .                       unsafe {
          .                           // First, drop all our elements without clearing the control bytes.
          .                           self.drop_elements();
-- line 1640 ----------------------------------------
-- line 1687 ----------------------------------------
          .                       .table
          .                       .ctrl(0)
          .                       .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());
          .                   source
          .                       .data_start()
          .                       .copy_to_nonoverlapping(self.data_start(), self.table.buckets());
          .           
          .                   self.table.items = source.table.items;
         72 ( 0.00%)          self.table.growth_left = source.table.growth_left;
          .               }
          .           }
          .           
          .           impl<T: Clone, A: Allocator + Clone> RawTable<T, A> {
          .               /// Common code for clone and clone_from. Assumes `self.buckets() == source.buckets()`.
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               unsafe fn clone_from_impl(&mut self, source: &Self, mut on_panic: impl FnMut(&mut Self)) {
          .                   // Copy the control bytes unchanged. We do this in a single pass
-- line 1703 ----------------------------------------
-- line 1790 ----------------------------------------
          .               fn default() -> Self {
          .                   Self::new_in(Default::default())
          .               }
          .           }
          .           
          .           #[cfg(feature = "nightly")]
          .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawTable<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
  2,651,818 ( 0.01%)      fn drop(&mut self) {
  1,243,222 ( 0.00%)          if !self.table.is_empty_singleton() {
          .                       unsafe {
          .                           self.drop_elements();
          .                           self.free_buckets();
          .                       }
          .                   }
  2,783,446 ( 0.01%)      }
          .           }
          .           #[cfg(not(feature = "nightly"))]
          .           impl<T, A: Allocator + Clone> Drop for RawTable<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn drop(&mut self) {
          .                   if !self.table.is_empty_singleton() {
          .                       unsafe {
          .                           self.drop_elements();
-- line 1813 ----------------------------------------
-- line 1817 ----------------------------------------
          .               }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> IntoIterator for RawTable<T, A> {
          .               type Item = T;
          .               type IntoIter = RawIntoIter<T, A>;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
      2,772 ( 0.00%)      fn into_iter(self) -> RawIntoIter<T, A> {
          .                   unsafe {
          .                       let iter = self.iter();
          .                       self.into_iter_from(iter)
          .                   }
      3,465 ( 0.00%)      }
          .           }
          .           
          .           /// Iterator over a sub-range of a table. Unlike `RawIter` this iterator does
          .           /// not track an item count.
          .           pub(crate) struct RawIterRange<T> {
          .               // Mask of full buckets in the current group. Bits are cleared from this
          .               // mask as each element is processed.
          .               current_group: BitMask,
-- line 1838 ----------------------------------------
-- line 1934 ----------------------------------------
          .           
          .           impl<T> Iterator for RawIterRange<T> {
          .               type Item = Bucket<T>;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn next(&mut self) -> Option<Bucket<T>> {
          .                   unsafe {
          .                       loop {
    809,534 ( 0.00%)                  if let Some(index) = self.current_group.lowest_set_bit() {
    125,784 ( 0.00%)                      self.current_group = self.current_group.remove_lowest_bit();
    190,319 ( 0.00%)                      return Some(self.data.next_n(index));
          .                           }
          .           
    458,154 ( 0.00%)                  if self.next_ctrl >= self.end {
          .                               return None;
          .                           }
          .           
          .                           // We might read past self.end up to the next group boundary,
          .                           // but this is fine because it only occurs on tables smaller
          .                           // than the group size where the trailing control bytes are all
          .                           // EMPTY. On larger tables self.end is guaranteed to be aligned
          .                           // to the group size (since tables are power-of-two sized).
     24,612 ( 0.00%)                  self.current_group = Group::load_aligned(self.next_ctrl).match_full();
     19,906 ( 0.00%)                  self.data = self.data.next_n(Group::WIDTH);
     39,970 ( 0.00%)                  self.next_ctrl = self.next_ctrl.add(Group::WIDTH);
          .                       }
          .                   }
          .               }
          .           
          .               #[inline]
          .               fn size_hint(&self) -> (usize, Option<usize>) {
          .                   // We don't have an item count, so just guess based on the range size.
          .                   (
-- line 1966 ----------------------------------------
-- line 2102 ----------------------------------------
          .                           }
          .                       } else {
          .                           // We must have already iterated past the removed item.
          .                       }
          .                   }
          .               }
          .           
          .               unsafe fn drop_elements(&mut self) {
     21,128 ( 0.00%)          if mem::needs_drop::<T>() && self.len() != 0 {
          .                       for item in self {
          .                           item.drop();
          .                       }
          .                   }
          .               }
          .           }
          .           
          .           impl<T> Clone for RawIter<T> {
-- line 2118 ----------------------------------------
-- line 2124 ----------------------------------------
          .                   }
          .               }
          .           }
          .           
          .           impl<T> Iterator for RawIter<T> {
          .               type Item = Bucket<T>;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
    106,569 ( 0.00%)      fn next(&mut self) -> Option<Bucket<T>> {
    325,814 ( 0.00%)          if let Some(b) = self.iter.next() {
  1,375,933 ( 0.00%)              self.items -= 1;
          .                       Some(b)
          .                   } else {
          .                       // We don't check against items == 0 here to allow the
          .                       // compiler to optimize away the item count entirely if the
          .                       // iterator length is never queried.
          .                       debug_assert_eq!(self.items, 0);
          .                       None
          .                   }
    213,138 ( 0.00%)      }
          .           
          .               #[inline]
          .               fn size_hint(&self) -> (usize, Option<usize>) {
          .                   (self.items, Some(self.items))
          .               }
          .           }
          .           
          .           impl<T> ExactSizeIterator for RawIter<T> {}
-- line 2151 ----------------------------------------
-- line 2177 ----------------------------------------
          .               T: Sync,
          .               A: Sync,
          .           {
          .           }
          .           
          .           #[cfg(feature = "nightly")]
          .           unsafe impl<#[may_dangle] T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
      1,196 ( 0.00%)      fn drop(&mut self) {
          .                   unsafe {
          .                       // Drop all remaining elements
          .                       self.iter.drop_elements();
          .           
          .                       // Free the table
      5,238 ( 0.00%)              if let Some((ptr, layout)) = self.allocation {
          .                           self.alloc.deallocate(ptr, layout);
          .                       }
          .                   }
        316 ( 0.00%)      }
          .           }
          .           #[cfg(not(feature = "nightly"))]
          .           impl<T, A: Allocator + Clone> Drop for RawIntoIter<T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn drop(&mut self) {
          .                   unsafe {
          .                       // Drop all remaining elements
          .                       self.iter.drop_elements();
-- line 2203 ----------------------------------------
-- line 2209 ----------------------------------------
          .                   }
          .               }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> Iterator for RawIntoIter<T, A> {
          .               type Item = T;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
     11,889 ( 0.00%)      fn next(&mut self) -> Option<T> {
          3 ( 0.00%)          unsafe { Some(self.iter.next()?.read()) }
     35,594 ( 0.00%)      }
          .           
          .               #[inline]
          .               fn size_hint(&self) -> (usize, Option<usize>) {
          2 ( 0.00%)          self.iter.size_hint()
          .               }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> ExactSizeIterator for RawIntoIter<T, A> {}
          .           impl<T, A: Allocator + Clone> FusedIterator for RawIntoIter<T, A> {}
          .           
          .           /// Iterator which consumes elements without freeing the table storage.
          .           pub struct RawDrain<'a, T, A: Allocator + Clone = Global> {
-- line 2231 ----------------------------------------
-- line 2259 ----------------------------------------
          .           where
          .               T: Sync,
          .               A: Sync,
          .           {
          .           }
          .           
          .           impl<T, A: Allocator + Clone> Drop for RawDrain<'_, T, A> {
          .               #[cfg_attr(feature = "inline-more", inline)]
     54,920 ( 0.00%)      fn drop(&mut self) {
          .                   unsafe {
          .                       // Drop all remaining elements. Note that this may panic.
          .                       self.iter.drop_elements();
          .           
          .                       // Reset the contents of the table now that all elements have been
          .                       // dropped.
          .                       self.table.clear_no_drop();
          .           
          .                       // Move the now empty table back to its original location.
      6,865 ( 0.00%)              self.orig_table
          .                           .as_ptr()
          .                           .copy_from_nonoverlapping(&*self.table, 1);
          .                   }
     54,920 ( 0.00%)      }
          .           }
          .           
          .           impl<T, A: Allocator + Clone> Iterator for RawDrain<'_, T, A> {
          .               type Item = T;
          .           
          .               #[cfg_attr(feature = "inline-more", inline)]
          .               fn next(&mut self) -> Option<T> {
          .                   unsafe {
-- line 2289 ----------------------------------------

 45,678,704 ( 0.12%)  <counts for unidentified lines in /usr/home/liquid/.cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.12.0/src/raw/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_expand/src/mbe/macro_parser.rs
--------------------------------------------------------------------------------
Ir                 

-- line 90 ----------------------------------------
        .           use std::collections::hash_map::Entry::{Occupied, Vacant};
        .           use std::mem;
        .           use std::ops::{Deref, DerefMut};
        .           
        .           // To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.
        .           
        .           /// Either a sequence of token trees or a single one. This is used as the representation of the
        .           /// sequence of tokens that make up a matcher.
  401,163 ( 0.00%)  #[derive(Clone)]
        .           enum TokenTreeOrTokenTreeSlice<'tt> {
      390 ( 0.00%)      Tt(TokenTree),
   98,454 ( 0.00%)      TtSeq(&'tt [TokenTree]),
        .           }
        .           
        .           impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {
        .               /// Returns the number of constituent top-level token trees of `self` (top-level in that it
        .               /// will not recursively descend into subtrees).
        .               fn len(&self) -> usize {
2,189,381 ( 0.01%)          match *self {
  503,110 ( 0.00%)              TtSeq(ref v) => v.len(),
        .                       Tt(ref tt) => tt.len(),
        .                   }
        .               }
        .           
        .               /// The `index`-th token tree of `self`.
        .               fn get_tt(&self, index: usize) -> TokenTree {
  473,722 ( 0.00%)          match *self {
1,559,732 ( 0.00%)              TtSeq(ref v) => v[index].clone(),
  511,110 ( 0.00%)              Tt(ref tt) => tt.get_tt(index),
        .                   }
        .               }
        .           }
        .           
        .           /// An unzipping of `TokenTree`s... see the `stack` field of `MatcherPos`.
        .           ///
        .           /// This is used by `inner_parse_loop` to keep track of delimited submatchers that we have
        .           /// descended into.
   61,778 ( 0.00%)  #[derive(Clone)]
        .           struct MatcherTtFrame<'tt> {
        .               /// The "parent" matcher that we are descending into.
        .               elts: TokenTreeOrTokenTreeSlice<'tt>,
        .               /// The position of the "dot" in `elts` at the time we descended.
   30,889 ( 0.00%)      idx: usize,
        .           }
        .           
        .           type NamedMatchVec = SmallVec<[NamedMatch; 4]>;
        .           
        .           /// Represents a single "position" (aka "matcher position", aka "item"), as
        .           /// described in the module documentation.
        .           ///
        .           /// Here:
-- line 140 ----------------------------------------
-- line 147 ----------------------------------------
        .           ///   position refers to.
        .           ///
        .           /// It is important to distinguish these two lifetimes because we have a
        .           /// `SmallVec<TokenTreeOrTokenTreeSlice<'tt>>` below, and the destructor of
        .           /// that is considered to possibly access the data from its elements (it lacks
        .           /// a `#[may_dangle]` attribute). As a result, the compiler needs to know that
        .           /// all the elements in that `SmallVec` strictly outlive the root stack slot
        .           /// lifetime. By separating `'tt` from `'root`, we can show that.
1,735,992 ( 0.00%)  #[derive(Clone)]
        .           struct MatcherPos<'root, 'tt> {
        .               /// The token or sequence of tokens that make up the matcher
        .               top_elts: TokenTreeOrTokenTreeSlice<'tt>,
        .           
        .               /// The position of the "dot" in this matcher
   36,936 ( 0.00%)      idx: usize,
        .           
        .               /// For each named metavar in the matcher, we keep track of token trees matched against the
        .               /// metavar by the black box parser. In particular, there may be more than one match per
        .               /// metavar if we are in a repetition (each repetition matches each of the variables).
        .               /// Moreover, matchers and repetitions can be nested; the `matches` field is shared (hence the
        .               /// `Rc`) among all "nested" matchers. `match_lo`, `match_cur`, and `match_hi` keep track of
        .               /// the current position of the `self` matcher position in the shared `matches` list.
        .               ///
        .               /// Also, note that while we are descending into a sequence, matchers are given their own
        .               /// `matches` vector. Only once we reach the end of a full repetition of the sequence do we add
        .               /// all bound matches from the submatcher into the shared top-level `matches` vector. If `sep`
        .               /// and `up` are `Some`, then `matches` is _not_ the shared top-level list. Instead, if one
        .               /// wants the shared `matches`, one should use `up.matches`.
  147,744 ( 0.00%)      matches: Box<[Lrc<NamedMatchVec>]>,
        .               /// The position in `matches` corresponding to the first metavar in this matcher's sequence of
        .               /// token trees. In other words, the first metavar in the first token of `top_elts` corresponds
        .               /// to `matches[match_lo]`.
   36,936 ( 0.00%)      match_lo: usize,
        .               /// The position in `matches` corresponding to the metavar we are currently trying to match
        .               /// against the source token stream. `match_lo <= match_cur <= match_hi`.
        .               match_cur: usize,
        .               /// Similar to `match_lo` except `match_hi` is the position in `matches` of the _last_ metavar
        .               /// in this matcher.
   36,936 ( 0.00%)      match_hi: usize,
        .           
        .               // The following fields are used if we are matching a repetition. If we aren't, they should be
        .               // `None`.
        .               /// The KleeneOp of this sequence if we are in a repetition.
   36,936 ( 0.00%)      seq_op: Option<mbe::KleeneOp>,
        .           
        .               /// The separator if we are in a repetition.
        .               sep: Option<Token>,
        .           
        .               /// The "parent" matcher position if we are in a repetition. That is, the matcher position just
        .               /// before we enter the sequence.
   73,872 ( 0.00%)      up: Option<MatcherPosHandle<'root, 'tt>>,
        .           
        .               /// Specifically used to "unzip" token trees. By "unzip", we mean to unwrap the delimiters from
        .               /// a delimited token tree (e.g., something wrapped in `(` `)`) or to get the contents of a doc
        .               /// comment...
        .               ///
        .               /// When matching against matchers with nested delimited submatchers (e.g., `pat ( pat ( .. )
        .               /// pat ) pat`), we need to keep track of the matchers we are descending into. This stack does
        .               /// that where the bottom of the stack is the outermost matcher.
        .               /// Also, throughout the comments, this "descent" is often referred to as "unzipping"...
        .               stack: SmallVec<[MatcherTtFrame<'tt>; 1]>,
        .           }
        .           
        .           impl<'root, 'tt> MatcherPos<'root, 'tt> {
        .               /// Adds `m` as a named match for the `idx`-th metavar.
        .               fn push_match(&mut self, idx: usize, m: NamedMatch) {
  892,140 ( 0.00%)          let matches = Lrc::make_mut(&mut self.matches[idx]);
        .                   matches.push(m);
        .               }
        .           }
        .           
        .           // Lots of MatcherPos instances are created at runtime. Allocating them on the
        .           // heap is slow. Furthermore, using SmallVec<MatcherPos> to allocate them all
        .           // on the stack is also slow, because MatcherPos is quite a large type and
        .           // instances get moved around a lot between vectors, which requires lots of
-- line 221 ----------------------------------------
-- line 226 ----------------------------------------
        .           // and this type is used to encapsulate both cases.
        .           enum MatcherPosHandle<'root, 'tt> {
        .               Ref(&'root mut MatcherPos<'root, 'tt>),
        .               Box(Box<MatcherPos<'root, 'tt>>),
        .           }
        .           
        .           impl<'root, 'tt> Clone for MatcherPosHandle<'root, 'tt> {
        .               // This always produces a new Box.
  147,744 ( 0.00%)      fn clone(&self) -> Self {
   73,872 ( 0.00%)          MatcherPosHandle::Box(match *self {
   37,152 ( 0.00%)              MatcherPosHandle::Ref(ref r) => Box::new((**r).clone()),
        .                       MatcherPosHandle::Box(ref b) => b.clone(),
        .                   })
  221,616 ( 0.00%)      }
        .           }
        .           
        .           impl<'root, 'tt> Deref for MatcherPosHandle<'root, 'tt> {
        .               type Target = MatcherPos<'root, 'tt>;
        .               fn deref(&self) -> &Self::Target {
        .                   match *self {
        .                       MatcherPosHandle::Ref(ref r) => r,
        .                       MatcherPosHandle::Box(ref b) => b,
-- line 247 ----------------------------------------
-- line 272 ----------------------------------------
        .           
        .           /// A `ParseResult` where the `Success` variant contains a mapping of
        .           /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping
        .           /// of metavars to the token trees they bind to.
        .           crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;
        .           
        .           /// Count how many metavars are named in the given matcher `ms`.
        .           pub(super) fn count_names(ms: &[TokenTree]) -> usize {
1,532,160 ( 0.00%)      ms.iter().fold(0, |count, elt| {
  766,080 ( 0.00%)          count
2,298,240 ( 0.01%)              + match *elt {
   52,354 ( 0.00%)                  TokenTree::Sequence(_, ref seq) => seq.num_captures,
   48,584 ( 0.00%)                  TokenTree::Delimited(_, ref delim) => count_names(&delim.tts),
        .                           TokenTree::MetaVar(..) => 0,
        .                           TokenTree::MetaVarDecl(..) => 1,
        .                           TokenTree::Token(..) => 0,
        .                       }
1,915,200 ( 0.01%)      })
        .           }
        .           
        .           /// `len` `Vec`s (initially shared and empty) that will store matches of metavars.
        .           fn create_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {
  257,310 ( 0.00%)      if len == 0 {
        .                   vec![]
        .               } else {
        .                   let empty_matches = Lrc::new(SmallVec::new());
        .                   vec![empty_matches; len]
        .               }
        .               .into_boxed_slice()
        .           }
        .           
        .           /// Generates the top-level matcher position in which the "dot" is before the first token of the
        .           /// matcher `ms`.
        .           fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree]) -> MatcherPos<'root, 'tt> {
        .               let match_idx_hi = count_names(ms);
        .               let matches = create_matches(match_idx_hi);
1,255,740 ( 0.00%)      MatcherPos {
        .                   // Start with the top level matcher given to us
        .                   top_elts: TtSeq(ms), // "elts" is an abbr. for "elements"
        .                   // The "dot" is before the first token of the matcher
        .                   idx: 0,
        .           
        .                   // Initialize `matches` to a bunch of empty `Vec`s -- one for each metavar in `top_elts`.
        .                   // `match_lo` for `top_elts` is 0 and `match_hi` is `matches.len()`. `match_cur` is 0 since
        .                   // we haven't actually matched anything yet.
-- line 316 ----------------------------------------
-- line 340 ----------------------------------------
        .           /// particular token tree.
        .           ///
        .           /// The width of each `MatchedSeq` in the `NamedMatch`, and the identity of
        .           /// the `MatchedNonterminal`s, will depend on the token tree it was applied
        .           /// to: each `MatchedSeq` corresponds to a single `TTSeq` in the originating
        .           /// token tree. The depth of the `NamedMatch` structure will therefore depend
        .           /// only on the nesting depth of `ast::TTSeq`s in the originating
        .           /// token tree it was derived from.
    3,310 ( 0.00%)  #[derive(Debug, Clone)]
        .           crate enum NamedMatch {
        .               MatchedSeq(Lrc<NamedMatchVec>),
        .               MatchedNonterminal(Lrc<Nonterminal>),
        .           }
        .           
        .           /// Takes a sequence of token trees `ms` representing a matcher which successfully matched input
        .           /// and an iterator of items that matched input and produces a `NamedParseResult`.
        .           fn nameize<I: Iterator<Item = NamedMatch>>(
-- line 356 ----------------------------------------
-- line 357 ----------------------------------------
        .               sess: &ParseSess,
        .               ms: &[TokenTree],
        .               mut res: I,
        .           ) -> NamedParseResult {
        .               // Recursively descend into each type of matcher (e.g., sequences, delimited, metavars) and make
        .               // sure that each metavar has _exactly one_ binding. If a metavar does not have exactly one
        .               // binding, then there is an error. If it does, then we insert the binding into the
        .               // `NamedParseResult`.
  512,116 ( 0.00%)      fn n_rec<I: Iterator<Item = NamedMatch>>(
        .                   sess: &ParseSess,
        .                   m: &TokenTree,
        .                   res: &mut I,
        .                   ret_val: &mut FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,
        .               ) -> Result<(), (rustc_span::Span, String)> {
  303,560 ( 0.00%)          match *m {
        .                       TokenTree::Sequence(_, ref seq) => {
    3,042 ( 0.00%)                  for next_m in &seq.tts {
   18,576 ( 0.00%)                      n_rec(sess, next_m, res.by_ref(), ret_val)?
        .                           }
        .                       }
        .                       TokenTree::Delimited(_, ref delim) => {
    4,570 ( 0.00%)                  for next_m in &delim.tts {
   27,420 ( 0.00%)                      n_rec(sess, next_m, res.by_ref(), ret_val)?;
        .                           }
        .                       }
        .                       TokenTree::MetaVarDecl(span, _, None) => {
        .                           if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {
        .                               return Err((span, "missing fragment specifier".to_string()));
        .                           }
        .                       }
  212,340 ( 0.00%)              TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val
  141,560 ( 0.00%)                  .entry(MacroRulesNormalizedIdent::new(bind_name))
        .                       {
        .                           Vacant(spot) => {
        .                               spot.insert(res.next().unwrap());
        .                           }
        .                           Occupied(..) => return Err((sp, format!("duplicated bind name: {}", bind_name))),
        .                       },
        .                       TokenTree::MetaVar(..) | TokenTree::Token(..) => (),
        .                   }
        .           
   46,556 ( 0.00%)          Ok(())
  372,448 ( 0.00%)      }
        .           
        .               let mut ret_val = FxHashMap::default();
        .               for m in ms {
  345,455 ( 0.00%)          match n_rec(sess, m, res.by_ref(), &mut ret_val) {
        .                       Ok(_) => {}
        .                       Err((sp, msg)) => return Error(sp, msg),
        .                   }
        .               }
        .           
   62,019 ( 0.00%)      Success(ret_val)
        .           }
        .           
        .           /// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)
        .           fn token_name_eq(t1: &Token, t2: &Token) -> bool {
  643,013 ( 0.00%)      if let (Some((ident1, is_raw1)), Some((ident2, is_raw2))) = (t1.ident(), t2.ident()) {
        9 ( 0.00%)          ident1.name == ident2.name && is_raw1 == is_raw2
  900,172 ( 0.00%)      } else if let (Some(ident1), Some(ident2)) = (t1.lifetime(), t2.lifetime()) {
        .                   ident1.name == ident2.name
        .               } else {
  385,624 ( 0.00%)          t1.kind == t2.kind
        .               }
        .           }
        .           
        .           /// Process the matcher positions of `cur_items` until it is empty. In the process, this will
        .           /// produce more items in `next_items`, `eof_items`, and `bb_items`.
        .           ///
        .           /// For more info about the how this happens, see the module-level doc comments and the inline
        .           /// comments of this function.
-- line 427 ----------------------------------------
-- line 443 ----------------------------------------
        .               sess: &ParseSess,
        .               cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,
        .               next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,
        .               eof_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,
        .               bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,
        .               token: &Token,
        .           ) -> ParseResult<()> {
        .               // Pop items from `cur_items` until it is empty.
1,545,736 ( 0.00%)      while let Some(mut item) = cur_items.pop() {
        .                   // When unzipped trees end, remove them. This corresponds to backtracking out of a
        .                   // delimited submatcher into which we already descended. In backtracking out again, we need
        .                   // to advance the "dot" past the delimiters in the outer matcher.
4,749,004 ( 0.01%)          while item.idx >= item.top_elts.len() {
   10,600 ( 0.00%)              match item.stack.pop() {
        .                           Some(MatcherTtFrame { elts, idx }) => {
   47,700 ( 0.00%)                      item.top_elts = elts;
   21,200 ( 0.00%)                      item.idx = idx + 1;
        .                           }
        .                           None => break,
        .                       }
        .                   }
        .           
        .                   // Get the current position of the "dot" (`idx`) in `item` and the number of token trees in
        .                   // the matcher (`len`).
        .                   let idx = item.idx;
        .                   let len = item.top_elts.len();
        .           
        .                   // If `idx >= len`, then we are at or past the end of the matcher of `item`.
1,045,663 ( 0.00%)          if idx >= len {
        .                       // We are repeating iff there is a parent. If the matcher is inside of a repetition,
        .                       // then we could be at the end of a sequence or at the beginning of the next
        .                       // repetition.
   46,126 ( 0.00%)              if item.up.is_some() {
        .                           // At this point, regardless of whether there is a separator, we should add all
        .                           // matches from the complete repetition of the sequence to the shared, top-level
        .                           // `matches` list (actually, `up.matches`, which could itself not be the top-level,
        .                           // but anyway...). Moreover, we add another item to `cur_items` in which the "dot"
        .                           // is at the end of the `up` matcher. This ensures that the "dot" in the `up`
        .                           // matcher is also advanced sufficiently.
        .                           //
        .                           // NOTE: removing the condition `idx == len` allows trailing separators.
   67,366 ( 0.00%)                  if idx == len {
        .                               // Get the `up` matcher
        .                               let mut new_pos = item.up.clone().unwrap();
        .           
        .                               // Add matches from this repetition to the `matches` of `up`
   67,046 ( 0.00%)                      for idx in item.match_lo..item.match_hi {
  167,625 ( 0.00%)                          let sub = item.matches[idx].clone();
  100,575 ( 0.00%)                          new_pos.push_match(idx, MatchedSeq(sub));
        .                               }
        .           
        .                               // Move the "dot" past the repetition in `up`
   66,885 ( 0.00%)                      new_pos.match_cur = item.match_hi;
  201,138 ( 0.00%)                      new_pos.idx += 1;
        .                               cur_items.push(new_pos);
        .                           }
        .           
        .                           // Check if we need a separator.
   33,523 ( 0.00%)                  if idx == len && item.sep.is_some() {
        .                               // We have a separator, and it is the current token. We can advance past the
        .                               // separator token.
      328 ( 0.00%)                      if item.sep.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {
    1,120 ( 0.00%)                          item.idx += 1;
        .                                   next_items.push(item);
        .                               }
        .                           }
        .                           // We don't need a separator. Move the "dot" back to the beginning of the matcher
        .                           // and try to match again UNLESS we are only allowed to have _one_ repetition.
   33,519 ( 0.00%)                  else if item.seq_op != Some(mbe::KleeneOp::ZeroOrOne) {
   67,036 ( 0.00%)                      item.match_cur = item.match_lo;
  134,072 ( 0.00%)                      item.idx = 0;
        .                               cur_items.push(item);
        .                           }
        .                       }
        .                       // If we are not in a repetition, then being at the end of a matcher means that we have
        .                       // reached the potential end of the input.
        .                       else {
        .                           eof_items.push(item);
        .                       }
        .                   }
        .                   // We are in the middle of a matcher.
        .                   else {
        .                       // Look at what token in the matcher we are trying to match the current token (`token`)
        .                       // against. Depending on that, we may generate new items.
1,484,295 ( 0.00%)              match item.top_elts.get_tt(idx) {
        .                           // Need to descend into a sequence
   16,360 ( 0.00%)                  TokenTree::Sequence(sp, seq) => {
        .                               // Examine the case where there are 0 matches of this sequence. We are
        .                               // implicitly disallowing OneOrMore from having 0 matches here. Thus, that will
        .                               // result in a "no rules expected token" error by virtue of this matcher not
        .                               // working.
    6,882 ( 0.00%)                      if seq.kleene.op == mbe::KleeneOp::ZeroOrMore
        .                                   || seq.kleene.op == mbe::KleeneOp::ZeroOrOne
        .                               {
    6,826 ( 0.00%)                          let mut new_item = item.clone();
   13,652 ( 0.00%)                          new_item.match_cur += seq.num_captures;
   17,065 ( 0.00%)                          new_item.idx += 1;
   20,478 ( 0.00%)                          for idx in item.match_cur..item.match_cur + seq.num_captures {
    9,741 ( 0.00%)                              new_item.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));
        .                                   }
        .                                   cur_items.push(new_item);
        .                               }
        .           
    3,441 ( 0.00%)                      let matches = create_matches(item.matches.len());
   41,292 ( 0.00%)                      cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos {
    3,441 ( 0.00%)                          stack: smallvec![],
        .                                   sep: seq.separator.clone(),
    3,441 ( 0.00%)                          seq_op: Some(seq.kleene.op),
        .                                   idx: 0,
   17,205 ( 0.00%)                          matches,
    6,882 ( 0.00%)                          match_lo: item.match_cur,
        .                                   match_cur: item.match_cur,
    6,882 ( 0.00%)                          match_hi: item.match_cur + seq.num_captures,
        .                                   up: Some(item),
   24,087 ( 0.00%)                          top_elts: Tt(TokenTree::Sequence(sp, seq)),
        .                               })));
        .                           }
        .           
        .                           // We need to match a metavar (but the identifier is invalid)... this is an error
        .                           TokenTree::MetaVarDecl(span, _, None) => {
        .                               if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {
        .                                   return Error(span, "missing fragment specifier".to_string());
        .                               }
-- line 565 ----------------------------------------
-- line 568 ----------------------------------------
        .                           // We need to match a metavar with a valid ident... call out to the black-box
        .                           // parser by adding an item to `bb_items`.
        .                           TokenTree::MetaVarDecl(_, _, Some(kind)) => {
        .                               // Built-in nonterminals never start with these tokens, so we can eliminate
        .                               // them from consideration.
        .                               //
        .                               // We use the span of the metavariable declaration to determine any
        .                               // edition-specific matching behavior for non-terminals.
  947,855 ( 0.00%)                      if Parser::nonterminal_may_begin_with(kind, token) {
        .                                   bb_items.push(item);
        .                               }
        .                           }
        .           
        .                           // We need to descend into a delimited submatcher or a doc comment. To do this, we
        .                           // push the current matcher onto a stack and push a new item containing the
        .                           // submatcher onto `cur_items`.
        .                           //
        .                           // At the beginning of the loop, if we reach the end of the delimited submatcher,
        .                           // we pop the stack to backtrack out of the descent.
   94,305 ( 0.00%)                  seq @ (TokenTree::Delimited(..)
        .                           | TokenTree::Token(Token { kind: DocComment(..), .. })) => {
        .                               let lower_elts = mem::replace(&mut item.top_elts, Tt(seq));
   18,861 ( 0.00%)                      let idx = item.idx;
  132,027 ( 0.00%)                      item.stack.push(MatcherTtFrame { elts: lower_elts, idx });
   75,444 ( 0.00%)                      item.idx = 0;
        .                               cur_items.push(item);
        .                           }
        .           
        .                           // We just matched a normal token. We can just advance the parser.
  374,559 ( 0.00%)                  TokenTree::Token(t) if token_name_eq(&t, token) => {
  164,773 ( 0.00%)                      item.idx += 1;
        .                               next_items.push(item);
        .                           }
        .           
        .                           // There was another token that was not `token`... This means we can't add any
        .                           // rules. NOTE that this is not necessarily an error unless _all_ items in
        .                           // `cur_items` end up doing this. There may still be some other matchers that do
        .                           // end up working out.
        .                           TokenTree::Token(..) | TokenTree::MetaVar(..) => {}
        .                       }
1,735,670 ( 0.00%)          }
  642,894 ( 0.00%)      }
        .           
        .               // Yay a successful parse (so far)!
        .               Success(())
        .           }
        .           
        .           /// Use the given sequence of token trees (`ms`) as a matcher. Match the token
        .           /// stream from the given `parser` against it and return the match.
  837,160 ( 0.00%)  pub(super) fn parse_tt(
        .               parser: &mut Cow<'_, Parser<'_>>,
        .               ms: &[TokenTree],
        .               macro_name: Ident,
        .           ) -> NamedParseResult {
        .               // A queue of possible matcher positions. We initialize it with the matcher position in which
        .               // the "dot" is before the first token of the first token tree in `ms`. `inner_parse_loop` then
        .               // processes all of these possible matcher positions and produces possible next positions into
        .               // `next_items`. After some post-processing, the contents of `next_items` replenish `cur_items`
        .               // and we start over again.
        .               //
        .               // This MatcherPos instance is allocated on the stack. All others -- and
        .               // there are frequently *no* others! -- are allocated on the heap.
        .               let mut initial = initial_matcher_pos(ms);
  418,580 ( 0.00%)      let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];
        .               let mut next_items = Vec::new();
        .           
        .               loop {
        .                   // Matcher positions black-box parsed by parser.rs (`parser`)
        .                   let mut bb_items = SmallVec::new();
        .           
        .                   // Matcher positions that would be valid if the macro invocation was over now
        .                   let mut eof_items = SmallVec::new();
  293,518 ( 0.00%)          assert!(next_items.is_empty());
        .           
        .                   // Process `cur_items` until either we have finished the input or we need to get some
        .                   // parsing from the black-box parser done. The result is that `next_items` will contain a
        .                   // bunch of possible next matcher positions in `next_items`.
        .                   match inner_parse_loop(
        .                       parser.sess,
        .                       &mut cur_items,
        .                       &mut next_items,
-- line 648 ----------------------------------------
-- line 652 ----------------------------------------
        .                   ) {
        .                       Success(_) => {}
        .                       Failure(token, msg) => return Failure(token, msg),
        .                       Error(sp, msg) => return Error(sp, msg),
        .                       ErrorReported => return ErrorReported,
        .                   }
        .           
        .                   // inner parse loop handled all cur_items, so it's empty
  293,518 ( 0.00%)          assert!(cur_items.is_empty());
        .           
        .                   // We need to do some post processing after the `inner_parser_loop`.
        .                   //
        .                   // Error messages here could be improved with links to original rules.
        .           
        .                   // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,
        .                   // either the parse is ambiguous (which should never happen) or there is a syntax error.
1,467,590 ( 0.00%)          if parser.token == token::Eof {
   27,566 ( 0.00%)              if eof_items.len() == 1 {
        .                           let matches =
   49,172 ( 0.00%)                      eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());
   20,673 ( 0.00%)                  return nameize(parser.sess, ms, matches);
        .                       } else if eof_items.len() > 1 {
        .                           return Error(
        .                               parser.token.span,
        .                               "ambiguity: multiple successful parses".to_string(),
        .                           );
        .                       } else {
        9 ( 0.00%)                  return Failure(
        3 ( 0.00%)                      Token::new(
        .                                   token::Eof,
        4 ( 0.00%)                          if parser.token.span.is_dummy() {
        .                                       parser.token.span
        .                                   } else {
        .                                       parser.token.span.shrink_to_hi()
        .                                   },
        .                               ),
        .                               "missing tokens in macro arguments",
        .                           );
        .                       }
        .                   }
        .                   // Performance hack: eof_items may share matchers via Rc with other things that we want
        .                   // to modify. Dropping eof_items now may drop these refcounts to 1, preventing an
        .                   // unnecessary implicit clone later in Rc::make_mut.
1,146,504 ( 0.00%)          drop(eof_items);
        .           
        .                   // If there are no possible next positions AND we aren't waiting for the black-box parser,
        .                   // then there is a syntax error.
  960,241 ( 0.00%)          if bb_items.is_empty() && next_items.is_empty() {
  998,712 ( 0.00%)              return Failure(parser.token.clone(), "no rules expected this token in macro call");
        .                   }
        .                   // Another possibility is that we need to call out to parse some rust nonterminal
        .                   // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.
  745,052 ( 0.00%)          else if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {
        .                       let nts = bb_items
        .                           .iter()
        .                           .map(|item| match item.top_elts.get_tt(item.idx) {
        .                               TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!("{} ('{}')", kind, bind),
        .                               _ => panic!(),
        .                           })
        .                           .collect::<Vec<String>>()
        .                           .join(" or ");
-- line 712 ----------------------------------------
-- line 721 ----------------------------------------
        .                                   n => format!("built-in NTs {} or {} other options.", nts, n),
        .                               }
        .                           ),
        .                       );
        .                   }
        .                   // Dump all possible `next_items` into `cur_items` for the next iteration.
        .                   else if !next_items.is_empty() {
        .                       // Now process the next token
   70,617 ( 0.00%)              cur_items.extend(next_items.drain(..));
   23,539 ( 0.00%)              parser.to_mut().bump();
        .                   }
        .                   // Finally, we have the case where we need to call the black-box parser to get some
        .                   // nonterminal.
        .                   else {
        .                       assert_eq!(bb_items.len(), 1);
        .           
  372,526 ( 0.00%)              let mut item = bb_items.pop().unwrap();
1,037,641 ( 0.00%)              if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {
  186,263 ( 0.00%)                  let match_cur = item.match_cur;
        .                           // We use the span of the metavariable declaration to determine any
        .                           // edition-specific matching behavior for non-terminals.
1,201,053 ( 0.00%)                  let nt = match parser.to_mut().parse_nonterminal(kind) {
        .                               Err(mut err) => {
        .                                   err.span_label(
        .                                       span,
        .                                       format!("while parsing argument for this `{}` macro fragment", kind),
        .                                   )
        .                                   .emit();
        .                                   return ErrorReported;
        .                               }
1,117,578 ( 0.00%)                      Ok(nt) => nt,
        .                           };
  745,052 ( 0.00%)                  item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));
  745,052 ( 0.00%)                  item.idx += 1;
1,117,578 ( 0.00%)                  item.match_cur += 1;
        .                       } else {
        .                           unreachable!()
        .                       }
        .                       cur_items.push(item);
        .                   }
        .           
  419,604 ( 0.00%)          assert!(!cur_items.is_empty());
        .               }
  753,444 ( 0.00%)  }

6,772,178 ( 0.02%)  <counts for unidentified lines in /usr/home/liquid/rust/worktree-benchmarking/compiler/rustc_expand/src/mbe/macro_parser.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./malloc/malloc.c
  ./nptl/pthread_rwlock_common.c
  ./stdlib/msort.c
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/strcmp-avx2.S
  /tmp/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/libsupc++/../../../../gcc-5.5.0/libstdc++-v3/libsupc++/new_op.cc

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
812,079,504 ( 2.17%)  events annotated

